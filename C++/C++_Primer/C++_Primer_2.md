# C++ Primer 第二章 变量和基本类型

C++属于静态类型语言。编译器在编译时会对程序中的变量类型进行检查

静态类型语言：在编译阶段检查类型。编译器负责检查数据类型是否支持要执行的运算，如果试图执行不支持的运算，编译器将报错

动态类型语言：在程序运行期间才去做数据类型的检查。对于动态数据类型语言，不用给任何变量指定数据类型，该语言会在第一次赋值给变量时，在内部将数据类型记录下来



## 2.1 基本内置类型

C++ 基本内置类型包括算术类型和空类型

算术类型包含了字符、整型数、布尔值和浮点数



C++ 语言规定，一个 `int` 至少和一个 `short` 一样大，一个 `long` 至少和一个 `int` 一样大，一个 `long long` 至少和一个 `long` 一样大



内存中最小的单位为 比特

大多数机器的字节由 8 比特构成

大多数计算机将内存中的每个字节与一个数字关联起来

32位操作系统能够支持的最大内存为 4G



`float` 单精度浮点数，6位有效数字

`double` 双精度浮点数，10位有效数字

`float` 和 `double` 在计算代价上相差无几，区别在于有效数字



#### 带符号类型和无符号类型

`unsigned` 表示无符号类型

无符号类型只能表示大于等于 0 的数，而带符号类型可以表示负数



### 2.1.2 类型转换

类型所能表示的值的范围决定了转换的过程：

+ 一个非布尔类型转换成布尔类型时，初始值为 0 则结果为 `false`，否则结果为 `true`
+ 一个布尔类型转换成非布尔类型时，初始值 `false` 则结果为 0，初始值 `true` 则结果为 1
+ 浮点数赋值给整数时，结果仅保留浮点数小数前的部分
+ 整数赋值给浮点数时，结果在小数点后添加 0
+ 当赋值给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数
+ 当赋值给一个带符号类型一个超出表示范围的值时，结果是未定义的



### 2.1.3 字面值常量

一个形如 42 的值被称为**字面值常量**

每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型



整型字面值可以写作十进制、八进制和十六进制

八进制开头为 `0`

十六进制开头为 `0x`



浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用 `E` 或 `e` 表示

默认的，浮点型字面值是一个 `double`



字符串字面值的类型是常量字符构成的数组

编译器在每个字符串的结尾处添加一个空字符 `\0`

字符串字面值的实际长度要比它的内容多 1



## 2.2 变量

变量提供一个具名的、可供程序操作的存储空间

C++ 每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算

变量实际为一块能存储数据并有某种类型的内存空间



初始化和赋值是两个不同操作

初始化的含义是创建变量时赋予一个初始值

赋值的含义是把对象的当前值擦除，而以一个新值来替代



### 2.2.2 变量声明和定义的关系

C++ 语言支持分离式编译：分离式编译允许程序分割成若干个文件，每个文件可以被独立编译



声明(declaration)：使得名字被程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明

定义(definition)：负责创建与名字关联的实体。定义申请了存储空间，也可能为变量赋一个初始值

一个变量可以被声明多次，但只能被定义一次



如果想要声明一个变量而非定义它，就在变量名前添加关键字 `extern`，而且不要显式地初始化变量

没有显式地赋初始化值也是定义



### 2.2.3 标识符

变量命名规范：

+ 标识符要能体现实际含义
+ 变量名一般用小写字母
+ 用户自定义地类名一般以大写字母开头
+ 如果标识符由多个单词组成，则单词间应用明显区分



### 2.2.4 名字的作用域

作用域是程序的一部分，在其中名字有其特定的含义

C++ 语言中大多数作用域都以花括号分离



内层作用域的变量会覆盖外层作用域



## 2.3 复合类型

### 2.3.1 引用

引用为对象起了另外一个名字，引用类型引用另外一种类型

通过将声明符写成 `&d` 的形式来定义引用类型

引用和其引用的对象共享相同的内存地址

> 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字



定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用

引用的初始值必须是一个对象，而不能是一个字符型常量

因为无法令引用重新绑定到另一个对象，因此引用必须初始化

因为引用本身不是一个对象，所以不能定义引用的引用



### 2.3.2 指针

指针实现了对其他对象的间接访问

指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期可以先后指向几个不同的对象



指针存放某个对象的地址，要想获取地址，需要使用**取地址符 `&`**



#### 指针值

指针的值应属下列 4 种状态之一：

+ 指向一个对象
+ 指向紧邻对象所占用空间的下一个位置（尾迭代器）
+ 空指针，意味着指针没有指向任何对象
+ 无效指针，上述情况之外的其他值



使用解引用符可以访问指针指向的对象



#### 空指针

空指针不指向任何对象 `nullptr`



#### 赋值和指针

一旦定义了引用，就无法再令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象

赋值号永远改变的是等号左侧的对象



#### 其他指针操作

只要指针拥有一个合法值，就能将它用在条件表达式中

如果指针的值是 0，条件为 `false`

任何非 0 指针对应的条件值都是 `true`



## 2.4 `const` 限定符

`const` 常量必须初始化



### 2.4.1 `const` 的引用

可以把引用绑定到 `const` 对象上，就像绑定到其他对象上一样

对常量的引用不能被用作修改它所绑定的对象

对于一个常量必须定义常量引用

但是常量引用可以引用一个非常量



### 2.4.2 指针和 `const`

指向常量的指针

```C++
double pi = 3.14;
const double *ptr = &pi;
double  const *ptr = &pi;
```

指向常量的指针不能通过解引用符改变所指的值

指向常量的指针可以指向一个非常量，但是不能通过自己修改这个指向的值



#### `const` 指针

常量指针必须初始化

常量指针指的是指针指向的对象不能改变

但是可以通过解引用来修改对象的值



### 2.4.3 顶层 `const`

顶层 `const` 表示指针本身是个常量

底层 `const` 表示指针所指的对象是一个常量



### 2.4.4 `constexpr` 和常量表达式

常量表达式是指**值不会改变**并且在**编译过程就能得到计算结果**的表达式

字面值属于常量表达式

用常量表达式初始化的 `const` 对象也是常量表达式

常量表达式的值不需要在运行时得到



一个对象是不是常量表达式由它的数据类型和初始值共同决定



C++11 新标准规定，允许将变量声明为 `constexpr` 类型以便由编译器来验证变量的值是否是一个常量表达式

声明为 `constexpr` 的变量一定是一个常量表达式，而且必须用常量表达式初始化



> 一般来说，如果认定变量是一个常量表达式，那就把它声明成 `consexpr` 类型



#### 字面值类型

常量表达式的值需要在编译时得到计算

字面值包括算数类型、引用和指针，以及字面值常量



一个 `constexpr` 指针的初始值必须是 `nullptr` 或者 0，或者是存储于某个固定地址中的对象（常量指针）



#### 指针和 `constexpr`

在 `constexpr` 声明中如果定义了一个指针，限定符 `constexpr` 仅对指针有效，与指针所指的对象无关

```C++
const int *p = nullptr;				// 一个指向整型常量的指针
constexpr int *q = nullptr;			// 一个指向整数的常量指针
```



## 2.5 处理类型

### 2.5.1 类型别名

`typedef` 可以定义类型别名

```C++
typedef double wages;		// wages 是 double 的类型别名
```



C++11 新标准中，使用别名声明来定义类型的别名

```C++
using SI = Sales_item;		// SI 是 Sales_item 的同义词
```



### 2.5.2 `auto` 类型说明符

`auto` 能让编译器替我们去分析表达式所属的类

`auto` 通过初始值来推算变量的类型

使用 `auto` 能在一条语句中声明多个变量，因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型必须一样



### 2.5.3 `decltype` 类型指示符

`decltype` 的作用是选择并返回操作数的数据类型

编译器分析表达式并得到它的类型，却不实际计算表达式的值



`decltype` 会保留顶层 `const` 但是 `auto` 并不会保留



> `decltype((variable))` 的结果永远是引用，而 `decltype(variable)` 结果只有当 `variable` 本身就是一个引用时才是引用



## 2.6 自定义数据类型

预处理器是在编译之前执行的一段程序，可以部分地改变我们所写的程序



头文件保护符：可以防止头文件被多次重复定义

头文件保护符包括 `#define`, `#ifdef`, `#ifndef`, `#endif`

`#define` 指令把一个名字设定为预处理变量

`#ifdef` 和 `#ifndef` 检查某个指定的预处理变量是否已经定义

如果没有定义则会执行后续操作到 `#endif ` 停止

头文件保护符可以保证 `include` 的头文件只被预处理一次，后续遇到时会跳过 `#ifndef ` 和 `#endif` 之间的部分

```C+
#ifndef XXX_H
#define XXX_H

// ...


# endif
```



## 习题

+ 什么是静态类型(statically typed)语言？什么是动态类型(dynamically typed)语言？C++属于哪一种类型？

+ C++ 基本内置类型包括什么？

+ `float` 和 `double` 的区别是什么？

+ 非布尔类型转换成布尔类型的规则？

+ 布尔类型转换成非布尔类型的规则？

+ 浮点数赋值给整数时的类型转换？

+ 当赋值给无符号类型一个超过表示范围的值会发生什么？

+ 计算 `int = -42` 转换成 `unsigned` 的值

+ 什么是分离式编译(separate compilation)？

+ 声明和定义的区别？

+ 如何声明但不定义一个变量？

+ 什么是C++引用？

+ 下面的哪个对引用的定义是不合法的？为什么？

  ```C++
  int &rval1 = 1.01;
  int &rval2 = rval1;
  int &rval3;
  ```

+ 可以重新绑定引用吗？可以定义引用的引用吗？

+ 引用是对象吗？

+ 如何理解对常量的引用引用了一个非常量对象

+ 如何理解下面的代码，v1，v2，v3的值分别是什么？

  ```C++
  int main() {
    int v1 = 1;
    int &v2 = v1;
    int v3 = 3;
    v2 = v3;
  }
  ```

+ 说明指针和引用的主要区别？

+ 什么是常量表达式？

+ 什么是顶层 `const`？什么是底层 `const`？

+ `constexpr` 修饰的指针是顶层指针还是底层指针？

+ `typedef` 和 `using` 的作用？

+ `decltype` 的作用？

+ 解释 `decltype((variable))`和 `decltype(variable)` 的区别

+ 解释头文件保护符？
