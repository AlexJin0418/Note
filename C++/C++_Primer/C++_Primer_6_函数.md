# C++ Primer 第六章 函数

函数是一个命名了的代码块，我们通过调用函数执行相应的代码



## 6.1 函数基础

一个经典的函数定义包含以下部分：返回类型、函数名字、由 0 个或多个形参组成的列表以及函数体



函数的调用完成两项工作：

+ 用实参初始化函数对应的形参
+ 将控制权转移给被调用函数。此时主函数的执行被暂时中断，被调函数开始执行

函数执行的第一步是定义并初始化它的形参



#### 形参和实参

实参是形参的初始值

函数有几个形参，我们就必须提供相同数量的实参



形参：出现在函数定义的地方，形参列表可以包含0个，1个或多个形参。形参规定了一个函数所接受数据的类型和数量。
实参：出现在函数调用的地方，实参的数量和形参一样多。实参的主要作用是初始化形参，并且这种初始化过程是一一对应的。



#### 函数的形参列表

函数的参数列表可以为空，但是不能省略



### 6.1.1 局部对象

在 C++ 语言中，名字有作用域，对象有生命周期

+ 名字的作用域是程序文本的一部分，名字在其中可见
+ 对象的生命周期是程序执行中该对象存在的一段时间



形参和函数体内定义的变量叫做**局部变量**

局部变量会隐藏在外层作用域中同名的其他所有声明



#### 局部静态变量

**局部静态对象（local static object）**在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。
局部静态对象使用static修饰。
当函数在第二次或多次访问时，局部静态对象并不会被重新定义，而是保留了上一次函数被调用时的值。
只有在程序结束后，局部静态对象才会被销毁。



### 6.1.2 函数声明

函数的名字必须在使用之前声明



#### 在头文件中进行函数声明

函数应该在头文件中声明，在源文件中定义



### 6.1.3 分离式编译

分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译



## 6.2 参数传递

每次调用函数时都会重新创建它的形参，并用传入实参对形参进行初始化



当形参是引用类型时，我们说它对应的实参被引用传递，形参将绑定实参。
当形参不是引用类型时，我们说实参的值被拷贝给形参，形参和实参是两个独立的对象。改变形参并不会改变实参的值。



### 6.2.1 传值参数

当初始化一个非引用类型的变量时，初始值被拷贝给变量

此时，对变量的改动不会影响初始值



### 6.2.2 传引用参数

引用形参绑定初始化它的对象

当改变形参时也会改变实参



#### 使用引用避免拷贝

当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象



#### 使用引用形参返回额外信息

一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径



### 6.2.3 `const` 形参和实参

当用实参初始化形参时会忽略掉顶层 `const`

当形参有顶层 `const` 时，传给它常量对象或者非常亮对象都是可以的



#### 指针或引用形参与 `const`

我们可以使用非常量初始化一个底层 `const` 对象，但是反过来不行

同时一个普通的引用必须用相同类型的对象初始化



### 6.2.4 数组指针

数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响

+ 不允许拷贝数组
+ 使用数组时会被转化为指针





## 6.7 函数指针

每一个函数都占用一段内存单元，它们有一个其实地址，指向函数入口地址的指针被称为**函数指针**



函数指针指向的是函数而非对象

```C++
int (*p)(int);		// 函数指针，参数为 int，返回值为 int
int* p(int);		// 是函数，返回的值是一个指针
```



和其他指针一样，函数指针指向某种特定类型

函数的类型由它的返回类型和形参类型共同决定，与函数名无关



函数指针函数名部分必须要有括号

```C++
bool (*pf)(const string &, const string &);
```



#### 使用函数指针

当我们把函数名作为一个值使用时，该函数自动地转换成指针



可以将函数指针作为参数使用，并可以传入函数在函数体内调用





## 习题

+ 形参和实参的区别是什么？

+ 什么是局部静态变量？

+ 什么是分离式编译？

+ 如何理解形参的引用和拷贝？

+ 如何使函数返回多个值？

+ 下面两个定义是否相同？ 

  ```C++
  void func(const int i) {}
  void func(int i) {}
  ```

+ 如果函数的一个形参不会发生改变，那么应该如何定义指针和引用形参？

+ 



<details>
  <summary> 如何向函数中传递一个数组？</summary>

  ``` 
  数组有两个特性：1.不允许拷贝数组；2.使用数组时会将其转换成指针。
  所以当为函数传递一个数组时，实际上传递的是指向数组首元素的指针。
  ```
</details>

<details>
  <summary> 当函数形参传入一个数组时，函数直到这个数组的长度吗？</summary>

  ``` 
  因为数组是以指针的形式传给函数的，所以函数只直到指针表示的是数组的首个元素。
  函数需要其他信息来直到数组的大小。
  ```
</details>

<details>
  <summary> 如何管理指针形参？</summary>

  ``` 
  1. 使用标记指定数组长度：当数组最后一位是一个空字符时，函数会遇到空字符停止。
  2. 使用标准库规范：传递指向数组首元素和尾后元素的指针。
  3. 显式传递一个表示数组大小的形参：将数组的大小以形参的方式传递到函数中。
  ```
</details>

<details>
  <summary> 什么是 initializer_list 形参</summary>

  ``` 
  如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用 initializer_list 类型的形参。
  initializer_list是模板类型，定义initializer_list对象时必须说明列表中所含元素的类型。
  initializer_list中的值是常量值，我们无法改变initializer_list对象中元素的值。
  
  ```
</details>

<details>
  <summary> 函数的返回值是如何被返回的？</summary>

  ``` 
  函数返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。
  如果函数返回引用，则该引用仅是它所引用对象的一个别名。
  ```
</details>

<details>
  <summary> 为什么不要返回局部对象的引用或指针？</summary>

  ``` 
  因为在函数内定义的局部对象会在函数结束后被销毁。
  所以函数终止意味着局部变量的引用将指向不再有效的内存区域。
  ```
</details>

<details>
  <summary>什么是重载函数(overloaded) </summary>

  ``` 
  同一作用域内的几个函数名字相同但形参列表不同，称之为重载函数。
  编译器会根据传递的实参类型推断想要的是哪个函数。
  ```
</details>

<details>
  <summary>如何定义重载函数？</summary>

  ``` 
  定义重载函数时应使得函数的形参数量或者函数形参类型有所不同。
  不允许两个函数除了返回类型外其他所有的要素都相同。 
  ```
</details>

<details>
  <summary>当调用重载函数时的三种情况</summary>

  ``` 
  1. 编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码
  2. 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误
  3. 有多于一个函数可以匹配，但是每一个都不是明显的最佳匹配。此时也将发生错误，称为二义性调用
  ```
</details>

<details>
  <summary>什么是默认实参 default argument </summary>

  ``` 
  某些函数有一种形参，在函数的很多次调用中它们都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的默认实参。
  默认实参作为形参的初始值出现在形参的列表当中。
  一旦某个形参被赋予了默认实参，它后面的所有形参都必须有默认值。
  ```
</details>

<details>
  <summary>默认实参重复声明</summary>

  ``` 
  头文件中多次声明同一个函数是合法的。但是给定作用域中一个形参只能被赋予一次默认实参。
  函数的后续声明只能为之前那些没有默认值的形参添加默认实参。
  ```
</details>

<details>
  <summary>默认实参的初始值？ </summary>

  ``` 
  局部变量不能作为默认实参的初始值，除此之外，只要表达式的类型能够转换成形参所需的类型，该表达式就能作为默认实参。
  ```
</details>

<details>
  <summary>什么是内联函数？ </summary>

  ``` 
  内联函数的声明是在函数声明的前面加上 inline。程序调用函数时需要保存当前程序的寄存器；拷贝实参；转向新的位置执行等等。
  对于一些内容比较小的程序，调用函数要比直接执行表达式更耗费时间。
  为了保留函数的优秀特性，可以将函数声明为内联函数，这样编译器编译时会将函数体看作表达式来进行编译。
  内联机制用于优化规模较小，流程直接，频繁调用的函数。
  ```
</details>

<details>
  <summary>什么是 Constexpr 函数？ </summary>

  ``` 
  constexpr 函数是指能用于常量表达式的函数。
  定义 constexpr 函数的方法与其他函数类似，不过要遵循几项约定：
  函数的返回类型以及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条 return 语句。
  ```
</details>


<details>
  <summary> 函数匹配的两个步骤是什么？</summary>

  ``` 
  1. 寻找候选函数
  2. 通过调用提供的实参，从候选函数中选出能被实参所调用的函数。新选出的函数被称为可行函数。
  3. 如果有多个函数满足可行函数，则寻找最佳匹配，寻找形参类型与实参类型最匹配的那个可行函数。
  当有多个函数满足可行函数时，如果有且只有一个函数满足下列条件，则匹配成功：
    该函数每个实参的匹配都不劣于其他可行函数需要的匹配
    至少有一个实参的匹配优于其他可行函数提供的匹配
  ```
</details>


<details>
  <summary> 什么是候选函数？</summary>

  ``` 
  候选函数是函数匹配中选定本次调用对应的重载函数集。
  候选函数具有两个特征：与被调用函数同名，其声明在调用点可见。
  ```
</details>

<details>
  <summary> 什么是可行函数？</summary>

  ``` 
  通过调用函数的实参，从候选函数中选出能被实参所调用的函数。新选出的函数被称为可行函数。
  可行函数具有两个特征：其形参数量与调用提供的实参数量相等，每个实参的类型与对应的形参类型相同，或者能转化成形参的类型。
  ```
</details>

<details>
  <summary> 什么是函数指针？</summary>

  ``` 
  函数指针是指向函数的指针。函数指针的类型由函数的返回值类型和形参类型共同决定。
  ```
</details>

<details>
  <summary> 如何理解下面的声明？ bool (*pf) (const string &, const string &);</summary>

  ``` 
  (*pf)表示指针，指针指向的是一个函数，其中该函数的参数是两个 const string 的引用，函数返回值是 bool 类型。
  ```
</details>

<details>
  <summary> 可以直接使用指向函数的指针来调用该函数吗？</summary>

  ``` 
  可以使用指向函数的指针来调用函数，无需提前解引指针。
  调用函数指针 == 调用函数指针解引 == 调用函数名。
  ```
</details>

<details>
  <summary> 当定义重载函数的指针时需要注意什么？</summary>

  ``` 
  当定义重载函数的指针时需要明确到底应该选用哪个函数。
  函数指针的形参列表和返回值类型必须要和某一个重载函数相匹配。
  ```
</details>

<details>
  <summary> 函数可以作为函数的形参吗？</summary>

  ``` 
  函数不可以作为函数的形参，但是指向函数的指针可以作为函数的形参。
  当调用函数时，可以直接将函数名作为实参使用，它会自动转换成指针。
  ```
</details>

