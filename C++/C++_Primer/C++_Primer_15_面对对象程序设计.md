# C++ Primer 第十五章 面向对象程序设计

面向对象程序设计基于三个基本概念：数据抽象（封装）、继承和动态绑定（多态）

继承和动态绑定对程序的编写有两方面的影响：一是我们可以更容易地定义与其他类相似但不完全相同的新类；二是在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉它们的区别



## 15.1 OOP 概述

面向对象程序设计的核心思想是数据抽象、继承和动态绑定

通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象



#### 继承

通过继承联系在一起的类构成一种层次关系

通常在层次关系的根部有一个**基类（base class）**，其他类似直接或间接地从基类继承而来，这些继承得到的类成为**派生类（derived class）**

基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自持有的成员



C++ 语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待

对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成**虚函数（virtual function）**



```C++
// Quote
class Quote {
public:
    std::string isbn() const;
    virtual double net_price(std::size_t n) const;
};
```



派生类通过使用**类派生列表（class derivation list）**明确指出它是从哪些个基类继承而来

**\*\*C++ 支持多继承\*\***



```C++
class Bulk_quote : public Quote {
public:
    double net_price(std::size_t) const override;
};
```



派生类必须在其内部对所有重新定义的虚函数进行声明

C++11 新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后加一个 `override` 关键字



#### 动态绑定

通过使用动态绑定，我们能用同一段代码分别处理 `Quote` 和 `Bulk_quote` 的对象

```C++
double print_total(ostream &os, const Quote &item, size_t n)
{
    // 根据传入的形参的对象类型调用 Quote::net_price
   	// 或者 Bulk_quote::net_price
    double ret = item.net_price(n);
    os << "ISBN: " << item.isbn() << endl;
    return ret;
}
```

因为 `print_total` 的 `item` 形参是基类 `Quote` 的引用，所以我们即能使用基类调用这个函数，也可以使用派生类调用该函数

又因为 `print_total` 是使用引用类型调用 `net_price` 函数的，所以实际传入的对象类型将决定到底执行哪个版本的 `net_price` 函数



> 函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定又被称为运行时绑定
>
> 在C++语言中，当我们使用基类的引用调用一个虚函数时将发生动态绑定



## 15.2 定义基类和派生类

完成 `Quote` 类的定义

```C++
class Quote {
public:
    Quote() = default;
    Quote(const std::string &book, double sales_price):
    				bookNo(book), price(sales_price) {}
    std::string isbn() const { return bookNo; }
    // 返回给定数量的书籍的销售总额
    // 派生类负责改写并使用不同的折扣计算算法
    virtual double net_price(std::size_n) const
    { return n * price; }
    virtual ~Quote() = default;		// 虚析构函数
private:
    std::string bookNo;
protected:
   	double price = 0.0;
};
```

基类通常应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此



#### 成员函数与继承

派生类可以继承基类的成员

派生类需要对这些操作提供自己的新定义以覆盖从基类继承而来的旧定义



基类有两种成员函数

1. 基类希望其派生类进行覆盖的函数
2. 基类希望派生类直接继承不要改变的函数



对于基类希望派生类进行覆盖的函数，通常将其定义为虚函数

当我们使用**指针或引用**调用虚函数时，会根据对象类型不同，执行基类或者派生类的版本



任何构造函数之外的**非静态函数**都可以是虚函数

关键字 `virtual` 只能出现在类内部的声明语句之前而不能用于类外部的函数定义

成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时



虚函数的目的是实现动态多态，即在运行时决定调用函数的对象，而**静态函数**是在编译时就确定了函数体所以静态函数不能是虚函数

同时，虚函数的实现需要 `this` 指针来调用虚函数表确定具体调用的虚函数，而静态函数属于整个类，所以没有 `this` 指针

同理，**内联函数**在编译时需要确定，且内联函数等同于函数体复制，所以也不能作为虚函数

**构造函数**的作用是用来构造一个对象，构造出对象后才能在对象中找到虚函数，所以构造函数也不能为虚函数



#### 访问控制与继承

派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员

派生类可以访问公有成员，但不能访问私有成员

对于 `protected` 修饰的成员，派生类可以访问，但是其他用户禁止访问

**\*\*派生类会继承基类的私有成员，但是派生类无法访问基类的私有成员\*\***



### 15.2.2 定义派生类

派生类必须通过使用派生类列表明确指出它是从哪个基类继承而来的

每个基类前面可以有以下三种访问说明符中的一个：`public`、`protected` 或者 `private`

派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明

```C++
class Bulk_quote : public Quote {
public:
    Bulk_quote() = default;
    Bulk_quote(const std::string&, double, std::size_t, double);
    // 覆盖基类的函数版本以实现基于大量购买的折扣政策
    double net_price(std::size_t) const override;
private:
    std::size_t min_qty = 0;
    double discount = 0.0;
};
```

派生类从基类那里继承了 `isbn()`、`bookNo` 和 `price` 等数据成员

同时还定义了 `net_price` 的新版本



如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分

我们能将**公有派生类型的对象**绑定到基类的引用或指针上



#### 派生类中的虚函数

派生类经常但不总是覆盖它继承的虚函数

如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通函数，派生类会直接继承其在基类中的版本



#### 派生类对象及派生类向基类的类型转换

一个派生类对象包含多个组成部分：一个含有派生类自己定义的成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个

因此，一个 `Bulk_quote` 对象将包含四个数据元素：从 `Quote` 继承而来的 `bookNo` 和 `price` 数据成员，以及 `Bulk_quote` 自己定义的 `min_qty` 和 `discount` 成员

在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的



因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象使用

而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上

```C++
Quote item;				// 基类对象
Bulk_quote bulk;		// 派生类对象
Quote *p = &item;		// p 指向 Quote 对象
p = &bulk;				// p 指向 bulk 的 Quote 部分
Quote &r = bulk;		// r 绑定到 bulk 的 Quote 部分
```

这种转换被称为**派生类到基类的转换**

我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；同样的，我们也可以把派生类对象的指针用在需要基类指针的地方



#### 派生类构造函数

尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员

和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分



> 每个类控制它自己的成员初始化过程



```C++
Bulk_quote(const std::string& book, double p, std::size_t qty, double disc) :
				Quote(book, p), min_qty(qty), discount(disc) {}
```

该函数将它的前两个参数传递给 `Quote` 的构造函数，由 `Quote` 的构造函数负责初始化 `Bulk_quote` 的基类部分

当 `Quote` 构造函数体结束后，我们构建的对象的基类部分初始化完成

接下来初始化由派生类直接定义 `min_qty` 成员和 `discount` 成员

最后运行 `Bulk_quote` 构造函数的函数



除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化

如果想使用其他的基类构造函数，我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值



> 首先初始化基类部分，然后按照声明的顺序依次初始化派生类的成员



#### 派生类使用基类成员

派生类可以访问基类的公有成员和受保护成员

对于派生类的一个成员来说，它使用派生类成员的方式与使用基类成员的方式没什么不同



#### 继承与静态成员

如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义

不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例



静态成员遵循通用的访问控制规则，如果基类中的成员是 `private` 的，则派生类无权访问

假设某静态成员是可访问的，则我们既可以通过基类使用它也能通过派生类使用它



#### 派生类的声明

派生类的声明与其他类差别不大，声明中包含类名但是不包含它的派生列表

```C++
class Bulk_quote;		// 声明派生类的方式
```

声明只是令程序知晓某个名字的存在

派生列表以及与定义有关的其他细节必须与类的主体一起出现



#### 被用作基类的类

如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明：

```C++
class Quote;		// 声明但未定义
class Bulk_quote : public Quote { ... };		// 错误：Quote 必须被定义
```



一个类是基类，同时它也可以是一个派生类

```C++
class Base {};
class D1: public Base {};
class D2: public D1 {};
```

`Base` 是 `D1` 的直接基类，同时是 `D2` 的间接基类

对于一个最终的派生类来说，它会继承其直接基类的成员；该直接基类的成员又含有其基类的成员；依此类推直至继承链的顶端

因此，最终的派生类将包含它直接基类的子对象以及每个间接基类的子对象



#### 防止继承的发生

有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类

为了实现这一目的，C++11 新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 `final`

```C++
class NoDerivated final { ... };		// NoDerivated 不能作为基类
class Base { ... };
class Last final : Base { ... };		// Last 可以继承 Base，但不能作为基类
```



### 15.2.3 类型转换与继承

可以将基类的指针或引用绑定到派生类对象上

当使用基类的引用或指针时，实际上我们并不清楚该引用所绑定对象的真实类型

该对象可能是基类的对象，也可能是派生类的对象



我们也可以将一个派生类对象存放在基类的智能指针内



#### 静态类型与动态类型

当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的**静态类型**与该表达式对象的**动态类型**区分开来

表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型

动态类型则是变量或表达式表示的内存中的对象的类型；动态类型知道运行时才可知



比如

```C++
double ret = item.net_price(n);
```

其中 `item` 的静态类型是 `Quote&`，这是在函数声明时就定义好的类型

`item` 的动态类型是未知的，只有在运行时才知道传入的对象是 `Quote` 类型还是 `Bulk_quote` 类型



如果表达式既不是引用也不是指针，则它的动态类型和静态类型永远都是一样的



> 基类的指针和引用的静态类型可能与其动态类型不一致



#### 不存在从基类向派生类的隐式类型转换

之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该基类部分上

一个基类的对象既可以以独立的形式存在，也可以作为派生类对象的一部分存在

如果基类对象不是派生类对象的一部分，则它只含有基类定义的成员，而不含有派生类定义的成员



因为一个基类的对象可能是派生类对象的一部分，也可能不是，所以不存在从基类像派生类的自动类型转换

如何可以进行类型转换，则可能会发生基类访问派生类内的成员，而该成员可能并未在基类中定义



#### 在对象之间不存在类型转换

派生类向基类的自动类型转换只针对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换



当我们初始化或赋值一个类型的对象时，实际上是在调用构造函数或者赋值运算符

这些成员函数都包含一个参数，该参数的类型是类类型的 `const` 版本的引用

因为这些成员接受引用作为参数，所以派生类向基类的转换允许我们给基类的拷贝/移动操作传递一个派生类的对象



当我们给基类的构造函数传递一个派生类对象时，实际运行的构造函数是基类中定义的那个

当我们用一个派生类对象为一个基类对象初始化或者赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉



存在继承关系类型之间的转换规则：

+ 从派生类向基类的类型转换只对指针或引用类型有效
+ 基类向派生类不存在隐式类型转换
+ 和任何其他成员一样，派生类向基类地类型转换也可能由于访问受限而变得不可行



## 15.3 虚函数

在 C++ 语言中，当使用基类的引用或指针调用一个虚函数成员会执行动态绑定，因为我们直到运行时才能知道到底调用了哪个版本的虚函数

所以所有的虚函数都必须有定义



#### 对虚函数的调用可能在运行时才被解析

当某个虚函数通过指针或者引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数

被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个



**动态绑定只有当我们通过指针或引用调用虚函数时才会发生，因为只有引用和指针是在运行期才确定对象的类型**

当我们通过一个具有普通类型的表达式调用虚函数时，在编译时就会将调用的版本确定下来



> 当我们使用基类的引用或指针调用基类中定义的一个函数时，我们并不知道该函数真正作用的对象是什么类型，因为它可能是一个基类的对象也可能是一个派生类的对象。如果函数是虚函数，则直到运行时才会决定到底执行哪个版本，判断的依据是引用或指针所绑定的对象的真实类型

> 对非虚函数的调用在编译时进行绑定。通过对象进行的函数调用也在编译时绑定。对象的类型是确定不变的，我们无论如何都不可能令对象的动态类型和静态类型不一致。因此，通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本上

**\*\*当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用\*\***



#### 派生类中的虚函数

一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数

一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致

派生类中的虚函数的返回类型也必须与基类函数匹配 - 当类的虚函数返回类型是类本身的指针或引用时，上述规则无效



#### final 和 override 说明符

派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为

编译器将认为新定义的这个函数与基类中原有的函数是相互独立的

这意味着派生类并没有覆盖掉基类函数中的虚函数



通过使用 `override` 我们可以显式地标明派生类中的虚函数

如果我们使用 `override` 标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错



#### 虚函数与默认实参

虚函数可以拥有默认实参

如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定



如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此

> 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致



#### 回避虚函数机制

我们可以使用作用域运算符来强制执行某一个版本的虚函数，而不要进行动态绑定

```C++
double undicounted = baseP->Quote::net_price(42);		// 强行调用 Quote 的 net_price 函数无论 baseP 实际指向的对象类型是什么
```

什么时候需要回避函数的默认机制呢？当一个派生类想要调用其基类定义的虚函数版本时



## 15.4 抽象基类

#### 纯虚函数

纯虚函数表示一个没有意义的函数

纯虚函数无须定义，通过在函数体的位置书写 `=0` 就可以将一个虚函数说明为纯虚函数

`=0` 只能出现在类内部的虚函数声明语句处

```C++
double net_price(std::size_t) const = 0;
```

我们可以为纯虚函数定义函数体，但是函数体必须定义在类的外部

我们不能在类的内部为一个 `=0` 的函数提供函数体



#### 含有纯虚函数的类是抽象基类

含有或者未经覆盖直接继承纯虚函数的类是抽象基类

抽象基类负责定义接口，而后续的其他类可以覆盖接口

我们不能创建一个抽象基类的对象



> 未覆盖直接继承纯虚函数的类也是抽象类



#### 派生类构造函数只初始化它的直接基类

每个类各自控制其对象的初始化过程

派生类会将构造函数的参数传递给它的直接基类

而它的直接基类会调用自己的直接基类的构造函数完成初始化

但是派生类不会调用间接基类的构造函数



## 15.5 访问控制与继承

每个类分别控制自己的成员初始化过程

与此类似，每个类还分别控制着其成员对于派生类来说是否可访问



#### 受保护的成员

一个类使用 `protected` 关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员

和私有成员类似，受保护的成员对于类的用户来说是不可访问的

和公有成员类似，受保护的成员对于类的派生类的成员和友元是可以访问的

派生类的成员或友元只能通过派生类对象来访问基类的受保护成员

派生类对于一个基类对象中受保护成员没有任何访问权

```C++
class Base {
protected:
    int prot_mem;
};

class Sneaky : public Base {
    friend void clobber(Sneaky&);			// 友元可以访问 Sneaky::prot_mem
    friend void clobber(Base&);				// 友元不能访问 Base::prot_mem
    int j;
};
// 正确：clobber 能访问 Sneaky 对象的 private 和 protected 成员
void clobber(Sneaky &s) { s.j = s.prot_men = 0; }
// 错误：clobber 不能访问 Base 的 protected 成员
void clobber(Base &b) { }
```

因为 `clobber` 并不是 `Base` 的友元，所以不能直接访问 `Base` 中受保护的成员



#### 公有、私有和受保护继承

某个类对其继承而来的成员的访问权限受限到两个因素的影响：

+ 在基类中该成员的访问说明符
+ 在派生类的派生列表中的访问说明符



派生类向基类转换的可访问性：

+ 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护或私有的，则用户代码不能使用该转换
+ 不论 D 以什么方式继承 B，D 的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的
+ 如果 D 继承 B 的方式是公有的或受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换；反之，如果 D 继承 B 的方式是私有，则不能使用



派生列表中继承访问规则：

+ `public` 公有继承：
  + 继承的基类各成员各属性不变
  + 派生类成员只能访问基类的 `public/protected` 成员
  + 派生类对象只能访问基类的 `public` 成员
+ `protected` 保护继承：
  + 继承时基类各成员属性变成 `protected`
  + 派生类成员可以访问基类 `public/protected` 成员
  + 派生对象不能访问基类的任何成员
+ `private` 私有继承：
  + 继承时基类各成员属性变成 `private`
  + 派生类成员可以访问基类 `public/protected` 成员
  + 派生对象不能访问基类的任何成员



派生访问说明符对于派生类的成员能否访问其直接基类的成员没什么影响

对基类成员的访问权限只与基类中的访问说明符有关



#### 友元与继承

就像友元关系不能传递一样，友元关系同样也不能继承

基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员

友元不能访问派生类的成员

但是基类的友元可以访问派生类中继承于基类的成员



#### 默认的继承保护级别

`class` 关键字定义的派生类是默认私有继承的

`strcut` 关键字定义的派生类是默认公有继承的

`class` 和 `struct` 唯一的区别在于默认成员访问说明符以及默认派生访问说明符



> 一个私有派生的类最好显式地将 `private` 声明出来，而不要仅仅依赖于默认的设置
>
> 显式声明的好处是可以令私有继承关系清晰明了，不至于产生误会



## 15.6 继承中的类作用域

每个类定义自己的作用域，在这个作用域内我们定义类的成员

当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内

如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义



正是因为这一层的嵌套关系，所以派生类才能像使用自己的成员一样使用基类的成员



#### 在编译时进行名字查找

一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的

一个类的成员只能由其派生类对象、引用或指针使用，其基类对象无法使用派生类的对象



#### 名字冲突与继承

和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域的名字将隐藏定义在外层作用域的名字

> 派生类的成员将隐藏同名的基类成员



#### 通过作用域运算符来使用隐藏的成员

我们可以通过作用域运算符来使用一个被隐藏的成员

作用域运算符将覆盖掉原有的查找规则，并指示编译器从指定的类的作用域开始查找对象

> 除了覆盖继承而来的虚函数外，派生类最好不要重用其他定义在基类中的名字



当成员名字相同时，即使派生类成员和基类成员的形参列表不一样，基类成员也会被隐藏掉

编译器会先进行名字查找，当查找到了后再进行类型检查



#### 虚函数与作用域

基类与派生类中的虚函数必须有相同的形参列表

如果基类与派生类的虚函数接受的实参不同，则我们无法通过基类的引用或指针调用派生类的虚函数了

如果派生类有一个和基类虚函数重名但是形参列表不同的函数，则该函数并没有覆盖基类的虚函数，此时派生类内有两个同名的函数

+ 继承自基类的虚函数
+ 自己定义的重名非虚函数



#### 通过基类调用隐藏的虚函数

通过基类的指针或引用调用时，如果基类中没有某个函数，即使派生类中有该函数也会报错

如果调用的是非虚函数，则不会发生动态绑定，实际调用的版本由指针的静态类型对象决定



## 15.7 构造函数与拷贝控制

和其他类一样，位于继承体系中的类也需要控制当其对象执行一系列操作时发生什么样的行为，这些操作包括创建、拷贝、移动、赋值和销毁



### 15.7.1 虚析构函数

继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数



如果我们 `delete` 一个动态分配的对象的指针时将执行析构函数

如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况

这样的话，编译器需要清楚应该执行基类的析构函数还是派生类的析构函数

我们通过在基类中将析构函数定义成虚函数以确保执行正确的版本



只要是基类的析构函数是虚函数，那么派生类的析构函数就是虚函数

如果基类的析构函数不是虚函数，则 `delete` 一个指向派生类对象的基类指针将产生未定义行为

一个基类总是需要析构函数



#### 虚析构函数将组织合成移动操作

当一个类定义了虚构函数，编译器将不会为这个类合成移动操作



### 15.7.2 合成拷贝控制与继承

基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：

它们对类本身的成员依次进行初始化、赋值或销毁的操作

这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类进行初始化、赋值或销毁的操作



大多数基类都会定义一个虚析构函数。因此在默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作

如果我们需要执行移动操作时，我们需要在基类中自己定义



### 15.7.3 派生类的拷贝控制成员

派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分

派生类的拷贝和移动构造函数再拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员

但是析构函数只负责销毁派生类自己分配的资源



默认情况下，基类默认构造函数初始化派生类对象的基类部分

如果我们想拷贝或移动基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类拷贝构造函数



#### 派生类析构函数

派生类析构函数只负责销毁由派生类自己分配的资源

派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后



如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本



### 15.7.4 继承的构造函数

在 C++11 新标准中，派生类能够重用其直接基类定义的构造函数

派生类继承基类构造函数的方式是提供一条注明了直接基类名的 `using` 声明语句

当 `using` 用作构造函数时，将令编译器产生代码

对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数

对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数



当一个基类构造函数含有默认实参时，这些实参并不会被继承



默认、拷贝和移动构造函数不会被继承

这些构造函数按照正常规则被合成



## 15.8 容器与继承

当我们使用容器存放继承体系中的对象时，通常必须采用间接存储的方式

因为不允许容器中保存不同类型的元素，所以我们不能把具有继承关系的多种类型的对象直接放在容器当中



> 当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”，因此容器和存在继承关系的类型无法兼容



#### 在容器中放置指针而非对象

当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针

这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型



## 习题

+ 基类与派生类的关系？

+ 什么是虚函数？

+ 什么是类派生列表？派生类如何继承自基类？

+ C++支持多继承吗？

+ 派生类如何显式地注明将使用哪个成员函数来改写基类的虚函数？

+ 派生类需要声明几个基类的虚函数？

+ 什么是动态绑定？

+ 什么时候会发生动态绑定？

+ 哪些函数可以被声明为虚函数？

+ 在什么阶段可以声明虚函数？

+ 虚函数和普通成员函数在解析过程中的区别？

+ `protected` 访问说明符与 `private` 的区别？

+ 什么类型的派生类对象可以绑定在基类的引用或指针上？

+ 如果派生类没有覆盖其基类的某个虚函数会发生什么？

+ 如何理解一个派生类对象包含多个组成部分？

+ 派生类对象是如何被当作基类对象使用的？

+ 派生类对象初始化时的构造顺序是什么样的？

+ 静态类成员在继承体系中是怎么样的？派生类可以使用基类定义的静态成员吗？

+ 直接基类和间接基类之间的关系？

+ `final` 关键字的作用？

+ 下面哪条声明语句是不正确的？

  ```C++
  class Base { .... };
  class Derived: public Derived {};
  class Derived: privated Base {};
  class Derived: public Base {};
  ```

+ 什么是变量的静态类型？什么是对象的动态类型？

+ 什么时候表达式的动态类型和静态类型是一样的？

+ 为什么只存在由派生类到基类的类型转换？

+ 当使用一个派生类为基类类型对象初始化或者赋值时会发生什么？

+ 为什么动态绑定只发生于指针和引用调用虚函数？如果使用普通类型调用虚函数会发生什么？

+ 如果派生类中有一个函数与基类中的虚函数有相同的名字但是形参列表不同，这样合法吗？

+ `override` 关键字的作用？

+ 如果派生类中有一个函数与基类中的虚函数有相同的名字且使用了 `override` 但是形参列表不同，这样合法吗？

+ 有必要将一个成员函数同时声明成 `override` 和 `final` 吗？

+ 如果我们使用派生类传入基类的指针或引用调用的虚函数中，且虚函数由默认实参，这时函数会使用哪个版本的实参？

+ 如何强制调用某一个版本的虚函数？

+ 什么是纯虚函数？

+ 纯虚函数定义在什么位置？

+ 什么是抽象基类？

+ 抽象基类的作用是什么？

+ 抽象基类可以创建对象吗？

+ 派生类的友元和对象在什么情况下可以访问基类的受保护成员？

+ 派生类三种继承的规则？

+ 友元在继承中的规则？

+ `class` 和 `struct` 的默认继承规则？

+ 继承关系中类作用域是怎么样的？

+ 当派生类和基类中有相同名字的成员，编译器会怎么做？

+ 当派生类和基类中有相同名字的成员时，如何使用基类的同名成员？

+ 为什么基类和派生类中的虚函数必须有相同的形参列表？

+ 虚析构函数的作用？为什么一定要定义虚析构函数？

+ 派生类析构函数会销毁哪部分成员？

+ 继承体系析构函数的执行顺序？

+ 当构造函数和虚构函数调用某个虚函数时会调用哪个版本的虚函数？

+ 派生类如何继承基类的构造函数？

+ 

