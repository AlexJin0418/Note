# 动态内存

程序中所使用的对象都有着严格定义的生存期

全局对象在程序启动时分配，在程序结束时销毁

局部自动变量，当我们进入其定义所在的程序块时被创建，在离开块时销毁

局部 `static` 对象在第一次使用前分配，在程序结束时销毁



C++ 支持动态分配对象

动态分配对象的生存期与它们在哪里创建是无关的，只有当显式地被释放时，这些对象才会销毁



静态内存用来保存局部 `static` 对象、类 `static` 数据成员以及定义在任何函数之外的变量

栈内存用来保存定义在函数内的非 `static` 对象

分配在静态或栈内存中的对象由编译器自动创建和销毁

对于栈对象，仅在其定义的程序块运行时才存在：`static` 对象在使用之前分配，在程序结束时销毁



除了静态内存和栈内存，每个程序还拥有一个内存池

这部分内存被称作**堆**。程序使用堆来存储动态分配的对象 --- 即，那些在程序运行时分配的对象

动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们



## 12.1 动态内存与智能指针

动态内存的管理是通过运算符 `new` 和 `delete` 来完成的

`new` 在动态内存中为对象分配空间并返回一个**指向对象的指针**

`delete` 接受一个动态对象的指针，销毁该对象，并释放与之关联的内存



当忘记释放内存时会产生内存泄漏

当尚有指针引用内存的情况下我们就释放会产生引用非法内存的指针



**智能指针**：负责自动释放所指向的对象

`shared_ptr` 允许多个指针指向同一个对象

`unique_ptr` “独占” 所指向的对象

`weak_ptr` 是一种弱引用，指向 `shared_ptr` 所管理的对象

`auto_ptr` 在C++ 11中已被弃用



### 12.1.1 `shared_ptr` 类

智能指针也是模板类。因此，当我们创建一个智能指针时，必须提供额外的信息

`shared_ptr<string> p1;`

`shared_ptr<list<int>> p2;`

默认初始化的智能指针中保存着空指针 `nullptr`

 

解引一个智能指针返回它指向的对象

如果在一个条件判断中使用智能指针，效果就是**检测它是否为空**



#### `make_shared` 函数

最安全的分配和使用动态内存的方法是调用一个名为 `make_shared` 的标准库函数

此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 `shared_ptr`

```C++
shared_ptr<int> p3 = make_shared<int>(42);		// 指向一个值为 42 的 int 的 shared_ptr
```

类似顺序容器的 `emplace` 成员，`make_shared` 用其参数来构造给定类型的对象

如果我们不传递任何参数，对象就会进行值初始化



#### `shared_ptr` 的拷贝和赋值

当进行拷贝或赋值操作时，每个 `shared_ptr` 都会记录有多少个其他 `shared_ptr` 指向相同的对象：

```C++
auto p = make_shared<int>(42);	// p 指向的对象只有 p 一个引用者
auto q(p);		// p 和 q 指向相同对象，此对象有两个引用者
```

我们可以认为每个 `shared_ptr` 都有一个关联的计数器，通常称其为**引用计数**

无论何时我们拷贝一个 `shared_ptr`，计数器都会递增

例如，将一个 `shared_ptr` 作为参数传递到一个函数中，以及作为函数返回值时，它所关联的计数器都会递增

当我们给 `shared_ptr` 赋予一个新值或是 `shared_ptr` 被销毁时，计数器就会递减

一旦一个 `shared_ptr` 的计数器变为 0，它就会自动释放自己所管理的对象



> 到底是用一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现来决定
>
> 关键是智能指针类能记录多少个 `shared_ptr` 指向相同的对象，并能在恰当的时候自动释放对象



#### `shared_ptr` 自动销毁所管理的对象

当指向一个对象的最后一个 `shared_ptr` 被销毁时，`shared_ptr` 类会通过析构函数自动销毁此对象

`shared_ptr` 的析构函数会递减它所指向的对象的引用计数

如果引用计数变为0，`shared_ptr` 的析构函数就会销毁对象，并释放它占用的内存



> 如果将 `shared_ptr` 存放于一个容器中，而后不再需要全部元素，而只使用其中的一部分，要记得用 `erase` 删除不再需要的那些元素



#### 使用了动态生存期的资源的类

程序使用动态内存出于以下三种原因：

+ 程序不知道自己需要使用多少对象
+ 程序不知道所需对象的准确类型
+ 程序需要在多个对象间共享数据



对于容器来说，分配地资源与对应对象生存期一致。例如，每个 `vector` 拥有其自己的元素。当我们拷贝一个 `vector` 时，原 `vector` 和副本 `vector` 中的元素是相互分离的



一般而言，如果两个对象共享底层数据，当某个对象被销毁时，我们不能单方面地销毁底层数据



### 12.1.2 直接管理内存

C++ 语言定义了两个运算符来分配和释放动态内存

运算符 `new` 分配内存，`delete` 释放 `new` 分配的内存

使用这两个运算符来管理内存非常容易出错



#### 使用 new 动态分配和初始化对象

在自由空间分配的内存是无名的，因此 `new` 无法为其分配的对象命名，而是返回一个**指向该对象的指针**

```C++
int *pi = new int;	// pi 指向一个动态分配的、未初始化的无名对象
```

默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的

我们可以使用直接初始化方式来初始化一个动态分配的对象，也可以使用列表初始化

```C++
int *pi = new int(1024);
string *ps = new string(10, '9');	// *ps = "9999999999"
```

也可以进行值初始化，只需要在后面跟一对空括号即可

```C++
string *ps1 = new string();		// 值初始化为空 string
```



当使用 `auto` 来从初始化器判断我们想要分配的类型时，需要保证括号中仅有单一初始化器

```C++
auto p1 = new auto(obj);		// 推断 p1 的类型为 obj 的类型
auto p2 = new auto{a, b, c};	// 错误，括号中只能有单个初始化器
```



#### 动态分配的 `const` 对象

用 `new` 分配 `const` 对象是合法的



#### 内存耗尽

一旦一个程序用光了它所有可用的内存，`new` 表达式就会失败

默认情况下，如果 `new` 不能分配所要求的内存空间，它会抛出一个类型为 `bad_alloc` 的异常

通过使用 `new (nothrow)` 可以阻止抛出异常，并返回一个空指针



#### 释放动态内存

为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统

我们通过 `delete` 来将动态内存归还给系统

`delete` 接受一个指针，指向我们想要释放的对象



`delete` 表达式执行两个动作：销毁给定的指针指向的对象；释放对应的内存



#### 指针值和 `delete`

我们传递给 `delete` 的指针必须指向动态分配的内存，或者是一个空指针

释放一个块并非 `new` 分配的内存，或者将相同的指针值释放多次，其行为是未定义的

```C++
int i, *pi1 = &i, *pi2 = nullputr;
double *pd = new double(33), *pd2 = pd;
delete i;		// 错误，i 不是一个指针
delete pi1;		// 未定义，pi1指向一个局部变量
delete pd;		// 正确
delete pd2;		// 未定义，因为已经释放了 pd 的内存空间
delete pi2;		// 正确，释放一个空指针总是没有错误的
```

编译器不能分辨一个指针指向的是静态还是动态分配的对象

编译器无法分辨一个指针指向的内存是否已经被释放了

对于这些表达式，编译器会通过编译，尽管它们是错误的



#### 动态对象的生存期直到被释放时为止

对于一个由内置指针管理的动态对象，直到被显式释放之前它都是存在的

函数内定义的指针并不会在离开作用域时释放其指向的对象，只有在显式释放的时候才会被释放

而一旦由函数返回，就无法释放这块内存了



使用 `new` 和 `delete` 管理动态内存存在三个问题：

+ 忘记 `delete` 内存。忘记释放动态内存会导致内存泄漏，因为这部分内存永远不可能被归还给自由空间了
+ 使用已经释放掉的对象。
+ 同一块内存释放两次。当有两个指针指向相同的动态分配对象时，可能发生这种错误。



#### `delete` 之后重置指针值

当我们 `delete` 一个指针后，指针值就变为无效了。虽然指针已经无效，但在很多机器上指针仍然保存着动态内存的地址

在 `delete` 之后，指针就变成了**空悬指针 (dangling pointer)**，即指向一块曾经保存数据对象但现在已经无效的内存的指针



在指针即将要离开其作用域之前释放关掉它所关联的内存

如果需要保留指针，可以在 `delete` 之后将 `nullptr` 赋予指针，这样就清楚地指出指针不指向任何对象



#### 提供了有限地保护

动态内存地一个问题是当多个指针指向相同的内存时，在 `delete` 内存之后重置指针的方法只对当前指针有效

当 `delete` 动态内存后，所有指向这块内存的指针都会失效



### 12.1.3 `shared_ptr` 和 `new` 结合使用

如果我们不初始化一个智能指针，它就会被初始化为一个空指针

同时，我们还可以用 `new` 返回的指针来初始化智能指针

```C++
shared_ptr<double> p1;			// shared_ptr 指向一个空的 double
shared_ptr<int> p2(new int(42));		// p2 指向一个值为 42 的 int
```

接受指针参数的智能指针构造函数是 explicit 的，因此我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式来初始化一个智能指针

```C++
shared_ptr<int> p1 = new int(1024);		// 错误：必须使用直接初始化形式
shared_ptr<int> p2(new int(1024));		// 正确：使用了直接初始化形式
```

**\*\*由于无法将内置指针隐式地转换为智能指针，所以只能使用 `new` 的返回值作为智能指针的参数来初始化\*\***

所以如果想要使用 `new` 创建的内置指针来定义一个新的智能指针，则只能将 `new` 返回的指针作为智能指针的参数来初始化



#### 不要混合使用普通指针和智能指针....

当向函数参数中传递时，需要传递一个 `shared_ptr` 而不是临时的 `shared_ptr`，这样，在函数调用结束之后内存空间就不会被释放掉

```C++
int *x(new int(1024));		// x 是一个普通指针，不是一个智能指针
process(shared_ptr<int>(x));		// 合法的，但是传入的是一个临时的智能指针；函数结束后内存空间会被释放
int p = *x;		// 不合法，因为 x 指向的内存空间被释放，将会变成一个空悬指针
```

 使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法知道对象何时会被销毁



#### ....也不要使用 `get` 初始化另一个智能指针或为智能指针赋值

智能指针类型定义了一个名为 `get` 的函数，它返回一个内置指针，指向智能指针管理的对象

我们需要向不能使用智能指针的代码传递一个内置指针

使用 `get` 返回的指针的代码不能 `delete` 此指针



#### 其他 `shared_ptr` 操作

我们可以使用 `reset` 来将一个新的指针赋予一个 `shared_ptr`



### 12.1.4 智能指针和异常

当出现异常时，原有的代码块会提前终止，而提前终止的后果可能是有些资源得不到正确地释放

如果使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放

函数的退出有两种可能，正常处理结束或发生了异常，无论哪种情况，局部对象都会被销毁，所以智能指针总能够通过析构函数来释放占用的内存空间

而如果使用 `new` 和 `delete` 之间发生了异常，则内存将永远无法被释放掉



### 12.1.5 `unique_ptr`

一个 `unique_ptr` 拥有它所指向的对象

某个时刻只能有一个 `unique_ptr` 指向一个给定的对象

当 `unique_ptr` 被销毁时，它所指向的对象也被销毁



当定义一个 `unique_ptr` 时，需要将其绑定到一个 `new` 返回的指针上

初始化 `unique_ptr` 必须采用直接初始化的形式：

```C++
unique_ptr<double> p1;		// 创建一个空的 unique_ptr
unique_ptr<int> p2(new int(42));		// p2 指向一个值为 42 的 int
```



由于 `unique_ptr` 拥有它指向的对象，因此 `unique_ptr` 不支持普通的拷贝或赋值操作

```C++
unique_ptr<string> p1(new string("Stegosaurus"));
unique_ptr<string> p2(p1);		// 错误，不支持拷贝，此时会有两个指针指向同一块地址
unique_ptr<string> p3;
p3 = p2; 	// 错误，不支持赋值
```



虽然不能拷贝或赋值 `unique_ptr`，但可以通过调用 `release` 或 `reset` 将指针的所有权从一个 `unique_ptr` 转移给另一个 `unique_ptr`

```C++
unique_ptr<string> p2(p1.release());		// release 会返回指针，并销毁原指针变量
unique_ptr<string> p3(new string("Trex"));
p2.reset(p3.release());		// reset 释放了 p2 原来指向的内存，并指向 p3 返回的对象
```



#### 传递 `unique_ptr` 参数和返回 `unique_ptr`

不能拷贝 `unique_ptr` 的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的 `unique_ptr`

比如：在函数中创建一个新的 `unique_ptr` 作为返回值，或者返回一个局部对象的拷贝



#### 向 `unique_ptr` 传递删除器

`unique_ptr` 默认情况下使用 `delete` 释放它指向的对象

我们可以通过重载 `unique_ptr` 的默认删除器来自定义如何释放对象

```C++
unique_ptr<objT, delT> p (new ObjT, fcn);

// Example
connection c = connect(&d);
unique_ptr<connection, decltype(end_connection) *> p (&c, end_connection);
```



### 12.1.6 `weak_ptr`

`weak_ptr` 是一种不控制所指向对象生存期的智能指针，它指向由一个 `shared_ptr` 管理的对象

将一个 `weak_ptr` 绑定到一个 `shared_ptr` 不会改变 `shared_ptr` 的引用计数

一旦最后一个指向对象的 `shared_ptr` 被销毁，对象就会被释放。即使有 `weak_ptr` 指向对象，对象也还会被释放



当我们创建一个 `weak_ptr` 时，要用一个 `shared_ptr` 来初始化

```c++
auto p = make_shared<int>(42);
weak_ptr<int> wp(p);		// wp 弱共享 p；p 的引用计数未改变
```

**\*\*由于是弱共享，创建 `wp` 不会改变 `p` 的引用计数；`wp` 指向的对象可能被释放掉\*\***



由于对象可能不存在，我们不能使用 `weak_ptr` 直接访问对象，而必须调用 `lock`

`lock` 函数检查 `weak_ptr` 指向的对象是否仍然存在。如果存在，`lock` 返回一个指向共享对象的 `shared_ptr` 



通过使用 `weak_ptr`，不会影响用户定义的 `shared_ptr` 对象，但是可以阻止用户访问一个不再存在的动态内存对象



## 12.2 动态数组

C++语言和标准库提供了两种一次分配一个对象数组的方法

C++定义了 `new` 表达式，可以分配并初始化一个对象数组

标准库中包含了 `allocator` 类，允许我们将分配和初始化分离。使用 `allocator` 通常会提供更好的性能和更灵活的内存管理能力



> 大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更简单、更不容易出现内存管理错误并且可能有更好的性能



### 12.2.1 `new` 和数组

使用 `new` 分配一个数组

```C++
int *pia = new int[4];
```

`new` 分配要求数量的对象并返回指向第一个对象的指针



当用 `new` 分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针

由于分配的内存并不是一个数组类型，因此不能对动态数组调用 `begin` 或 `end`

出于相同原因，也不能用范围 `for` 语句来处理动态数组中的元素



**\*\*动态数组并不是数组类型，这是很重要的\*\***



#### 初始化动态分配对象的数组

默认情况下，`new` 分配的对象，不管是单个分配还是数组中的，都是默认初始化的，可以对数组中的元素进行值初始化，方法是在大小之后跟一对括号



在新标准中，我们还可以提供一个元素初始化器的花括号列表，类似于 Java 初始化数组

```C++
int *pia3 = new int[10]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
```



如果列表初始化数量小于大小，则剩余元素进行值初始化

如果列表初始化数量大于大小，则 `new` 表达式失败，不会分配任何内存



**不能使用 `auto` 分配数组**



#### 动态分配一个空数组是合法的

我们可以使用 `new` 来创建一个大小为 0 的动态数组，这是合法的

但是默认数组的大小不能为 0 

```C++
char arr[0];		// 错误；不能定义长度为 0 的数组
char *cp = new char[0];		// 正确；但 cp 不能解引用
```

当我们使用 `new` 分配一个大小为 0 的数组时，`new` 返回一个合法的非空指针

此指针保证与 `new` 返回的其他任何指针都不同

对于零长度的数组来说，此指针就像尾后指针一样，我们可以像使用尾后迭代器一样使用这个指针

但是不能对这个指针进行解引用



#### 释放动态数组

为了释放动态数组，我们使用一种特殊形式的 `delete` -- 在指针前加上一个空方括号对；

```C++
delete p;				// p 必须指向一个动态分配的对象或为空
delete [] pa;			// pa必须指向一个动态分配的数组或为空
```

释放动态数组时，数组中的元素按照逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个

空方括号指示编译器此指针指向一个对象数组的第一个元素



#### 智能指针和动态数组

标准库提供了一个可以管理 `new` 分配的数组的 `unique_ptr` 版本：我们必须在对象类型后面跟一对空括号

```C++
unique_ptr<int[]> up(new int[10]);		// up 指向一个包含 10 个未初始化 int 的数组
up.release();
```

类型中的方括号指出 `up` 指向一个 `int` 数组而不是一个 `int`。因此在销毁管理的指针时会自动使用 `delete[]`



`shared_ptr` 不直接支持管理动态数组。如果希望使用 `shared_ptr` 管理一个动态数组，必须提供自己定义的删除器

默认情况下，`shared_ptr` 使用 `delete` 销毁它指向的对象。如果此对象是一个动态数组，则会产生未定义行为



### 12.2.2 `allocator` 类

`new` 有一些灵活性上的局限，其中一方面表现在它将内存分配和对象构造组合在了一起

类似的，`delete` 将对象析构和内存释放组合在了一起

使用 `new` 时，我们大多已知了对象的值，因为在分配空间的同时我们会初始化对象

如果我们不立即知道需要的值，我们也会在初始化后立即赋予了新值，而后使用时可能会再次赋值



同时，由于动态数组需要元素类型支持默认初始化，所以那些没有默认构造函数的类就不能动态分配数组了



#### `allocator` 类

标准库 `allocator` 类定义在头文件 `memory` 中，它帮助我们将内存分配和对象构造分离开来

它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的



`allocator` 是一个模板类。为了定义一个 `allocator` 对象，我们必须指明这个 `allocator` 可以分配的对象类型

当一个 `allocator` 对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对其位置

```C++
allocator<string> alloc;				// 创建一个可以分配 string 类型的 allocator 对象
auto const p = alloc.allocate(n);		// 分配 n 个未初始化的 string
```







## 习题：

+ 解释下面代码执行的结果

  ```C++
  int *q = new int(42), *r = new int(100);
  r = q;
  auto q2 = make_shared<int>(42), r2 = make_shared<int>(100);
  r2 = q2;
  ```

+ 如利用 `new` 来初始化一个智能指针？

+ 可否直接让 `new` 返回的指针直接赋值初始化一个智能指针？为什么？

+ `unique_ptr` 能否进行拷贝或者赋值？

+ 如何转移 `unique_ptr` 指向的对象到另一个 `unique_ptr`？

+ 下面的 `unique_ptr` 声明中，哪些是合法的，哪些可能导致后续的程序错误？解释每个错误的问题在哪里

  ```C++
  int ix = 1024, *pi = &ix, *p2 = new int(2048);
  typedef unique_ptr<int> IntP;
  IntP p0(ix);
  IntP p1(pi);
  IntP p2(pi2);
  IntP p3(&ix);
  IntP p4(new int(2048));
  IntP p5(p2.get());
  ```

+ `unique_ptr` 中 `relase` 成员函数的作用以及返回值？

+ `shared_ptr` 为什么没有 `release` 成员？

+ 如果创建一个 `weak_ptr`？

+ `weak_ptr` 和 `shared_ptr` 的关系？

+ `weak_ptr` 有什么作用？

+ 可以创建一个长度为 0 的动态数组吗？对于内置数组呢？

+ 释放动态数组时，空方括号的意义？

+ 使用 `new` 进行动态分配有什么局限性？
