# C++ Primer 第九章 顺序容器

一个**容器**就是一些特定类型对象的集合

**顺序容器**为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器的位置相对应



## 9.1 顺序容器概述

顺序容器类型

+ vector：可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢
+ deque：双端队列。支持快速随机访问 `deque.at(pos) / deque[pos]`。在头尾位置插入/删除速度很快
+ list：双向链表。只支持双向顺序访问。在 list 中任何位置进行插入/删除操作速度都很快
+ forward_list：单向链表。只支持单项顺序访问。在链表任何位置进行插入/删除操作速度都很快
+ array：固定大小数组。支持快速随机访问。不能添加或删除元素
+ string：与 vector 相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快



除了固定大小的 array 外，其他容器都提供高效，灵活的内存管理。我们可以添加和删除元素，扩张和收缩容器的大小

string 和 vector 将元素保存在连续的地址空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在这两种容器的中间位置添加或删除元素就会非常耗时：在一次插入或删除操作后，需要移动插入/删除位置之后的所有元素，来保持连续存储。而且，添加一个元素有可能还需要分配额外的存储空间

list 和 forward_list 两个容器的目的是令容器任何位置的添加和删除操作都很快速。作为代价，这两个容器不支持元素的随机访问：为了访问一个元素，我们只能遍历整个容器

deque 支持快速随机访问，所以在 deque 的中间位置添加或删除元素的代价很高。但是，在 deque 的两端添加或删除元素都是很快的，与 list 或 forward_list 添加删除元素的速度相当

array 和 forward_list 是 C++ 新标准增加的类型。与内置数组相比，array 是一种更安全，更容易使用的数组类型。array 对象的大小是固定的，因此 array 不支持添加和删除元素以及改变容器大小操作

为了达到与最好的手写的单向链表数据结构相当的性能，forward_list 没有 size 操作，因为保存或计算其大小就会比手写链表多出额外的开销

**\*\*通常，使用 vector 是最好的选择\*\***



选择顺序容器需要判断：是否需要在容器中插入或删除元素，是否需要随机访问



## 9.2 容器库概览

每个容器都定义在一个头文件中，文件名与类型名相同

容器均为模板类，我们必须提供额外信息来生成特定的容器类型

```C++
list<Sales_data>		// 保存 Sales_data 对象的 list
deque<double>			// 保存 double 的 deque
```



#### 对容器可以保存的元素类型的限制

顺序容器可以保存任意类型的元素。我们可以定义一个容器，其元素的类型是另一个容器

顺序容器构造函数的一个版本接受容器大小参数，它使用了元素类型的默认构造函数。但是某些类没有默认构造函数。我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数，同时还要提供元素初始化器



### 9.2.1 迭代器

一个**迭代器范围**由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置。这两个迭代器通常被称为 begin 和 end，它们标记了容器中元素的一个范围

第二个迭代器 end 从来都不会指向范围中的最后一个元素，而是指向尾元素之后的位置

迭代器范围中的元素包括 begin 所表示的元素以及 begin 开始至 end 之间的所有元素

迭代器 begin 和 end 必须指向相同的容器。end 可以与 begin 指向相同的位置，但是不能指向 begin 之前的位置

对构成范围迭代器的要求：

+ 它们指向同一个容器中的元素，或者是容器最后一个元素之后的位置，且
+ 我们可以通过反复递增 begin 来到达 end。换句话说，end 不在 begin 之前



### 9.2.2 容器类型成员

+ iterator：此容器类型的迭代器类型
+ const_iterator：可以读取元素，但不能修改元素的迭代器类型
+ size_type：无符号整数类型，足够保存此种容器类型最大可能容器的大小
+ reverse_iterator：按逆寻址元素的迭代器

为了使用这些类型成员，我们必须显示地使用类型名：使用作用域运算符



### 9.2.3 begin 和 end 成员

begin 和 end 操作生成指向容器中第一个元素和尾元素之后位置的迭代器。这两个迭代器最常见的用途是形成一个包含容器中所有元素的迭代器范围

cbegin 和 cend 返回 const_iterator，只能读取，不能修改。无论调用对象是什么类型，始终返回 const 迭代器



### 9.2.4 容器定义和初始化

#### 默认构造函数初始化

每个容器类型都定义了一个默认的构造函数。除 array 外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数



#### 拷贝初始化

将一个新容器创建为另一个新容器的拷贝的方法有两种：可以直接拷贝整个容器，或者拷贝由一个迭代器对指定的元素范围

当使用容器拷贝时，两个容器的类型以及元素必须匹配，对于 array 类型，其必须含有相同的大小

当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。同时，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器的元素即可

由于两个迭代器表示一个范围，因此可以使用这种构造函数来拷贝一个容器中的子序列

```C++
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};

list<string> list2(authors);		// 拷贝初始化
deque<string> authList(authors);	// 错误：容器类型不匹配
vector<string> words(articles);		// 错误：容器类型必须匹配

// 正确：可以将 const char* 元素转换为 string
// 使用迭代器范围拷贝时不要求容器类型是相同的
forward_list<string> words(articles.begin(), articles.end());
```



#### 列表初始化

在 C++ 11 新标准中，我们可以对一个容器进行列表初始化

```C++
list<string> authors = {"abc", "bcd", "cde"};
vector<int> ivector {1, 2, 3};
```

当使用列表初始化时，我们显式地指定了容器中每个元素的值，同时除 array 之外的容器类型，我们还隐含地指定了容器的大小：容器包含与初始值一样多的元素



#### 与顺序容器大小相关的构造函数

除了默认构造函数外，顺序容器还提供一个构造函数，接受一个容器大小和一个可选的元素初始值。如果不提供元素初始值，则标准库会创建一个值初始化器

```C++
vector<int> ivec(10, -1);			// 10个 int 元素，每个都是初始化 -1
list<string> svec(10, "h1");		// 10个 string 元素，每个都初始化为 "hi"
forward_list<int> uvec(10);			// 10个 int 元素，每个都初始化为 0
```

如果元素类型没有默认构造函数，除了大小参数外，还必须指定一个显式的元素初始值



**只有顺序容器的构造函数才接受大小参数，关联容器并不支持**



#### 标准库 array 具有固定大小

与内置数组一样，标准库 array 的大小也是类型的一部分。当定义一个 array 时，除了指定元素类型，还要指定容器大小：

```C++
array<int, 42>;		// 类型为 保存 42 个 int 的数组
array<string, 10>;	// 类型为 保存 10 个 string 的数组
```

由于大小是 array 的一部分，array 不支持普通的容器构造函数



array 大小固定的特性决定了其默认构造时是非空的：它包含了与其大小一样多的元素。这些元素都被默认初始化，就像一个内置数组

如果我们对一个 array 进行列表初始化，初始值的数目必须等于或小于 array 的大小



**\*\*虽然无法对内置数组进行拷贝或对象赋值操作，但是 array 并无此限制\*\***



与其他容器一样，array 也要求初始值类型必须与要创建的容器类型相同。此外，array 还要求元素类型和大小也都一样，因为大小是 array 类型的一部分



### 9.2.5 赋值和swap

赋值运算可将左边容器中的全部元素替换为右边容器中元素的拷贝

```C++
c1 = c2;			// 将 C1 的内容替换为 C2 中元素的拷贝
c1 = {a, b, c};		// 赋值后, c1 大小为 3
```

如果两个容器原来大小不同，赋值运算后两者的大小都与右边容器的原大小相同

与内置数组不同，标准库 array 类型运行赋值。赋值号左右两边的运算对象必须具有相同的类型

由于右边运算对象的大小可能与左边运算对象的大小不同，因此 array 类型不支持 assign，也不允许用花括号包围值列表进行赋值



#### 使用 assign (仅顺序容器)

赋值运算符要求左右两边的运算对象具有相同的类型

assign 允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值

assign 接受一个迭代器范围，也接受一个整型值和一个元素值



#### 使用swap

swap 操作交换两个相同类型容器的内容。调用 swap 后，两个容器中的元素将会交换

除 array 外，swap 不对任何元素进行拷贝、删除或插入操作。也就是说，指向容器的迭代器、引用和指针在 swap 操作后不会失效，仍然指向之前所指的元素，只是元素不属于原来的容器，而是属于被 swap 后的容器

但是 array 使用 swap 时会真正的交换元素，因此指针、引用和迭代器所保定的元素保持不变，内存空间地址不变，但是内存空间内的值被改变了，变成被交换掉的值



### 9.2.6 容器大小操作

成员函数 size 返回容器中元素的数目

empty 当 size 为 0 时返回 true，否则 false

max_size 返回一个大于或等于该类型容器所能容纳的最大元素数的值



### 9.2.7 关系运算符

每个容器类型都支持相等运算符

关系运算符左右两边的运算对象必须是**相同类型的容器**，且必须保存**相同类型的元素**

容器判断是否相等时比较：

1. 容器内元素数量是否相同
2. 一个容器是否为另一个容器的子序列
   1. 如果一个容器为另一个容器的子序列，则数量少的容器较小
3. 比对两个容器中第一个不相同的元素



只有当其元素类型也定义了**相应的比较运算符时**，我们才可以使用关系运算符来比较两个容器

如果元素类型不支持比较运算符，那么保存这种元素的容器就不能使用相应的关系运算



### 9.3 顺序容器操作

顺序容器支持向容器中添加，删除等操作来改变容器的大小

除 array 外，因为 array 不能更改其大小



### 9.3.1 向顺序容器添加元素

 增加或删除元素会带来容器存储空间的变化



#### push_back

push_back 向容器尾部追加一个新的元素

除 array 和 forward_list 外，每个顺序容器都支持 push_back

+ array 大小不可变，所以无法添加元素
+ forward_list 因为是单项链表，并不会保存最后一个元素的指针，所以需要 O(n) 复杂度来遍历到最后一个元素

当使用 push_back 时，添加的新元素是对象值的一个拷贝，而不是对象本身。所以随后对容器中元素的任何改变都不会影响到原始对象，反之亦然



#### push_front

除了 push_back，list，forward_list 和 deque 容器还支持 push_front 操作，将元素插入到容器头部

deque 保证在容器首尾进行插入和删除元素的操作只花费常数时间



#### 在特定位置添加元素

insert 成员函数提供了元素添加功能，允许我们在容器中任意位置插入 0 个或多个元素

每个 insert 函数都接受一个迭代器作为其第一个参数。迭代器指出了容器中什么位置放置元素

insert 将插入元素放在迭代器之前



#### 插入范围元素

insert 函数还接受更多的参数

其中一个版本接受一个元素数目和一个值，它将指定数量的元素添加到指定位置之前，这些元素都按给定值初始化

另一个版本接受一个迭代器位置，和一对迭代器组成的范围

```C++
slist.insert(slist.begin(), v.end() - 2, v.end());
```



#### 使用 insert 返回值

当使用 insert 插入新元素时，其会返回一个迭代器并指向这个新元素

所以可通过一直获取这个 insert 的返回值，来循环获得最新的插入位置



#### 使用 emplace 操作

C++ 11 新标准引入了 emplace，emplace_front，emplace_back，这与 insert，push_front，push_back 类似

当我们调用一个 emplace 成员函数时，则是将参数传递给元素类型的构造函数

emplace 成员使用这些参数在容器管理的内存空间中直接构造元素

```C++
c.emplace_back("parameter 1", p2, p3);
c.push_back(NewItem("parameter 1", p2, p3));
```

emplace 函数参数根据**元素类型参数**变化，参数必须与元素类型的构造函数相匹配



### 9.3.2 访问元素

部分顺序容器支持使用 front 或 back 成员函数来获取容器内首位元素

间接方法是可以通过解引 begin 和 end 迭代器来获取首尾元素的调用



#### 访问成员函数返回的是引用

在容器中访问元素的成员函数返回的都是引用

```C++
auto &v = c.back();
auto v2 = c.back();
```

通过引用可以改变容器内的元素值

如果不是引用，则变量是成员函数的一个拷贝，对其的改变并不会影响到容器内的值



#### 下标操作和安全的随机访问

使用下标访问容器中的元素时，如果越界，编译器不会检查该错误，函数行为为未定义

使用 at 访问容器内的元素时，如果下标越界，则会抛出 `out_of_range` 异常



### 9.3.3 删除元素

#### pop_front 和 pop_back 成员函数

pop_front 和 pop_back 成员函数分别删除首元素和尾元素

操作返回 void，所以如果需要值得话，需要提前保存



#### 从容器内部删除一个元素

成员函数 erase 从容器中指定位置删除元素

可以删除单个迭代器指定的元素，也可以删除一对迭代器组成的范围中的所有元素

erase 返回指向删除的元素之后位置的迭代器

如果删除一个容器中所有的元素，可以调用 clear 成员函数，也可以使用 begin 和 end 迭代器作为 erase 的参数



### 9.3.4 特殊的 forward_list 操作

forward_list 对于其他的容器来说拥有特殊版本的添加和删除操作

由于删除或增加一个元素会改变序列中的链接，且 forward_list 只支持单向遍历

所以 forward_list 提供 insert_after，emplace_after，erase_after 的操作来通过改变给定元素之后的元素

同时 forward_list 还定义了  before_begin 来指向首元素之前的位置

`list.insert_after(p, t);		// 向迭代器位置 p 之后插入元素 t`

当在 forward_list 添加或删除元素时，我们必须关注两个迭代器 - 一个指向我们要处理的元素，另一个指向其前驱



### 9.3.5 改变容器大小

我们可以使用 resize 来增大或缩小容器，如果大于当前大小，则添加新元素到容器后部；如果小于当前大小，则删除后部元素

array 不支持 resize

resize 操作接受一个可选的元素值参数，用来初始化添加到容器中的元素

如果调用者未提供此参数，新元素进行值初始化

如果容器保存的是类类型元素，且 resize 向容器添加新元素，则我们必须提供初始值，或者元素类型必须提供一个默认构造函数



### 9.3.6 容器操作可能使迭代器失效

向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效

使用失效的指针、引用或迭代器是一种严重的程序设计错误，很可能引起与使用未初始化指针一样的问题



在向容器添加元素后：

+ 如果使 vector 或 string：如果存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效，因为容器内的元素被分配的新的地址空间。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍然有效，但指向插入位置之后元素的迭代器、指针和引用将会失效因为新插入的元素导致插入位置之后的所有元素的地址值被改变
+ 对于 deque：插入到除首位位置以外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效
+ 对于 list 和 forward_list，指向容器的迭代器、指针和引用仍然有效



当我们从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效。当我们删除一个元素后：

+ 对于 list 和 forward_list，指向容器其他位置的迭代器、指针和引用仍然有效
+ 对于 deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素的外其他元素的迭代器、引用或指针也会失效。如果是删除 deque 的尾元素，则尾后迭代器会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受到影响
+ 对于 vector 和 string，指向被删除元素之前元素的迭代器、引用和指针仍有有效。当我们删除元素时，尾后迭代器总会失效



由于 list 和 forward_list 是链表结构，其元素地址并不连续，所以增加和删除操作并不会影响到容器内其他元素的迭代器、指针和引用

vector，string 将元素保存在连续的地址空间中，所以增加和删除的操作会对后续元素的地址空间造成影响，所以后续元素的指针和引用会失效。但是插入和删除位置之前的元素并不会受到影响

deque 当在首尾之外的位置插入和删除时都会导致迭代器、指针和引用失效。当在首尾添加时，迭代器会失效。当在首尾删除时，如果删除尾元素，那么尾后迭代器会失效。在首尾删除和增加并不会影响到其他元素的指针和引用



**保证每次改变容器的操作之后都正确地重新定位迭代器**



#### 不要保存 end 返回地迭代器

当我们添加/删除 vector 或 string 的元素后，或在 deque 中首元素之外任何位置添加/删除元素后，原来 end 返回的迭代器总会失效



## 9.4 vector 对象是如何增长的

为了支持快速随机访问，vector 将元素连续存储 -- 每个元素紧挨着前一个元素存储，放置在一个连续的地址空间内



当向 vector 或 string 中添加新元素时，如果没有空间容纳新元素，由于元素必须连续存储，容器会分配新的地址空间来保存已有元素和新元素，将已有元素从旧位置移动到新空间中，然后添加元素，释放旧存储空间



#### 管理容量的成员函数

capacity 操作告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素

reserve 操作允许我们通知容器它应该准备保存多少个元素



只有当需要的内存空间超过当前容量时，reserve 调用才会改变 vector 的容量

因此，在调用 reserve 之后，capacity 将会大于或等于传递给 reserve 的参数



#### capacity 和 size

容器的 size 是指它已经保存的元素的数量

capacity 则是在不分配新的内存空间的前提下它最多可以保存多少元素

容器的 capacity 会永远大于或等于容器的 size



**\*\*每个 vector 实现都可以选择自己的内存分配策略。但是必须遵守的一条原则是：只有当迫不得已时才可以分配新的内存空间\*\***

只有在执行 insert 操作时 size 与 capacity 相等，或者调用 resize 或 reserve 时给定的大小超过当前 capacity，vector 才可能重新分配内存空间。会分配多少内存空间取决于具体实现



## 9.5 额外的 string 操作

除了顺序容器共同的操作之外，string 类型还提供了一些额外的操作

### 9.5.1 构造 string 的其他方法

+ `string s (cp, n)`	s 是 cp 指向的数组中前 n 个字符的拷贝
+ `string s (s2, pos2)`   s 是 string s2 从下标 pos2 开始的字符的拷贝
+ `string s (s2, pos2, len2)`   s 是 string s2 从下标 pos2 开始 len2 个字符的拷贝



#### substr 操作

substr 操作返回一个 string，它是原始 string 的一部分或全部的拷贝

`s.substr(pos, n)`  返回一个 string，包含 s 中从 pos 开始的 n 个字符的拷贝。pos 默认值为 0。n 的默认值为 s.size() - pos，即拷贝从 pos 开始的所有字符



### 9.5.2 改变 string 的其他方法

除了接受迭代器的 insert 和 erase 版本外，string 还提供了接受下标版本。下标指出了开始删除的位置，或是 insert 到给定值之前的位置



#### append 和 replace 函数

append 操作是在 string 末尾进行插入操作的一种简写形式

replace 操作是调用 erase 和 insert 的一种简写形式

```C++
string s("C++ Primer 4th Ed.");
s.erase(11, 3);			// C++ Primer Ed.
s.insert(11, "5th");	// C++ Primer 5th Ed.
// 从位置 11 开始，删除 3 个字符并插入 "5th"
s2.replace(11, 3, "5th");	// args: 位置，删除的长度，替换的目标字符
```

调用 replace 时，删除和插入的字符长度是可以不一样长的



#### 改变 string 的多种重载函数

assign  和 append 函数无须指定要替换 string 中哪个部分：assign 总是替换 string 中的所有内容，append 总是将新字符追加到 string 末尾

replace 函数提供两种指定元素范围的方式。可以通过一个位置和一个长度来指定范围，也可以通过一个迭代器范围来指定

insert 函数允许我们使用两种方式来指定插入点：用一个下标或迭代器。两种情况下，新元素都会插入到给定下标之前的位置

添加字符可以使用拷贝另一个 string，来自于一个字符指针，来自于一个花括号包围的字符列表，或者一个字符和一个计数器



### 9.5.3 string 搜索操作

string 提供了 6 个不同的搜索函数，搜索是大小写敏感的

+ `s.find(args);`
  + 查找 `s` 中 `args` 第一次出现的位置
  + `args` 可以是 `s` 的 substring
+ `s.rfind(args);`
  + 查找 `s` 中 `args` 最后一次出现的位置
  + 并不是逆向查找，而是查找最后一次出现的位置
+ `s.find_first_of(args);`
  + 查找 `args` 中任意一个字符在 `s` 中首次出现的位置
+ `s.find_last_of(args);`
  + 查找 `args` 中任意一个字符在 `s` 中最后一次出现的位置
+ `s.find_first_not_of(args);`
  + 查找不是 `args` 中任意一个字符在 `s` 中首次出现的位置
+ `s.find_last_not_of(args);`
  + 查找不是 `args` 中任意一个字符在 `s` 中最后一次出现的位置



#### 指定从哪里开始搜索

我们可以传递给 find 操作一个可选的开始位置



### 9.5.4 compare 函数

标准库 string 提供 compare 函数根据 `s` 是等于、大于还是小于参数指定的字符串，返回 0、正数、或负数



### 9.5.5 数值转换

字符串中常常包含数值的字符，可使用 string 提供的方法进行数值转换

```C++
int i = 42;
string s = to_string(i);		// 将整数 i 转换为字符表示形式
double d = stod(s);				// 将字符串 s 转换为浮点数
```

如果 string 不能转换为一个数值，这些函数抛出一个 `invalid_argument` 异常

如果转换得到的数值无法用任何类型来表示，则抛出一个 `out_of_range` 异常



## 9.6 容器适配器

除了顺序容器外，标准库还定义了三个顺序容器适配器：stack，queue，priority_queue

适配器是标准库中的一个通用概念，本质上，一个适配器是一种机制，能使某种事物的行为看起来像另一种事物一样

一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型



#### 定义一个适配器

每个适配器都定义两个构造函数：默认构造函数创建一个空对象，接受一个容器的构造函数拷贝该容器来初始化适配器

默认情况下，stack 和 queue 是基于 deque 实现的，priority_queue 是在 vector 之上实现的



#### 栈适配器

stack 将新元素压入栈底，将栈顶元素弹出，FILO

+ `s.pop()` 删除栈顶元素，但不返回该元素值
+ `s.push(item)` 创建一个新元素压入栈顶，该元素通过拷贝或移动 item 而来
+ `s.emplace(args)` 通过 `args` 构造一个新的元素
+ `s.top()` 返回栈顶元素，但不将元素弹出栈



#### 队列适配器

queue 将新元素放在栈尾，将栈顶元素弹出，FIFO

+ `q.pop()` 返回 queue 的首元素
+ `q.front()` 返回首元素或尾元素，但不删除
+ `q.back()` 适用于 queue
+ `q.top()` 返回最高优先级元素，但不删除该元素
+ `q.push(item)` 在 queue 末尾或 priority_queue 中恰当的位置创建一个元素
+ `q.emplace(args)` 其值为 item，或者由 `args` 构造



priority_queue 允许为队列中的元素建立优先级

新加入的元素会排在所有优先级比它低的已有元素之前 - 饭店按照客人预定时间而不是到来时间的早晚来为他们安排座位



## 练习

1. 简述 6 种顺序容器，支持的访问顺序，插入顺序
2. 为什么 forward_list 没有 size 操作
3. 什么时候选择 vector
4. 什么时候选择 list 或 forward_list
5. 什么时候选择 deque
6. 对于下面的程序任务，vector，deque 和 list 哪种容器最为合适？
   1. 读取固定数量的单词，将它们按字典序插入到容器中
   2. 读取未知数量的单词，总是将新单词插入到末尾。删除操作在头部进行
   3. 从一个文件读取位置数量的整数。将这些数排序，然后将它们打印到标准输出
7. 什么是迭代器范围？构成迭代器范围的要求是什么？
8. begin 和 cbegin 两个函数有什么不同？
9. 下面对象分别是什么类型？

```C++
vector<int> v1;
const vector<int> v2;
auto it1 = v1.begin(), it2 = v2.begin();
auto it3 = v1.cbegin(), it4 = v2.cbegin();
```

10. 当容器进行拷贝初始化时，什么时候容器类型以及元素类型必须匹配，什么时候容器类型以及容器中元素类型也可以不同？
11. 为什么 array 不支持普通的容器构造函数？
12. 对于接受一个容器创建其拷贝的构造函数，和接受两个迭代器创建拷贝的构造函数，解释它们的不同
13. 为什么 array 不支持 assign 赋值，也不允许用花括号包围的值列表进行赋值？
14. array 的 swap 和其他容器类型的 swap 有什么不同？
15. insert 将新元素插入到迭代器之前还是之后？为什么？
16. insert 的返回值是什么？
17. emplace_back 与 push_back 有什么不同？
18. 下标访问和使用 at 成员函数有什么不同？
19. 对空容器调用 front 和 back 会有什么后果？
20. erase 成员函数返回什么值？
21. 为什么 forward_list 会有特殊版本的增加和删除函数
22. 接受单个参数的 resize 版本对元素类型有什么限制？
23. 为什么 forward_list 不接受加减移动迭代器？那么应该如何移动 forward_list 的迭代器？
24. size 和 capacity 的区别？
25. 一个vector容器的 capacity 可能小于它的 size 吗？
26. 为什么 list 或 array 没有 capacity 成员函数？
27. 什么是容器适配器？
28. stack，queue，priority_queue 分别是基于哪个容器的适配器？
29. 描述 stack，queue，priority_queue 的用法

