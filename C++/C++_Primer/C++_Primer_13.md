# 拷贝控制

当定义一个类时，我们显式地或隐式地指定在此类型地对象拷贝、移动、赋值和销毁时做什么

一个类通过定义物种特殊的成员函数来控制这些操作，包括

+ 拷贝构造函数
+ 拷贝赋值运算符
+ 移动构造函数
+ 移动赋值运算符
+ 析构函数

拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么

拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么



如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作



## 13.1 拷贝、赋值与销毁

### 13.1.1 拷贝构造函数

如果一个构造函数的**第一个参数是自身类型的引用**，且任何额外参数都有默认值，则此构造函数是拷贝构造函数

```C++
class Foo {
public:
    Foo();					// 默认构造函数
    Foo(const Foo&);		// 拷贝构造函数
}
```



#### 合成拷贝构造函数

如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个

合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中：

+ 对类类型成员，会使用其拷贝构造函数来拷贝；
+ 内置类型的的成员直接拷贝



#### 拷贝初始化

直接初始化和拷贝初始化的差异：

直接初始化是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数

拷贝初始化是我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换

```C++
string dots(10, '.');			// 直接初始化
string s2 = dots;				// 拷贝初始化
```



拷贝初始化不仅在我们用 `=` 定义变量时会发生，在下列情况下也会发生：

+ 将一个对象作为实参传递给一个非引用类型的形参
+ 从一个返回类型为非引用类型的函数返回一个对象
+ 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
+ 某些类型还会对它们所分配的对象使用拷贝初始化。例如标准化容器中的 `insert` 和 `push`；而 `emplace` 则是直接初始化



#### 参数和返回值

在函数调用过程中，具有非引用类型的参数要进行拷贝初始化

当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果



拷贝构造函数被用来初始化非引用类类型参数：当函数的参数为非引用时，我们会对其实参进行拷贝初始化

这一特性解释了**为什么拷贝构造函数自己的参数必须是引用类型**。如果其参数不是引用类型，则调用永远也不会成功：为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环



#### 拷贝初始化的限制

**[?]** 如果我们希望使用一个 `explicit` 构造函数，就必须显式地使用：不能从一个 `explicit` 的构造函数拷贝一个实参，而必须使用直接初始化



#### 编译器可以绕过拷贝构造函数

在拷贝初始化过程中，编译器可以跳过拷贝/移动构造函数，直接创建对象

```C++
string null_book = "9-999-999-9";		// 拷贝初始化
string null_book("9-999-999-9");		// 编译器可以改写为直接初始化
```



### 13.1.2 拷贝赋值运算符

#### 重载赋值运算符

拷贝赋值运算使用 `=` 来进行

**拷贝赋值运算符**本质上是一个重载的赋值运算符，定义为类的成员函数

重载运算符本质上是函数，赋值运算符就是一个名为 `operator =` 的函数

类似于任何其他函数，运算符函数也有一个返回类型和一个参数列表



如果一个运算符是成员函数，其左侧运算对象就绑定到隐式的 `this` 参数

对于二元运算符，右侧运算对象则为显示参数传递



**赋值运算符通常返回一个指向其左侧运算对象的引用**



#### 合成拷贝赋值运算符

如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个**合成拷贝赋值运算符**

通常情况下，合成的拷贝赋值运算符会将右侧对象的非 `static` 成员逐个赋予左侧对象的对应成员，这些赋值操作是由成员类型的拷贝赋值运算符来完成的

对于某些类，合成拷贝赋值运算符会起到禁止该类型对象赋值的效果



> 拷贝构造函数是用一个对象来初始化另一个对象
>
> 而拷贝赋值运算符是对一个已经初始化的对象的重新赋值



### 13.1.3 析构函数

析构函数释放对象使用的资源，并销毁对象的非 `static` 数据成员

析构函数是类的一个成员函数，名字由波浪号接类名构成

它没有返回值，也不接受参数

```C++
class Foo {
    public:
    ~Foo();			// 析构函数
};
```

由于析构函数不接受参数，因此它不能被重载

对于一个给定类，只会有唯一一个析构函数



在一个析构函数中，首先执行析构函数的函数体，然后销毁成员

成员按照初始化顺序的逆序销毁



通常，析构函数释放对象在生存期分配的所有资源



什么时候会调用析构函数？

无论何时一个对象被销毁，就会自动调用析构函数

+ 变量离开其作用域的时候
+ 当一个对象被销毁时，其成员被销毁
+ 容器被销毁时，其元素被销毁
+ 对于动态分配的对象，当对指向它的指针应用 `delete` 运算符时被销毁
+ 对于临时对象，当创建它的完整表达式结束时被销毁



> 当指向一个对象的引用或指针离开作用域时，析构函数不会执行
>
> 指向对象的引用或指针离开作用域时，只是引用或指针被销毁，但原有的对象仍然存在



#### 合成析构函数

当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数

对于某些类，合成析构函数被用来阻止该类型的对象被销毁



**认识到析构函数体自身并不直接销毁成员是非常重要的。成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分进行的**



### 13.1.4 三/五法则

有三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算和析构函数。在新标准下，还有移动构造函数和移动赋值运算符



#### 需要析构函数的类也需要拷贝和赋值操作

一个基本原则是首先确定这个类是否需要一个析构函数

通常，对析构函数的要求比对拷贝构造函数或赋值运算符的需求更为明显

**如果这个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符**



举例：当一个类的构造函数中有动态分配时，析构函数必须要有 `delete` 语句来释放内存，因为合成析构函数不会主动得释放一个指针数据成员

如果使用合成拷贝构造函数和合成拷贝赋值运算符，那么当函数体内有拷贝运算时，在函数结束后，会执行两次析构函数

此时，析构函数会对同一块内存地址执行两次 `delete` 操作



#### 需要拷贝操作的类也需要赋值操作，反之亦然

如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符

但这不以为着这个类需要一个析构函数



举例：当一个类中有一个数据成员来保存唯一的 id 时，发生拷贝的同时需要避免新的对象拷贝原有对象的 id，这时候需要自定义拷贝构造函数和拷贝赋值运算符，但是此时并不一定需要定义析构函数



### 13.1.5 使用 `=default`

我们可以 通过将拷贝控制成员定义为 `=default` 来显式地要求编译器生成合成的版本



当我们在类内用 `=default` 修饰成员的声明时，合成的函数将隐式地声明为内联

如果我们不希望合成地函数时内联函数，应该只对成员的类外定义使用 `=default` 



> 我们只能对具有合成版本的成员函数使用 `=default`



### 13.1.6 阻止拷贝

大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地



有些情况下，定义类时需要采用某种机制阻止拷贝和赋值



#### 定义删除的函数

在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为**删除的函数**来阻止拷贝

删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们

在函数的参数列表后面加上 `=delete` 来指出我们希望将它们定义为删除的

```C++
struct NoCopy {
    NoCopy() = default;
    NoCopy(const NoCopy&) = delete;	// 阻止拷贝
    NoCopy &operator=(const NoCopy&) = delete;		// 阻止赋值
}
```



与 `=default` 不同，`=delete` 需要出现在函数第一次声明的时候

另一个不同是，我们可以对任何函数指定 `=delete`，而 `=default` 只能对那些有合成版本的函数使用



#### 析构函数不能是删除的成员

我们不能删除析构函数。如果析构函数被删除，就无法销毁此类型的对象

对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类型的临时对象

但是，我们可以动态分配这种类型的对象，但是不能释放这些对象



#### 合成的拷贝控制成员可能是删除的

对于某些类来说，编译器将合成的成员定义为删除函数

如果一个类有数据成员不能默认构造、拷贝、复制或者销毁，则对应的成员函数将被定义为删除的



> 本质上，当不可能拷贝、赋值或者销毁类的成员时，类的合成拷贝控制成员就被定义为删除的



#### `private` 拷贝控制

在新标准发布前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为 `private` 来阻止拷贝

由于拷贝构造函数和拷贝赋值运算是 `private` 的，用户的代码不能拷贝这个类型的对象

但是友元函数和成员函数仍然可以拷贝对象。为了阻止友元函数和成员函数进行拷贝，我们将这些拷贝控制成员声明为 `private` 的，但不定义它们



> 希望阻止拷贝的类应该使用 `=delete` 来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为 `private`



## 13.2 拷贝控制和资源管理

管理类外资源，如动态内存的类必须定义拷贝控制成员

为了定义这些成员，我们首先必须确定此类型对象的拷贝语义

一般来说，有两种选择：

+ 类的行为像一个值，意味着它应该也有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然
+ 类的行为像指针，则表明类共享状态。当我们拷贝一个这种类时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然

 

标准库容器和 `string` 类的行为像一个值

`shared_ptr` 类提供类似指针的行为



### 13.2.1 行为像值的类

为了提供类值行为，对于类的管理资源，每个对象都应该拥有一份自己的拷贝



#### 类值拷贝赋值运算符

赋值运算符通常组合了析构函数和构造函数的操作。类似析构函数，赋值操作会销毁左侧运算对象的资源

类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据

但是，这些操作是以正确的顺序执行的，即使将一个对象赋予它自身，也保证正确

同时，我们需要保证编写的赋值运算符是异常安全的 -- 即使发生了异常，左侧运算对象也能被置于一个有意义的状态



> 当编写赋值运算符时，有两点要记住
>
> + 如果将一个对象赋予它自身，赋值运算符必须能正确工作
> + 大多数赋值运算符组合了析构函数和拷贝构造函数的工作
>
> 当编写赋值运算符时，一个好的模式是先将右侧运算符对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了



### 13.2.2 定义行为像指针的类

对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符



通过使用引用计数，我们可以直接管理资源：

+ 除了初始化对象外，每个构造函数还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为 1
+ 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享计数器，指出给定对象的状态又被一个新用户所共享
+ 析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变成 0，则析构函数释放状态
+ 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器为 0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁的状态



我们可以将计数器保存在动态内存中。当创建一个对象时，我们也分配一个新的计数器。当拷贝或赋值对象时，我们拷贝指向计数器的指针



### 13.3 交换操作

除了定义拷贝控制成员，管理资源的类通常还定义一个名为 `swap` 的函数

定义 `swap` 是非常重要的，用来交换两个元素



`swap` 函数可以是创建一个临时的对象来进行两次拷贝，也可以是通过指针来直接交换



如果类实现了特定版本的 `swap` 函数，则调用 `swap` 时会优先调用特定版本的 `swap`，如果没有特定版本，则会调用 `std::swap`



#### 在赋值运算符中使用 `swap`

定义 `swap` 的类通常用 `swap` 来定义它们的赋值运算符。这些赋值运算符使用了一种名为**拷贝并交换 (copy and swap)**的技术

```C++
HasPtr& HasPtr::operator=(HasPtr rhs)
{
    swap(*this, rhs);		// rhs 现在指向本对象曾经使用的内存
    return *this;			// rhs 被销毁，从而 delete 了 rhs 中的指针
}
```

将右侧运算对象以传值方式传递给了赋值运算符

因此 `rhs` 是右侧运算符的一个副本

在赋值运算符的函数体中，我们调用 `swap` 来交换 `rhs` 和 `*this` 中的数据成员。这个调用将左侧运算符对象中原来保存的指针存入 `rhs` 中，并将 `rhs` 中原来的指针存入 `*this` 中。因此，在 `swap` 调用之后，`*this` 中的指针成员将指向新分配的对象



当赋值运算符结束后，`rhs` 被销毁，`HasPtr` 的析构函数将执行。此析构函数 `delete` `rhs` 现在指向的内存，即，释放掉左侧运算对象中原来的内存



## 13.4 拷贝控制示例







## 习题：

+ 什么是拷贝构造函数？

+ 如何定义一个类的拷贝构造函数？

+ 什么是合成拷贝构造函数？合成拷贝构造函数是如何工作的？

+ **拷贝初始化和直接初始化的区别？**

+ 拷贝初始化在什么情况下会发生？

+ 为什么拷贝构造函数自己的参数必须是引用类型？

+ 拷贝赋值运算符是什么？什么时候使用它？合成拷贝赋值运算符完成是么工作？什么时候会生成合成拷贝赋值运算符？

+ 拷贝构造函数和拷贝赋值运算符的区别？

+ 析构函数的作用？

+ 析构函数有返回值吗？接受参数吗？

+ 析构函数能被重载吗？

+ 一个类可以有多个析构函数吗？

+ 什么时候会调用析构函数？

+ 成员对象销毁的过程是怎么样的？成员是在析构函数体内被销毁的吗？

+ 下面的代码片段中会发生几次析构函数的调用？

  ```C++
  bool fcn(const Sales_data *trans, Sales_data accum)
  {
      Sales_data item1(*trans), item2(accum);
      return item1.isbn() != item2.isbn();
  }
  ```

+ 举例说明为什么需要析构函数时也需要拷贝构造函数和拷贝赋值运算符

+ 举例说明需要拷贝构造函数和拷贝赋值运算符并不代表需要析构函数

+ 对具有合成版本的成员函数定义为 `=default` 有什么用？

+ 当使用 `=default` 来定义合成版本的成员函数时如何避免被定义为内联函数？

+ 什么是删除的函数？如何定义删除函数？

+ 析构函数可以是删除函数吗？如果定义了析构函数为删除函数有什么后果？

+ 如何理解拷贝控制成员提供像**值**或像**指针**的行为？

+ 什么是拷贝并交换技术？

