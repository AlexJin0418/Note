# C++ Primer 第十章 泛型算法

标准库容器定义的操作集合惊人得小。标准库并未给每个容器添加大量功能，而是提供了一组算法，这些算法中的大多数都独立于任何特定的容器。这些算法是通用的，或者是泛型的 generic：它们可用于不同类型的容器和不同类型的元素



顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素、访问首尾元素、确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代器

标准库定义了一组**泛型算法 (generic algorithm)**：

+ 称为算法，是因为它们实现了一些经典算法的公共接口，如排序和搜索
+ 称为泛型，是因为它们可以用于不同类型的元素和多种容器类型



## 10.1 概述

大多数算法都定义在头文件 `algorithm` 中

**\*\*一般情况下，算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。通常情况下，算法遍历范围，对其中每个元素进行一些处理\*\***



#### 迭代器令算法不依赖于容器

#### 但算法依赖于元素类型的操作



泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作

泛型算法运行于迭代器之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的编程假定：算法永远不会改变底层容器的大小

算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素



## 10.2 初时泛型算法

除了少数外，标准库算法都对一个范围内的元素进行操作

接受输入范围的算法总是使用前两个参数来表示范围，两个参数分别是指向要处理的第一个元素和尾元素之后位置的迭代器

理解算法的最基本的方式就是了解它们是否读取元素，改变元素或是重拍元素顺序



### 10.2.1 只读算法

只读算法只会读取其输入范围内的值，而从不改变元素

`accumulate(begin, end, sum value);`

`accumulate` 算法的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型



#### 算法和元素类型

将元素类型加到和的类型上的操作必须是可行的，也就是说，对于 `accumulate` 算法，操作是由第三个参数来决定的，迭代器范围内元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型



#### 操作两个序列的算法

`equal(list1.cbegin(), list1.cend(), list2.cbegin());`

`equal` 算法接受三个迭代器：前两个为第一个序列中元素范围，第三个表示第二个序列的首元素

所以 `equal` 假定第二个序列至少与第一个序列一样长



**\*\*那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长\*\***



### 10.2.2 写容器元素的算法

一些算法将新值赋予序列中的元素

需要保证序列原大小至少不小于我们要求算法写入的元素数目



向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素



#### back_inserter

一种保证算法有足够元素空间来容纳输出数据的方法是使用**插入迭代器 (insert iterator)**

当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中



`back_inserter` 接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器

由于我们传递的参数是 `back_inserter` 返回的迭代器，因此每次赋值都会在容器上调用 `push_back`



#### 拷贝算法

拷贝算法是另一种向目的位置迭代器指向的输出序列中的元素写入数据的算法

此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置

此算法将输入范围中的元素拷贝到目的序列中

传递个 `copy` 的目的序列至少要包含与输入序列一样多的元素



### 10.2.3 重排容器元素的算法

某些算法会重排容器中元素的顺序，`sort` 算法利用元素类型的 `<` 运算符来实现排序的



#### 消除重复元素

`unique` 算法可以消除重复元素，并返回一个指向不重复值范围末尾的迭代器

`unique` 并不删除任何元素，只是将相邻的重复元素覆盖掉，使得不重复元素出现在序列开始的位置，重复元素出现在序列的末尾，这样 `unique` 返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素依然存在，只是我们不知道它们的值是什么



## 10.3 定制操作

很多算法都会比较输入顺序中的元素。默认情况下，这类算法使用元素类型 `<` 或 `=` 运算符来完成比较

标准库为这些算法定义了额外版本，允许我们提供自己定义的操作来代替默认运算符



### 10.3.1 向算法传递函数

**谓词:** 谓词是一个可调用的表达式，其返回结果是一个能用作条件的值

标准库算法使用的谓词分为两种：**一元谓词** 和 **二元谓词**

谓词可以理解为一个带有返回值的函数，一元谓词表明函数有一个参数，二元谓词表明函数有两个参数



### 10.3.2 lambda 表达式

根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格接受一个或两个参数

但是有的时候我们希望进行的操作需要更多的参数，超出了算法对谓词的限制



#### 介绍 lambda

我们可以向一个算法传递任何类别的**可调用对象**

对于一个对象或一个表达式，如果可以对其使用调用运算符 ()，则称它为可调用的



目前为止，可调用对象有函数和函数指针，**lambda表达式**也是可调用对象



一个 lambda 表达式表示一个可调用的代码单元

我们可以将其理解为一个未命名的内联函数

与任何函数相似，一个 lambda 具有一个返回类型、一个参数列表和一个函数体

但与函数不同，lambda 可能定义在函数内部

`[capture list] (parameter list) -> return type { function body }`

`capture list` 是一个 lambda 所在函数中定义的局部变量的列表

我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体



如果 lambda 的函数体包含任何单一 return 语句之外的内容，且未指定返回类型，则返回 void



#### 向 lambda 传递参数

与一个普通函数调用类似，调用一个 lambda 时给定的实参被用来初始化 lambda 的形参

与普通函数不同，lambda 不能有默认参数。因此，一个 lambda 调用的实参数目永远与形参数目相同



#### 使用捕获列表

空捕获列表表明此 lambda 不适用它所在函数中的任何局部变量



虽然一个 lambda 可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量

lambda 也可以使用局部静态变量以及定义在函数体外的变量和头文件中的变量



一个 lambda 只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量



### 10.3.3 lambda 的捕获和返回

当向一个函数传递一个 lambda 时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象

默认情况下，从 lambda 生成的类都包含一个对应该 lambda 所捕获的变量的数据成员



#### 值捕获

值捕获的前提是变量可以拷贝

由于被值捕获变量的值实在 lambda 创建时拷贝，因此随后对其修改不会影响到 lambda 内对应的值



#### 引用捕获

当我们在 lambda 函数体内使用引用捕获时，实际上使用的引用所绑定的对象

引用捕获会改变所引用的变量

如果我们采用引用的方式捕获一个变量，就必须确保被引用的对象在 lambda 执行的时候是存在的。因为 lambda 捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果 lambda 在函数结束后执行，捕获的引用指向的局部变量已经消失



#### 隐式捕获

在捕获列表中使用 `=` 和 `&` 来隐式表示捕获类型，并让编译器根据函数体推断捕获列表



当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须时一个 `&` 或 `=`

当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式



#### 可变 lambda

默认情况下，值拷贝的变量，lambda 不会改变其值

如果希望改变一个被捕获的变量的值，就必须在参数列表首加上关键字 `mutable`



#### 指定 lambda 返回类型

如果一个 lambda 体包含 return 之外的任何语句，则编译器假定此 lambda 返回 void

当我们需要为一个 lambda 定义返回类型时，就必须使用尾置返回类型

`[] (int i ) -> int { if (i < 0) return -1; else return i;}`



### 10.3.4 参数绑定

对于那种只在一两个地方使用的简单操作，lambda 表达式是最有用的

如果我们需要在很多地方使用相同的操作，通常应该定义一个函数，而不是多次编写相同的 lambda 表达式

类似的，如果一个操作需要很多语句才能完成，通常使用函数更好



#### 标准库 bind 函数

当函数的参数超过了谓词的限制后，就无法将其作为表达式参数放在算法中

可以使用一个名为 `bind` 的标准库函数作为通用函数适配器，接受一个可调用对象，生成新的可调用对象来适应原对象的参数列表

`auto newCallable = bind(callable, arg_list);`

当调用 `newCallable` 时，`newCallable` 会调用 `callable`，并传递给它 `arg_list` 中的参数

`arg_list` 中包含形如 `_n` 的名字，其中 `n` 是一个整数

这些参数是 “占位符”，表示 `newCallable` 的参数



#### bind 的参数

假定 `f` 是一个可调用对象

`auto g = bind(f, a, b, _2, c, _1);`

生成一个新的可调用对象，它有两个参数，分别占用 `_2` 和 `_1` 表示

当调用 `g` 时，`g(_1, _2)` 将会映射为 `f(a, b, _2, c, _1)`



如果调用 `g(X, Y)` 则会映射为 `f(a, b, Y, c, X)`



#### 绑定引用参数

当需要绑定引用参数时，比如 `ostream`，可以在 `bind` 中加入引用参数 `ref()`

`bind(print, ref(os), _1, ' ');`



## 练习

1. 假定 `v` 是一个 `vector<double>`，那么调用 `accumulate(v,cbegin(), v.cend(), 0)` 有何错误？如果存在的话

2. 当调用 `equal` 算法时，如果列表中保存的是 `C风格字符串` 而第三个参数是 `string`，会发生什么？

3. 标准库算法不会改变它们所操作的容器的大小。为什么使用 `back_inserter` 不会使这一断言失效？

4. 什么叫谓词？
5. 如何理解 lambda 表达式？
6. lambda 和 函数有什么相同和不同？
7. 为什么 lambda 不能有默认参数？
8. lambda 捕获列表中需要捕获什么变量？lambda 能够使用什么变量？
9. 什么是隐式捕获？当隐式捕获和显式捕获同时出现时有什么要求？

 
