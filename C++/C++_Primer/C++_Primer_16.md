# C++ Primer 第十六章 模板与泛型编程

面对对象和泛型编程都能处理在编写程序时不知道类型的情况

OOP能处理类型在成勋运行之前都未知的情况

泛型编程中，在编译时就能获知类型了



当使用泛型程序时，我们提供类型或值，程序实例可在其上面运行



## 16.1 定义模板

一个模板就是一个创建类或函数的蓝图或者说公式

我们可以提供足够多的信息，将蓝图转换为特定的类或函数

这种转换发生在**编译时**



假如我们希望编写一个函数来比较两个值，在实际中，我们想要对每一个给定的类型定义一一个函数

这样我们需要定义多个重载函数，它们的区别在于参数的类型，而函数体则完全一样

在编写程序的时候，我们就要确定函数的所有类型

如果希望能在用户提供的类型上使用此函数，那么这种策略就失效了



### 16.1.1 函数模板

我们可以定义一个通用的**函数模板（function template）**，而不是为每个类型都定义一个新函数

**一个函数模板就是一个公式，可用来生成针对特定类型的函数版本**

```C++
template <typename T>
int compare(const T &v1, const T &v2)
{
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```

模板定义以关键字 `template` 开始，后跟一个**模板参数列表（template parameter list）**，这是一个逗号分隔的一个或多个模板参数的列表，用 `<>` 包围起来

在模板定义中，模板参数列表不能为空



模板的参数表示在类或函数定义中用到的类型或值

当使用模板时，我们指定模板实参，将其绑定到模板参数上



#### 实例化函数模板

当我们调用一个函数模板时，编译器用函数实参来为我们推断模板实参

编译器使用实参的类型来确定绑定到模板参数的类型

编译器用推断出的模板参数来为我们实例化一个特定版本的函数

编译器生成的版本通常称为模板的**实例 (instantiation)**



#### 模板类型参数

类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换

```C++
// 返回类型为T，参数类型也为T
template <typename T> T foo(T* p)
{
    T tmp = *p;		// tmp 类型是指针 p 指向的类型
    return tmp;
}
```

类型参数前必须使用关键字 `class` 或 `typename`

```C++
template <typename T, class U, K> calc(const T&, const U&, const K&);	// 错误，每个参数前都必须使用关键字 class 或 typename
```



#### 非类型模板参数

除了定义类型参数，还可以在模板中定义非类型参数

一个非类型参数表示一个值而非一个类

我们通过一个特定的类型名而非关键字 `class` 或 `typename` 来指定非类型参数



当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替

绑定到非类型整型参数的实参必须是一个**常量表达式**并具有静态的生存期

所以我们不能使用局部变量或动态对象作为指针或引用非类型模板参数的实参



#### `inline` 和 `constexpr` 的函数模板

函数模板可以声明为 `inline` 和 `constexpr`

`inline` 或 `constexpr` 说明符放在模板参数列表之后，返回类型之前

```C++
template <typename T> inline T min(const T&, const T&);
```

 

#### 编写类型无关的代码

模板程序应该尽量减少对实参类型的要求

+ 模板的函数参数是 `const` 引用，保证函数可以用于不能拷贝的类型
+ 函数体中的条件判断仅使用 < 比较运算，降低对要处理的类型的要求，只需要支持 < 而不必同时支持 >



#### 模板编译

当编译器遇到一个模板定义时，它并不生成代码

只有当我们实例化出模板类的一个特定版本时，编译器才会生成代码

当我们使用模板时，编译器才生成代码



为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义

因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义



#### 大多数编译错误在实例化期间报告

模板直到实例化时才会生成代码，这一特性影响了我们何时才会获知模板内代码的编译错误

通常，编译器会在三个阶段报告错误：

+ 第一个阶段是编译模板本身时
  + 在这个阶段编译器只能检查语法错误
+ 第二个阶段是编译器遇到模板类使用时
  + 对于函数模板调用，编译器通常会检查实参数目是否正确
  + 检查参数类型是否匹配
+ 第三个阶段是模板实例化时
  + 这个阶段会发现类型相关的错误



### 16.1.2 类模板

类模板是用来生成类的蓝图的

与函数模板的不同之处是，编译器不能为类模板推断模板参数类型



#### 定义类模板

类似函数模板，类模板以关键字 `template` 开始，后跟模板参数列表

```C++
template <typename T> class Blob {
public:
    typedef T value_type;
    typedef typname std::vector<T>::size_type size_type;
    // 构造函数
    Blob();
    Blob(std::initializer_list<T> il);
    // Blob 中的元素数目
    size_type size() const { return data->size(); }
    bool empty() const { return data->empty(); }
    // 添加和删除
    void push_back(const T &t) { data->push_back(t); }
    void pop_back();
    
    T& back();
    T& operator[](size_type i);
    
private:
    std::shared_ptr<std::vector<T>> data;
    void check(size_type i, const std::string &msg) const;
}
```



#### 实例化类模板

当使用一个类模板时，我们必须提供额外信息 - 显式模板实参 (explicit template argument)

它们被绑定到模板参数

编译器使用这些模板实参来实例化出特定的类

```c++
Blob<int> ia;
Blob<int> ia2 = {0,1,2,3,4};
```

编译器会根据实参实例化不同的类



> 一个类模板的每个实例都形成一个独立的类
>
> 类型 `Blob<string>` 与任何其他 Blob 类型都没有关联，也不会对任何其他 Blob 类型的成员有特殊访问权限



#### 在模板作用域中引用模板类型

当在一个模板类中使用另一个模板时不直接使用实际参数，而是使用自己的参数作为参考



#### 类模板的成员函数

与其他任何类相同，我们可以在类模板内部，也可以在类模板外部定义成员函数，且定义在类模板内的成员函数被隐式声明为内联函数



类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的成员函数

类模板的成员函数具有和模板相同的模板参数

因而，定义在类模板之外的成员函数就必须以关键字 `template` 开始，后接模板参数列表





 

## 习题

+ 什么是函数模板？
+ 如何定义一个函数模板？
+ 模板函数的定义与调用是怎样的？
+ 函数模板是如何实例化的？
+ 什么是类型参数？
+ 非类型模板参数表示的是什么？
+ `template<typename T>` 和 `template<unsigned N>` 的区别是什么？
+ 编写泛型模板的两个重要原则是什么？
+ 为什么模板类的声明和定义通常会都放在头文件中？
+ 当模板被编译到实例化期间，编译器会在哪三个阶段检查错误？
+ 