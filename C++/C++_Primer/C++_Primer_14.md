# C++ Primer 第十四章 重载运算与类型转换

当运算符被用于类类型的对象时，C++语言允许我们为其指定新的含义；同时，我们也能自定义类类型之间的转换规则

## 14.1 基本概念

重载的运算符是具有特殊名字的函数：它们的名字由关键字 `operator` 和其后要定义的运算符号共同组成

和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体



重载运算符函数的参数数量与该运算符作用的运算对象数量一样多

> 当一个重载的运算符是成员函数时，`this` 绑定到左侧运算对象。成员运算符函数的参数数量比运算对象的数量少一个



我们不能重载内置类型的运算符

我们只能重载已有的运算符，而无权发明新的运算符号



不能被重载的运算符如下

+ `::`
+ `.*`
+ `.`
+ `? :`



#### 直接调用一个重载的运算符函数

我们可以像调用普通函数一样直接调用运算符函数

```C++
operator+(data1, datra2);		// data1 + data2
```

也可以像调用其他成员函数一样显示地调用**成员运算符函数**

```C++
data1.operator+=(data2);		// data1 += data2
```



#### 某些运算符不应该被重载

某些运算符指定了运算对象求值的顺序

因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上

特别是，**逻辑与运算符**，**逻辑或运算符**和**逗号运算符**的运算对象求值顺序规则无法保留下来

除此之外 `&&` 和 `||` 运算符的重载版本也无法保留内置运算符短路的求值属性

同时，对于逗号运算符和取地址运算符，C++语言已经定义了两种运算符用于类类型对象时的特殊含义，所以不应该被重载



#### 选择作为成员或者非成员

当我们定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数

下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数：

+ 赋值 `=`，下标 `[ ]`，调用 `( )` 和成员访问箭头 `->` 运算符必须是成员
+ 复合赋值运算 `+=` 一般来说应该是成员，但并非必须
+ 改变对象状态的运算符或者与给定成员类型密切相关的运算符，如递增、递减和解引用运算符
+ 具有**对称性**的运算符可能转换任意一端的运算对象，例如算数、相等性、关系和位运算符等



当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属的一个对象



## 14.2 输入和输出运算符

IO标准库分别使用 `>>` 和 `<<` 执行输入和输出操作

对于这两个运算符来说，IO库定义了用气读写内置类型的版本，而类则需要自定义适合其对象的新版本以支持 IO 操作



### 14.2.1 重载输出运算符 <<

通常情况下，输出运算符的第一个形参是一个非常亮 `ostream` 对象的引用

之所以是非常量是因为向流写入内容会改变其状态

而该形参是引用是因为我们无法直接复制一个 `ostream` 对象



第二个形参一般来说是一个常量的引用，该常量是我们希望打印的类类型

第二个形参是引用的原因是我们希望避免复制实参

而之所以该形参可以是常量是因为打印对象不会改变对象的内容



#### 重载的输出运算符

```C++
ostream &operator<< (ostream &os, const Data &data)
{
    os << data.A() << " " << data.B() << " " data.C();
    return os;
}
```



通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符

因为如果打印了换行符，用户就无法在对象的同一行内接着打印一些描述性的文本了

令输出运算符尽量减少格式化操作可以使用户有权控制输出的细节



#### 输入输出运算符必须是非成员函数

与 `iostream` 标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数

否则，它们的左侧运算对象是我们的类的一个对象 

假设输入输出运算是某个类的成员，则它们必须是 `istream` 或 `ostream` 的成员

然而，这两个类属于标准库，并且我们无法给标准库中的类添加任何成员

因此，我们希望自定义 IO 运算符为非成员函数

由于 IO 运算符通常需要读写类的非公有数据成员，所以 IO 运算符一般被声明为友元



### 14.2.2 重载输入运算符 >>

通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用

第二个形参是将要读入到的对象的引用，该对象是非常量是因为我们要将数据写入这个对象



#### 重载的输入运算符

```C++
istream &operator>> (istream &is, Data &data)
{
    is >>  data.a >> data.b;
    if (is)							// 判断数据是否传输成功
    {
        data.c = data.a + data.b;
    }
    else
    {
        data = Data();				// 写入失败，默认初始化对象
    }
    return is;
}
```



> 输入运算符必须处理可能失败的情况，而输出运算符不需要



#### 输入时的错误

执行输入操作时可能发生错误：

+ 含有错误类型的数据读取操作可能失败
+ 当读取操作达到文件末尾或者遇到输入流的其他错误



> 当读取操作发生错误时，输入运算符应该负责从错误中恢复



### 14.3 算术和关系运算符

我们把算数和关系运算符定义成非成员函数以允许左侧或右侧的运算对象进行转换

因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用



```C++
Data operator+ (const Data &data1, const Data &data2)
{
    Data sum = data1;
    sum += data2;
    return sum;
}
```

 

> 如果类同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符



### 14.3.1 相等运算符

C++中的类通过定义相等运算符来检验两个对象是否相等

它们会比较对象的每一个数据成员，只有当所有相对应的成员都相等时才认为两个对象相等



定义相等运算符时应该尽量遵守下列准则：

+ 如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成 `operator=` 而非一个普通的命名函数：因为用户希望使用 `==` 来判断对象
+ 如果定义了 `operator==`，则这个类应该定义 `operator!=`
+ 如果定义了 `operator==`，则运算符应该能判断一组对象中是否含有重复数据
+ 相等运算符和不等运算符中的一个应该把工作委托给另一个，这意味着其中的一个应该负责实际的比较工作，而另一个应该调用这个真正工作的运算符



### 14.3.2 关系运算符

当定义关系运算符 `operator<` 时需要遵守：

+ 定义顺序关系，令其与关联容器中对关键字的要求一致
+ 并且，如果类同时也含有 `==` 运算符的话，则定义一种关系令其与 `==` 保持一致。特别的，如果两个对象是 `!=` 的，则一个对象应该 `<` 另一个



> 如果存在唯一一种逻辑可靠的 `<` 定义，则应该考虑为这个类定义 `<` 运算符
>
> 如果类同时还有 `==`，则当且仅当 `<` 的定义和 `==` 产生的结果一致时才定义 `<` 运算符



## 14.4 赋值运算符

赋值运算符除了拷贝赋值运算符和移动赋值运算符外，还可以定义接受花括号内的元素列表作为参数的赋值运算符

```C++
Data &operator=(std::initializer_list<std::string>)
{
    
}
```

和拷贝赋值以及移动赋值一样，其他重载的赋值运算符必须释放当前的内存空间，再创建一片新空间



> 我们可以重载赋值运算符。不论形参类型是什么，赋值运算符都必须定义为成员函数



#### 复合赋值运算符

复合赋值运算符不非得是类的成员，但是我们倾向于将复合赋值在内的所有赋值运算都定义在类的内部

类中的复合赋值运算符也要返回其左侧运算对象的引用

在定义程序中则是返回 `*this`



> 赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用



## 14.5 下标运算符

表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符 `operator[]`

下标运算符必须是成员函数

下标运算符通常以所访问元素的引用作为返回值，这样的好处是下标可以出现在赋值运算符的任意一端

如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，一个是类的常量成员并且返回常量引用



## 14.6 递增和递减运算符

C++ 语言不要求递增和递减运算符必须是类的成员，但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数



定义递增和递减运算符应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类的成员



#### 定义前置递增/递减运算符

递增和递减运算符工作机制：首先检查是否有效，如果是，接着检查给定的索引是否有效

如果没有异常，则返回对象的引用



#### 区分前置和后置运算符

普通的重载形式无法区分前置和后置运算符

前置和后置版本使用的是同一个符号，意味着其重载版本的名字将是相同的，并且运算对象的数量和类型也相同



为了解决这个问题，后置版本接受一个额外的 `int` 类型的形参

当我们使用后置运算符时，编译器为这个形参提供一个值为 0 的实参

```C++
Data operator++(int);
```



> 为了与内置版本保持一致，后置运算符应该返回对象的原值，返回的形式是一个值而非引用

对于后置版本来说，在递增对象之前需要首先记录对象的状态，之后递增当前对象，然后返回记录的之前的对象值



#### 显式地调用后置运算符

可以显示地调用后置运算符，只需要为其整数参数传递一个值

```C++
p.operator++(0);		// 后置版本
p.operator++();			// 前置版本
```

尽管传入的参数通常会被忽略，但是必不可少，因为编译器只有通过它才能知道应该使用哪个版本



## 14.7 成员访问运算

我们可以重载迭代器和智能指针中的解引用运算符 `*` 和箭头运算符 `->`

```C++
std::string& operator*() const
{
    
}

std::string* operator->() const
{
    return & this->operator*();
}
```



> 箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此



#### 箭头运算符返回值的限定

对于大多数运算符，我们能定义其完成我们任何的指令操作

我们可以让 `operator*` 返回一个固定值，也可以打印对象的内容

但是箭头运算符则不是这样，它永远不能丢掉成员访问这个最基本的含义

当我们重载箭头时，可以改变的是箭头从哪个对象当中获取成员，而箭头获取成员这一事实则永不改变



> 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象



## 14.8 函数调用运算符

如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象

```C++
struct absInt {
  int operator() (int val) const {
      return val < 0 ? -val : val;
  }  
};
```

当一个类定义了一个函数调用运算符时，它的对象可以用于一个实参列表

```c++
int i = -42;
absInt absObj;
int ui = absObj(i);		// 含有函数调用运算符的对象
```

即使 `absObj` 只是一个对象而非函数，我们也可以调用该对象

调用对象实际上是在运行重载的调用运算符。此例中，该运算符接受一个 `int` 值并返回其绝对值



> 函数调用必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或者类型上有所区别



如果类定义了调用运算符，则该类的对象称作**函数对象**

因为可以调用这种对象



## 14.9 重载、类型转换与运算符

**类型转换运算符**是一种特殊的成员函数，它负责将一个类类型的值转换成其他类型

```C++
operator type() const;
```



一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表必须为空

类型转换函数通常应该是 `const`



#### 显示的类型转换运算符

为了防止自动转换带来的意想不到的情况，C++11 新标准引入了显示的类型转换运算符

```C++
explicit operator int() const {}
```

编译器不会将一个显式的类型转换运算符用于隐式类型转换



```C++
SmallInt si = 3;
si + 3;							// 错误，不能隐式地进行类型转换
static_cast<int>(si) + 3;		// 显式地请求类型转换
```



当表达式被用于以下情况时，显式的类型转换将被隐式地执行：

+ `if`，`while`，`do` 语句的条件部分
+ `for` 语句头的条件表达式
+ 逻辑非运算符、逻辑或运算符、逻辑与运算符的运算对象
+ 条件运算符的条件表达式



## 习题

+ 如何定义一个重载的运算符？

+ 当重载的运算符是成员函数时，会有什么变化？

+ 列举几个不能被重载的运算符

+ 为什么逻辑与或和逗号运算符不应该被重载？

+ 为什么 `&&` 和 `||` 不应该被重载？

+ 在什么情况下重载的运算符和内置运算符有所区别？在什么情况下重载的运算符又与内置运算符一样？

+ 如何确定下列运算符是否应该是类的成员？

  ```C++
  %	%=	++	->	<<	&&	==	()
  ```

+ 重载的输出运算符的第一个形参和第二个形参一般是什么样的？

+ 为什么重载的输出运算符不应该打印换行符？

+ 为什么输入输出运算符必须是非成员函数？

+ 为什么 IO 运算符需要被声明为友元函数？

+ 重载的输入操作符的两个形参是什么样的？

+ 为什么调用 `operator+=` 来定义 `operator+` 比其他方法更有效？

+ 定义相等运算符时应该遵守什么准则？

+ 定义关系运算符时应该遵守什么准则？

+ 重载的赋值运算和复合赋值运算符的返回值是什么

+ 如何区分重载的前置递增运算符和后置递增运算符？

+ 后置版本的递增运算符在实现上有什么是需要注意的？

+ 为什么不定义 `const` 版本的递增和递减运算符？

+ 如何显式地调用后置递增运算符？

+ 箭头运算符返回值的限定是什么？

+ 什么叫做函数对象？

+ 一个重载的函数调用运算符应该接受几个运算对象？

+ 如何定义一个类型转换函数？

+ 显式的类型转换函数和隐式的类型转换函数有什么区别？

+ 当什么情况下显式的类型转换会被执行为隐式类型转换？

+ 

