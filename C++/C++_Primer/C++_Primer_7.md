# C++ Primer 第七章 类

类的基本思想是**数据抽象**和**封装**

封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分

**\*\*所谓类的接口就是使得使用者在不知道具体实现细节的情况下能够使用类内提供的成员函数以及数据成员\*\***

```C++
class Sales_data {
public:
    Sales_data() = default;
    Sales_data(const std::string &s, unsigned n, double p):
    			bookNo(s), units_sold(n), revenue(p*n) {}
    Sales_data(const std::string &s): bookNo(s) {}
    Sales_data(std::istream&);
    std::string isbn() const { return bookNo; }
    Sales_data &combine(const Sales_data&);

private:
    double avg_price() const
    	{ return units_sold ? revenue / unit_sold : 0; }
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
```



## 7.1 定义抽象类型

**成员函数：**在类中声明的函数叫做成员函数。成员函数的声明必须在类的内部，它的定义既可以在类的内部也可以在类的外部

定义在类内部的函数是隐式的 `inline` 函数

> 为什么要将成员函数定义在类的外部？
>
> 因为定义在类内部的函数是隐式的 `inline` 函数，内联函数的目的是当调用函数时直接运行函数体
>
> 所以内联函数的长度一般都很短
>
> 所以将较短的函数定义在类的内部可以优化运行速度
>
> 同时将复杂的成员函数定义在类的外部



#### 引入 `this`

当使用类的对象调用成员函数时

```C++
Sales_data total;
total.isbn();
```

成员函数通过一个名为 `this` 的额外的隐式参数来访问调用它的那个对象

当我们调用一个成员函数时，用请求该函数的对象地址初始化 `this`

例如，如果调用 `total.isbn();`

编译器负责把 `total` 的地址传递给成员函数 `isbn` 的隐式参数 `this`，这样就知道成员函数内部代码中调用的是哪个对象的成员

因为 `this` 的目的总是指向“这个”对象，所以 `this` 是一个常量指针，我们不允许改变 `this` 中保存的地址



#### 引入 `const`

`const` 关键字紧随参数列表之后，这里 `const` 的作用是修改隐式 `this` 指针的类型

默认情况下，`this` 的类型是指向类类型非常量版本的常量指针，也就是说，`this` 是一个常量指针，但是它指向一个非常量

因此我们不能把 `this` 绑定到一个常量对象上，也使得我们不能在一个常量对象上调用普通的成员函数

然而，`this` 是隐式的并且不会出现在参数列表中，所以在哪将 `this` 声明成指向常量的指针呢？

C++ 语言的做法是允许把 `const` 关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的 `const` 表示 `this` 是一个指向常量的指针

像这样使用 `const` 的成员函数被称作 **常量成员函数**

由于 `this` 是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容



#### 类作用域和成员函数

类本身就是一个作用域。类的成员函数的定义嵌套在类的作用域之内

编译器在编译时，分两步来处理类：**首先编译成员的声明，然后才轮到成员函数体**。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序



#### 在类的外部定义成员函数

当在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配。也就是说，返回类型、参数列表和函数名都得与类内部的声明保持一致

如果成员被声明成常量函数，那么它的定义也必须在参数列表后明确 `const` 属性

同时，类外部定义的成员的名字必须包含**它所属的类名**

```C++
double Sales_data::avg_price() const
{
    if (units_sold)
    {
        return revenue/units_sold;
    }
    else
    {
        return 0;
    }
}
```

函数名 `Sales_data::avg_price()` 使用作用域运算符来说明如下事实：我们定义了一个名为 `avg_price` 的函数，并且该函数被声明在类 `Sales_data` 的作用域内



#### 定义一个返回 `this` 对象的函数

函数 `combine` 定义如下：

```C++
Sales_data& Sales_data::combine(const Sales_data &rhs)
{
    units_sold += ths.units_sold;
    revenue += rhs.revenue;
    return *this;
}
```

当调用这个函数时

```C++
total.combine(trans);
```

`total` 的地址被绑定到隐式的 `this` 参数上，而 `rhs` 绑定到了 `trans` 上

`return` 语句解引用 `this` 指针以获得执行该函数的对象，换句话说，返回了 `total` 的引用



### 7.1.3 定义类相关的非成员函数

类通常需要定义一下辅助函数，如 `read`，`add`，`print` 等。尽管这些函数定义的操作从概念上来说属于类的接口组成部分，但它们实际上并不属于类本身

一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内



### 7.1.4 构造函数

每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制器对象的初始化过程，这些函数叫做 **构造函数**

构造函数的任务是初始化类对象的数据成员，无论何时只要有类的对象被创建，就会执行构造函数



构造函数名字和类名相同

构造函数没有返回类型

构造函数的参数列表和函数体可以为空

类可以包含多个构造函数



构造函数不能被声明为 `const` 类型。当我们创建类的一个 `const` 对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在 `const` 对象的构造过程中可以向其写值



#### 合成的默认构造函数













## 习题

+ 在类中需要按照次序声明类的成员和定义成员函数体吗？
+ 当成员函数定义在类外部时需要注意什么？
+ 外部定义成员函数时使用作用域运算符的意义是什么？
+ 什么样的函数可以定义为类相关的非成员函数？







