# C++ Primer 第十八章 用于大型程序的工具

与仅需几个程序员就能开发完成的系统相比，大规模编程对程序设计语言的要求更高

大规模应用程序的特殊要求包括：

+ 在独立开发的子系统之间协同处理错误的能力
+ 使用各种库进行协同开发的能力
+ 对比较复杂的应用概念建模的能力



C++ 有三种语言特性正好能满足上述要求：异常处理、命名空间和多重继承



## 18.1 异常处理

**异常处理**机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理

异常使得我们能够将问题的检测与解决过程分离开来



### 18.1.1 抛出异常

在 C++ 语言中，我们通过**抛出**一条表达式来引发一个异常

被抛出的表达式的类型以及当前的调用链共同决定了哪段处理代码将被用来处理该异常



当执行一个 `throw` 时，跟在 `throw` 后面的语句将不再被执行

相反，程序的控制权从 `throw` 转移到与之匹配的 `catch` 模块

该 `catch` 模块可能是同一个函数中的局部 `catch`，也可能位于直接或间接调用了发生异常的函数的另一个函数中

控制权从一处转移到另一处



#### 栈展开

当抛出一个异常后，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的 `catch` 子句

当 `throw` 出现在一个 `try` 语句块内时，检查与该 `try` 块关联的 `catch` 子句

如果找到了匹配的 `catch`，就使用该 `catch` 处理异常

如果找不到匹配的 `catch`，且该 `try` 语句嵌套在其他 `try` 块中，则继续检查与外层 `try` 匹配的 `catch` 子句



**栈展开**：栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的 `catch` 子句为止

或者也可能一直没找到匹配的 `catch`，则退出主函数后查找过程终止



如果找到了匹配的 `catch` 子句，则程序进入该子句并执行其中的代码

当执行完这个 `catch` 子句后，找到与 `try` 块关联的最后一个 `catch` 子句之后的点，并从这里继续执行



> 一个异常如果没有被捕获，则它将终止当前的程序



#### 栈展开过程中对象被自动销毁

如果在栈展开过程中退出了某个块，编译器将负责确保在这个块中创建的对象能被正确销毁

如果某个局部对象的类型是类类型，则该对象的析构函数将被自动调用



如果异常发生在构造函数中，则当前的对象可能只构造了一部分

我们要确保已构造的成员被正确的初始化



#### 析构函数与异常

析构函数总是会被执行，但是函数中负责释放资源的代码却可能被跳过，这一特点对于我们如何组织程序结构有重要的影响

如果析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置在一个 `try` 语句块中，并且在析构函数内部得到处理



