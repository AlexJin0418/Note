# C++ 内存分布

## 栈和队列

+ 栈 stack
  + 先进后出 - 先进入的元素在栈底，后进的元素在栈顶
+ 队列 queue
  + 先进先出 - 从队列尾部进入，从头部出



```C++
int a = 0;							// (GVAR) 全局变量区
int *p1;							// (bss) 全局未初始化区

int main()							// (text) 代码区
{
    int b = 1;						// (stack) 栈区变量						
    char s[] = "abc";				// (stack) 栈区变量	
    int *p2;						// (stack) 栈区变量	内存空间地址从高地址到低地址
    char *p3 = "123456";			// "123456\0"在常量区，p3在(stack) 栈区变量	
    static int c = 0;				// (GVAR) 全局(静态变量)变量区
    p1 = new int(10);				// (heap) 堆区变量
    p2 = new int(20);				// (heap) 堆区变量
    char *p4 = new char[7];			// (heap) 堆区变量
    strcpy_s(p4, 7, "123456");
    
    return 0;
}

```



**\*\*从高地址到低地址 从上到下\*\***

+ **栈空间 STACK**
  + 由系统/编译器获取空间
  + 保存函数中声明的变量
  + 地址由下往上，从高到底增长
+ **未使用空间 unused memory**
  + 在栈空间和堆空间中的空间
+ **堆空间 HEAP**
  + 由程序员获取空间
  + 保存new创建的变量
  + 地址由上往下，从低到高增长
+ **全局未初始化区 BSS**
  + 保存未初始化的全局变量和静态变量
  + 编译器会给一个初始化的零值
+ **全局初始化区 GVAR**
  + 保存初始化的全局变量和静态变量
+ **代码区 TEXT**
  + 保存变量之外的程序代码



## 动态分配资源 - 堆 (Heap)

1. 从现代的编程语言角度来看，使用堆，或者说使用动态内存分配，是一件自然不过的事情
2. 动态内存带来了不确定性：内存分配耗时需要多久？失败了怎么办？在实时性要求比较高的场合，如嵌入式控制器和电信设备
3. 一般而言，当我们在堆上分配内存时，很多语言会使用`new`这样的关键字，有些语言则是隐式分配。在C++中`new`的对应词时delete，因为C++是可以让程序员完全接管内存的分配释放的



程序通常需要牵涉到三个内存管理器的操作：

+ 分配一个某个大小的内存块
+ 释放一个之前分配的内存块
+ 垃圾收集操作，寻找不再使用的内存块并予以释放；
  + 这个回收策略需要实现性能，实时性，额外开销等各方面的平衡，很难有统一和高效的做法
+ C++能够做到分配和释放内存块，Java能够坐到分配和垃圾回收的操作



## 栈中堆中的变量对比

|                    | 栈区 stack                                               | 堆区 heap                                              |
| ------------------ | -------------------------------------------------------- | ------------------------------------------------------ |
| 作用域             | 函数体内，语句块 {} 作用域                               | 整个程序范围内，由 new, malloc 开始，delete, free 结束 |
| 编译间大小是否确定 | 变量大小范围确定                                         | 变量大小范围不确定，需要运行期间确定                   |
| 大小范围           | Windows默认栈大小是 1M, linux 常见默认大小是 8M 或者 10M | 所有系统的堆空间上限是接近内存的总大小                 |
| 内存分配方式       | 地址由高到底减少                                         | 地址由低到高                                           |
| 内容是否可变       | 可变                                                     | 可变                                                   |



## 全局静态存储区和常量存储区的变量对比

|                      | 全局静态存储区     | 常量存储区 |
| -------------------- | ------------------ | ---------- |
| 存储内容             | 全局变量，静态变量 | 常量       |
| 编译期间大小是否确定 | 确定               | 确定       |
| 内容是否可变         | 可变               | 不可变     |



## 内存泄漏

+ 什么是内存泄漏问题：
  + 程序中已动态分配的堆内存由于某种原因程序未释放或无法释放造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果
+ 内存泄漏发生原因和排查方式
  + 内存泄漏主要发生在堆内存分配方式中，即“配置了内存后，所指向该内存的指针都遗失了”。若缺乏语言这样的垃圾回收机制，这样的内存片就无法归还系统
  + 因为内存泄漏属于程序运行中的问题，无法通过编译识别，所以只能在程序运行过程中来判别和判断

