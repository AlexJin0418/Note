# C++ 练习题



## 2021/07/18

+ 在进行赋值转换时，变量的类型被自动转换为赋值号右边的表达式的值。请问正确吗？

  > 错误。赋值运算是变量自动转换取决于左边的类型

+ 下面代码的运行结果是

  ```C++
  main() 
  { 
      int a[5]={1,2,3,4,5}; 
      int *ptr=(int *)(&a+1); 
      printf("%d,%d",*(a+1),*(ptr-1)); 
  }
  ```

  > 2，5
  >
  > *(a + 1)，a 表示数组，也可以表示数组的起始地址，则 a + 1 表示数组第二个元素的地址，解引后得到 2
  >
  > *ptr = (int *)(&a + 1)，&a 是数组的地址，由于分配了 4 * 5 = 20 的连续地址，那么 &a + 1 表示的是数组的下一个地址，即 a[5] 的地址，那么 ptr - 1 就是a[4] 的地址，所以得到 5

+ 为了提高程序的运行速度，在函数中对于整型或指针可以使用（）型的变量

  + `auto`
  + `register`
  + `static`
  + `extern`

  > register 建议编译器将该变量加入 CPU
  >
  > auto 为变量类型推演
  >
  > static 静态变量 只能在当前文件中使用
  >
  > extern 引入外部变量

+ 字符串"a+b=12\n"的长度为

  > 7
  >
  > 转义字符 \ 和后面的字符长度为1，同时 '\0' 只计算空间开销，不计算在长度内

+ 所谓私有成员是指只有类中所提供的成员函数才能直接使用它们，任何类以外的函数对它们的访问都是非法的

  > 错误
  >
  > 私有成员可以被类内提供的成员函数所使用
  >
  > 也可以被**友元函数**使用

+ 下列程序结果是多少

  ```C++
  #include <stdio.h>
  enum etest{
      eparam1,
      eparam2,
      eparam3=10,
      eparam4,
      eparam5='a',
      eparam6
  }epr;
  int main()
  {
      printf(“%d,%d”,eparam4,eparam6);
      return 0;
  }
  ```

  > 11, 98
  >
  > 枚举类的值会从上到下递增
  >
  > 所以 eparam4 = eparam3 + 1 = 11
  >
  > eparam6 = eparam5 + 1 = 'a' + 1 = 97 + 1 = 98
  >
  > 字符 'a' 的ASCII值为 97
  >
  > 字符 'A' 的ASCII值为 65

+ 关于C++中的友元函数说法正确的是

  + 友元函数只能访问所在类的保护成员和公有成员，不能访问私有成员
  + 友元函数不能被继承
  + 友元函数没有`this`指针
  + 友元函数破坏了继承性机制

  > B，C
  >
  > 友元函数可以访问类的私有成员
  >
  > 友元函数不能被继承，可理解为：你父亲的朋友不一定是你自己的朋友
  >
  > 友元函数是非成员函数，所以没有`this`指针，`this`指针只存在于成员函数内
  >
  > 友元函数破坏了类的封装，因为友元函数不是成员函数，所以没有破坏继承性机制

+ 以下指针与引用的区别描述错误的是

  + 指针是一个变量，存储的内容为一个地址；引用是给一个已有对象起的别名
  + 指针需要分配内存空间；引用不需要分配内存空间
  + 指针和引用自增运算结果一致
  + 指针是间接访问，引用是直接访问

  > 指针的自增运算是地址值的增加；引用的自增运算是原有值得增加
  >
  > 指针属于间接访问，而引用是直接访问因为引用是已有对象得别名

+ 若已定义的函数有返回值，则以下关于该函数调用的叙述中错误的是

  + 函数调用可以作为独立语句存在
  + 函数调用可以作为一个函数的实参
  + 函数调用可以出现在表达式中
  + 函数调用可以作为一个函数的形参

  > 函数调用的返回值存在寄存器中，并没有地址，所以无法作为形参，但是可以作为实参传递给形参

+ 一下代码的运行结果是

  ```C++
  以下代码的运行结果为：
  class Base {
  public:
  	Base() {echo();}
  	virtual void echo() {printf(“Base”);}
  };
   
  class Derived:public Base {
  public:
  	Derived() {echo();}
  	virtual void echo() {printf(“Derived”);}
  };
   
  int main() {
  	Base* base = new Derived();
  	base->echo();
  	return 0;
  }
  ```

  > 声明语句 `Base * base = new Derived();` 声明了 `Base` 类型的指针指向实际类型为 `Derived` 的对象
  >
  > 先调用基类构造函数，再调用派生类构造函数。输出 "Base" 和 "Derived"
  >
  > `base -> echo();` 指针是`Base`类型，但是有关键字`virtual`，所以不是隐藏而是重写，调用的是`Derived`的方法，输出 "Derived"
  >
  > 隐藏是指派生类的函数屏蔽了与其同名的基类函数。注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏
  >
  > 由于基类的 `echo()` 声明为虚函数，所以调用时会去寻找子类对应的虚函数执行

+ `stl::deque` 是一种什么数据类型？

  > deque 是双端队列，可以动态的在首位添加或删除元素，所以是动态数组类型

+ 关于C++的说法错误的是

  + 一个类可以有多个析构函数
  + 析构函数可以为`virtual`
  + 编译器不会为空类产生默认构造函数
  + 可以用 `free` 释放一个对象

  > 一个类只能有一个析构函数，且析构函数可以为 virtual
  >
  > 编译器会在某些时候为空类产生构造函数
  >
  > free 用来释放内存空间，若要释放一个对象还需要调用其析构函数，因此应该使用 delete



## 2021/07/19

+ 在类 Time 中的析构函数可以声明为：void ~Time(int);

  > 错误
  >
  > 类的析构函数与类名相同，以 ~ 为开头
  >
  > 析构函数不能有返回值（包括 void），也不能有参数，所以不可以重载

+ 请问下面代码的输出是多少

  ```C++
  #include <stdio.h>
  int main()
  {
      int m [] = {1,2,3,4,5,6,7,8,9,0};
      int(*p)[4] = (int(*)[4])m;
      printf(“%”,p[1][2]);
      return 0;
  }
  ```

  > `int(*p)[4]` 表示行指针，单位移动量为 4 个 int 类型。即 p + 1，则一次移动 4 个 int 类型
  >
  > `(int(*)[4])m` 表示已数组指针类型组织 m，每 4 个为一个数组
  >
  > `p[1][2]` 表示 p 的第一行，第二位，则对应为 { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0,  ,  } }
  >
  > 最后输出为 7

+ 以下程序输出的是为

  ```C++
  int main()
  {
      int a=1,b=2,m=0,n=0,k;
  
      k=(n=b<a)&&(m=a) ;
      printf("%d,%d\n",k,m);
  
      return 0;
  }
  ```

  > `n = b < a` 输出为 0
  >
  > C++ 逻辑运算短路：表达式 k = A && B，若 A 为 False，则直接返回 False 而不执行 B
  >
  > 同理 A || B 运算时如果 A 表达式为 True，则直接返回 True

+ 在下列函数中，哪个声明了纯虚函数

  + `void fun () = 0;`
  + `virtual void fun () = 0;`
  + `virtual void fun();`
  + `virtual void fun() {};`

  > 虚函数与纯虚函数的区别：
  >
  > 虚函数需要 virtual 关键字，并且无括号声明
  >
  > 纯虚函数在 virtual 关键字的基础上，还需要令它等于 0 

+ 下面关于指针的说法，正确的是

  + `int *const p` 与 `int const *p` 等价
  + `const int *p` 与 `int *const p` 等价
  + `const int *p` 与 `int const *p` 等价
  + `int *p[10]` 与 `int (*p)[10]` 等价

  > 根据 `const` 修饰的对象来判断指针是否为常量
  >
  > `const p` 表示 `const` 修饰变量 `p`，则变量`p`为常量
  >
  > `const *p` 表示 `const` 修饰变量 `p` 所指的内容，则 `p` 所指的内容为常量
  >
  > `int *const p` 为指向整型的常量指针，指针本身不可被修改，但是指针所指的地址内保存的值可以被修改
  >
  > `int const *p` 为指向整型常量的指针，指针所存放的数据不可被修改
  >
  > `const int *p` 同样为指向整型常量的指针
  >
  > `int *p[10]` 表示整型数组，存放 10 个指向整型类型的指针
  >
  > `int (*p)[10]` 表示数组指针，指向存放整型数据的数组

+ 以下关于内存泄漏说法正确的是

  + 如果一个进程运行过程中占用的内存无限制上升，那么该进程有内存泄漏
  + 单线程程序不可能内存泄漏
  + 内存泄漏是操作系统内存管理出错导致的问题
  + 只要进程在退出之前释放了所有分配的内存，那么就不会有泄露
  + 内存泄漏仅仅出现在C/C++程序中，Java程序不会内存泄漏

  > 内存泄漏是进程申请了内存却没有释放，导致内存无限制上升。但占用内存不代表内存泄漏
  >
  > 内存泄漏与线程数量无关
  >
  > 内存泄漏是程序BUG，不是操作系统管理出错
  >
  > 进程在退出前释放分配的内存能够阻止内存泄漏，但是内存可能在进程运行中出现泄露
  >
  > Java虽然有垃圾回收机制，但还是会出现内存泄露，比如加入 `Hashmap` 对象的 `hash` 值发生了改变就无法从 `Hashmap` 中移除

+ 下列语句中正确的是

  + `int a, &ra = a, &&ref = a;`
  + `int &refa[10];`
  + `int a, &ra = a, &*refp = &ra;`
  + `int *pi; *&pref = pi;`

  > 引用只能有一层，不能多层引用
  >
  > 不允许使用引用的数组，同时引用必须初始化
  >
  > 指针是指向一个对象的，指针不能指向一个引用
  >
  > 对指针的引用是合法的

+ 下面代码的最终输出是

  ```C++
  int main(void)
  {
      int i = 1;
      int j = i++;
      if ((i++ > ++j) && (++i == j)) i += j;
      printf("%d\n", i);  
      return 0;
  }
  ```

  > 3
  >
  > `int j = i++;` 先赋值后自增，所以 `j = 1`，`i = 2`
  >
  > 之后判断 `i++ > ++j`，这里 `i = 2`，`j = 2`，返回 False
  >
  > 之后表达式短路，并不会继续执行 `&&` 后的内容
  >
  > 所以 `i == 3`

+ 重载函数是否允许使用默认参数？

  > 重载函数允许使用默认参数，但是要考虑到函数的二义性
  >
  > 对于 `void foo();` 和 `void foo(int a = 0);`
  >
  > 当在调用 `foo()` 时，就会出现二义性，导致无法编译



## 2021/07/20

+ 以下不能作为合法常量的是：

  + `1.234e04`
  + `1.234e0.4`
  + `1.234e+4`
  + `1.234e0`

  > 实型字面值常量有两种表现形式：小数形式和指数形式
  >
  > 小数形式：由最前面的额正负号，数字 0 - 9 和小数点组成，不允许有其他符号
  >
  > 指数形式：包括指数和尾数两个不可缺少的部分，用符号E(e)分割；E(e)左边是尾数，为十进制整型或小数形式，右边为指数，必须为十进制整数
  >
  > 由于 B 选项指数为小数，故不正确

+ 为什么 `float` 和 `double` 不能参加位运算？

  > 由于 `float` 和 `double` 在内存中存储分为三个部分：符号位，指数位，尾数位；故位运算符没有意义
  >
  > 按位运算是对字节或字节中实际位置进行检测、设置或位移，它只适用于字符型和整数型变量以及他们的变体，对其他数据类型没有用
  >
  > 所以 `int`，`char`，`long int` 类型可以进行位运算

+ 下列函数中，不能说明为虚函数的是：

  + 私有成员函数
  + 公有成员函数
  + 构造函数
  + 析构函数

  > 虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数
  >
  > 常见不能声明为虚函数的有：普通函数(非成员函数)，静态成员函数，内联成员函数，构造函数，友元函数

+ 下面代码的输出结果是：

  ```C++
  int main(){
     int pid;
     int num=1;
     pid=fork();
      
     if(pid>0) {
     	 num++;
     	 printf("in parent:num:%d addr:%x\n",num,&num);
     }
     else if(pid==0) {
     	 printf("in child:num:%d addr:%x\n",num,&num);
     }
  }
  ```

  + 父子进程中输出的 `num` 相同，`num` 地址不同
  + 父子进程中输出的 `num` 不同，`num` 地址相同
  + 父子进程中输出的 `num` 相同，`num` 地址也相同
  + 父子进程中输出的 `num` 不相同，`num` 地址也不同

  > `fork` 出来时，虚拟地址一样，物理地址也一样。当进程发生分歧时，即修改此变量时，才会分配不同的物理地址，也就是 copy-on-write，写时复制
  >
  > 所以父子进程中输出的内容是不同的，但是 `num` 的地址相同

+ `X` 定义如下，若存在 `X a; a.x = 0x11223344;` 则 `a.y[1]` 的值可能为

  ```C++
  union X {
      int x;
      char y[4];
  }
  ```

  > 考虑大小端存储的问题
  >
  > 如果是小端存储，那么低位存储在低地址，0x44是低位，存放在低地址 y[0]
  >
  > 如果是大端存储，那么高位存储在低地址，0x11是高位，存放在低地址 y[0]

+ 执行下面的语句后，`y` 的值为：

  ```C++
  int x y;
  x = y = 1;
  ++x || ++y;
  ```

  > 表达式短路：当表达式为 `||` 时，如果第一个表达式为真，那么短路返回整个表达式为真
  >
  > 当表达式为 `&&` 时，如果第一个表达式为假，那么短路返回整个表达式为假
  >
  > 所以，++x = 2 为真，所以整个表达式的值为真  = 1




## 2021/07/22

+ 什么是数据流？

  > 数据流是指一组有顺序的、有起点的和终点的字节集合
  >
  > 数据流本身没有逻辑格式，数据流的解释方式由应用程序的操作决定

+ 指针变量 p 进行自加运算后，地址偏移为 1，则其数据类型为 char，说法是否正确？

  > 因为地址偏移为 1，所以可以判定数据类型的大小为 1
  >
  > 数据类型大小为 1 的有 char，unsigned char，以及空函数和 bool 类型


## C++ 与 C

+ 以下C语言和C++语言比较中错误的是：

  + C语言绝大部分语法适用于C++

  + C语言和C++的 `struct` 意义和用法一致

  + C语言不能使用继承，但C++可以

  + C++是面向对象的语言，C语言是面向过程的语言

    >C++的结构体可以有类属性用法，但C的结构体不行
    >
    >C++的结构体是类，可以有成员，函数，友元等
    >
    >但是C的结构体不可以有函数，只能有成员，而且也不可以有 `static` 关键字

+ 



## C 风格字符串

+ 以下代码哪一句会出错？

  ```C++
  char* s="AAA"; 		//1
  printf("%s",s); 	//2
  s[0]='B'; 			//3
  printf("%s",s); 	//4
  ```

  > 第3句
  >
  > 因为 `char *s = "AAA";` 
  >
  > 初始化指针时所创建的字符串常量被定义为只读
  >
  > 定义指针 `s`，指向的是一个常量区的 "AAA"，试图修改 `s` 则试图修改常量字符，所以会报错
  >
  > 如果试图修改这个值就会出现未定义
  >
  > 如果定义成 `char s[] = "AAA";` 相当于创建了一个副本，则此时可以进行修改

+ 对于 `char s1[] = {"abcd"}; s2[] = {'a', 'b', 'c', 'd'};` 下列叙述正确的是

  + 数组 s1 与 数组 s2 等价
  + 数组 s1 长度与数组 s2 长度相等
  + 数组 s1 长度大于数组 s2 的长度
  + 数组 s1 长度小于数组 s2 的长度

  > s1 是字符串，以 '\0' 结尾
  >
  > 大小：`sizeof(s1) = 5; sizeof(s2) = 4`
  >
  > 长度：`strlen(s1) = 4; strlen(s2) = 4`

+ 运行下面代码，输出结果是：

  ```C++
  #include <stdio.h>
  int main()
  {
      char *str[3] ={"stra", "strb", "strc"};
      char *p =str[0];
      int i = 0;
      while(i < 3)
      {
          printf("%s",p++);
          i++;
      }
      return 0;
  }
  ```

  > `char *str[3] ={"stra", "strb", "strc"};` 定义了一个指针数组，每一个元素是一个指针指向字符串的地址
  >
  > `char *p = str[0];` 定义了一个指针 `p` 指向 `str[0]` 的地址
  >
  > 此时 `p` 表示的是 `stra` 的地址
  >
  > 当 `p++` 时，实际是 `stra` 地址的移动，所以输出为 `stra tra ra`
  >
  > 当 `printf(%s)` 时，会遇到空格后停止输出



## C++ 指针

+ 下面的声明中调用正确的是：

  ```C++
  int fun6(int);
  int (*pf)(int) = fun6;
  ```

  + `int a=15; int n=fun6(&a);`
  + `int a = 15; cout<<(&pf)(a);`
  + `cout<<(pf)( 256 );`
  + `cout << pf( 256 );`

  > `int fun6(int)` 是一个函数声明
  >
  > `int (*pf)(int) = fun6;` 是一个指针函数
  >
  > 指针函数可以使用函数名直接调用

  

## `const` 关键字



+ 下列 `const` 使用方法错误的是

  + `const int Val = 10; Val = 20;`
  + `class A   {         const int SIZE = 100;         int array[SIZE];   };`
  + `class A { protected:  static int const Inity; };`
  + `int a=7;     const int *aPtr;      aPtr = &a;`

  > `const` 修饰的变量不能被修改值 A错
  >
  > C：`static` 变量在类内部声明，但是必须在类的外部进行定义和初始化



## `static` 关键字

+ 以下程序执行的结果是：

  ```C++
  #include <iostream>
  using namespace std;
  int i = 0;
  int function(int n)
  {
      static int a = 2;
      a++;
      return a + n;
  }
  void main()
  {
      int k = 5;
      {
         int i = 2;
         k += function(i);
      }
      k += function(i);
      cout << k;
  }
  ```

  > `int i = 0;` 为全局变量
  >
  > `k += function(i);` 第一次出现在局部作用域中，此时 `funciton(i)` 返回值为 5
  >
  > 第二次时，`static int a = 2;` 由于是静态类，所以只会在函数中进行一次初始化
  >
  > 所以第二次调用该函数时 `a = 3 + 1`
  >
  > 所以结果为 14

+ 

## 标准库函数

+ `fgetc` 函数的作用是从指定文件读入一个字符，该文件打开方式是？

  >`fgetc` 函数要求文件打开的方式必须是以读或读写的方式追加
  >
  >只写方式是不能读的

+ 
