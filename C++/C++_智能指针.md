# C++ 智能指针

使用指针是非常危险的行为，可能存在空指针，野指针问题，并可能造成内存泄漏

但是指针又非常的高效，所以我们希望以更安全的方式来使用指针



+ 一般有两种典型的方案：
  + 使用更安全的指针 - 智能指针
  + 不使用指针，使用更安全的方式 - 引用



### 智能指针

智能指针的实现原理：资源分配即初始化 RAII (Resource Acquisition Is Initialization)

定义一个类来封装资源的分配和释放，在构造函数完成资源分配和初始化，在析构函数完成资源的清理，可以保证资源的正确初始化和释放

**实现机制：**利用类的构造函数和析构函数是由编译器自动调取的



智能指针：

+ 管理指针执行对象的释放问题
+ 可以像指针一样使用



C++ 标准库中推出了四种常用的智能指针

+ `unique_ptr`
+ `shared_ptr`
+ `weak_ptr`
+ `auto_ptr` C++ 11中被废弃，C++ 17中被废除



### auto_ptr

由 new expression 获得对象，在 `auto_ptr` 对象销毁时，他所管理的对象也会自动被 delete 掉

即 RAII：在构造的时候获取资源，在析构的时候释放资源，并进行相关指针操作的重载

所有权转移：不小心把它传递给另外的智能指针，原来的指针就不再拥有对象了。在拷贝/赋值过程中，会直接剥夺掉指针对原来对象内存的控制权，转移给新对象，然后将原来的对象指针置为 `nullptr`。当试图访问原对象时，程序就会报错。不能有两个 `auto_ptr` 同时指向一个相同的对象。

由此会引起管理上的混乱

[浅谈auto_ptr智能指针](https://blog.csdn.net/qq_34992845/article/details/68939527)

[C++ 智能指针 auto_ptr详解](https://blog.csdn.net/gatieme/article/details/50939155)



### unique_ptr

unique_ptr 是专属所有权，所以 unique_ptr管理的内存，只能被一个对象持有，不支持复制和赋值

移动语义：unique_ptr 禁止拷贝语义，但有时我们也需要能够转移所有权，于是提供了移动语义，即可以使用 std::move() 进行控制权的转移