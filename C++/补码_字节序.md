# 补码

机器数：

一个数在计算机中的二进制表示形式，叫做这个数的机器数

机器数是带符号的，在计算机用一个数的最高位存放符号，整数为0，负数为1

十进制数 -3 -> 10000000000000000000000000000011

机器数对应  -> 11111111111111111111111111111101



真值：

真正的数学意义上的数值

因为第一位是符号位，所以机器数的形式值就不等于真正的数值



求补码公式：

1011 = -8 + 0 + 2 + 1 = -5

1111 = -8 + 4 + 2 + 1 = -1



另一种方式

对负数：保留符号位，对后面每位取反 + 1

1011 -> 保留负号，011 按位取反 -> 100 + 1 -> 101 = -5



## 字节序

一个字 (32位机器采用 32 `bits` 字长 4 `bytes`) 在内存中如何以 `byte` 来存放的？

32位机器中，最小处理的单位是以32位作为一个字，也就是一次可以处理4个字节

那么存在一个问题就是如何存放这4个字节



大端法 (Big Endian)：大多数IBM机器，Internet传输

| 地址  | 保存值 |
| ----- | ------ |
| 0x100 | 01     |
| 0x101 | 23     |
| 0x102 | 45     |
| 0x103 | 67     |

小端法 (Little Endian)：Intel 兼容机

| 地址  | 保存值 |
| ----- | ------ |
| 0x100 | 67     |
| 0x101 | 45     |
| 0x102 | 23     |
| 0x103 | 01     |



## 观察机器数

```C++
int i = 0;
int i2 = -1;
int i3 = -2147483648;
int i4 = 2147483647;

// &i2 = 0x00fffeec => ff ff ff ff
// &i3 = 0x00fffee0 => 00 00 00 80 小端表示 
```

为什么有符号的32位长 0x80000000 表示 -2147483648？

因为 0x80000000 表示为 2进制 为

1000 0000 0000 0000 0000 0000 0000 0000

因为是有符号的，所以第一位为符号位，剩下位取反 + 1

000 0000 0000 0000 0000 0000 0000 0000 -> 取反 -> 111 1111 1111 1111 1111 1111 1111 1111

加1后得到 1000 0000 0000 0000 0000 0000 0000 0000 = 2,147,483,648

故 0x80000000 在有符号的情况下等于 -2,147,483,648

又因为intel机器使用小端表示，所以 -2,147,483,648 在 32 位小端表示为 00 00 00 80

