# C++ 指针



## 左值与右值

左值：一般来说，编译器为其单独**分配了一块存储空间**，可以取其地址的，左值可以放在赋值运算符左边。左值也可以放在运算符的右边。

右值：指的是数据本身，或数据表示方式；不能取到其自身地址，右值只能赋值运算右边，如果放在赋值运算的左边则编译器会报错。



+ 左值最常见的情况如函数和数据成员的名字；
+ 右值是没有标识符，不可以取地址的表达式，一般也称之为“临时对象”；
+ 比如 `int a = b + c;`
  + `&a` 是允许的操作，而 `&(b + c)` 不能通过编译，因此 `a` 是一个左值，而 `b + c` 是一个右值



## C++中原始指针

+ 一般类型指针 `T*`
  + `T` 是一个泛型，泛指任何一种类型
+ 指针的数组 (array of pointers) 与 数组的指针 (a pointer to an array)
  + 指针的数组 `	T* t[]`
  + 数组的指针 `T(*t)[]`



## const 与 指针

const pointer 与 pointer to const

```C++
char strHelloworld[] = {"hellowowlrd"};
char const *pStr1 = "helloworld";			// 指向常量的指针
char* const pStr2 = "helloworld";			// 常量指针 指针指向的地址不可变
char const * const pStr3 = "helloworld";	// 指向常量的常量指针
const char * pStr4 = "helloworld";			// 指向常量的指针
pStr1 = strHelloworld;
```

关于 `const` 修饰的部分：

+ 看左侧最近的部分；
+ 如果左侧没有，则看右侧；
+ 如果修饰部分是变量类型，则指针指向地址中保存的值不可变
+ 如果修饰部分是指针，则指针指向的地址不可变，即指针的值不变



## 指向指针的指针

```C++
int a = 123;
int *b = &a;	// b 是指向 a 地址的指针
int **c = &b;	// c 是指向 b 地址的指针

// *b ==> a 123
// *c ==> b, &a
// **c ==> *b, a, 123
```

优先级为从里向外逐层求值 -> `**C` == `*(*C)`



## 野指针

未初始化和非法的指针

```C++
int *a;		// 声明变量，并在栈空间中分配变量
*a = 12;
// 声明指针变量时并未初始化变量，a指向的内容并未定义
// 相当于a中保存了一个随机的内存空间，并通过解引向这块随机空间中赋值 12
// 运气好的话，定位到一个非法地址，程序会报错，从而终止
// 最坏的情况，定位到一个可以访问的地址，无意修改了它，这样的错误难以捕捉，引发的错误可能与原先用于操作的代码完全不相干
```

定义指针时一定要初始化



### NULL指针

一个特殊的指针，不表示任何东西

`int *a = NULL; // nullptr`

表示特定的指针目前未指向任何东西，避免声明指针时指向任意地址



对于一个指针，如果已经知道它将被初始化为什么地址，那么请赋给它这个地址值，否则请把它**设置为NULL**

在对一个指针进行间接引用前，请先判断这个指针的**值是否为NULL**




### 野指针

垃圾指针，指向垃圾内存的指针，`if`等判断对它们不起作用，因为没有设置`NULL`

+ 指针变量没有初始化
+ 已经释放不用的指针没有设置NULL，如`delete`或者`free`的指针
+ 指针操作超越了变量的作用范围 -> 指向有生命周期的地址，一块生命周期后失效的地址



没有初始化的，不用的或者超出范围的指针请把值设置为`NULL`



## 指针的基本运算

`char ch = 'a';`

`char *cp = &ch;`



表达式 `&ch`是取地址的操作，该操作为右值，并不能作为左值，因为编译器并不会为`&ch`这个操作单独开辟一个地址空间来存放这个操作，也就是说`&ch`能得到`ch`的地址，但是这个操作并没有地址，所以是一个右值，并非左值



表达式 `*cp`即可作为左值也可作为右值

+ 作为左值时，表示为间接引用取出的是`ch`的存储空间，可以向该地址空间内赋值
  + `*cp = 'b';		// 表示为通过间接引用得到 ch 的地址空间，并向这个地址空间赋值`
+ 作为右值时，表示为`ch`的存储空间中保存的值，即`a`
  + `char ch2 = *cp; 	// 即表示为取出 ch 地址中保存的值，并赋值给 ch2`



表达式  `*cp + 1`

+ 作为左值为非法
  + `*cp`作为左值时表示为`ch`的地址，则`*cp + 1`为`ch`的地址`+1`，因为我们并未对该地址有明确的定义，所以该操作是非法的
+ 作为右值时，即为得到`*cp`的值后`+1`并再赋值给某个变量



表达式 `*(cp + 1)`

+ 作为左值表示为先将`ch`的地址向后移动，并访问该地址空间
+ 作为右值表示为先将`ch`的地址向后移动，并访问该地址内的值



### 指针的 ++ 与 -- 操作符

+ `char *cp2 = ++cp;		// 前置操作符，先递增后赋值`
  + `mov   eax, dword ptr [cp]`
  + `eax   1`
  + `mov   dword ptr [cp], eax`
  + `mov   ecx, dword ptr [cp]`
  + `mov   dword ptr [cp2], ecx`
+ `char *cp2 = cp++;		// 后置操作符，先赋值后递增`

### 指针的 ++++, ---- 等运算符

编译器程序分解成符号的方法是：一个字符一个字符的读入，如果该字符可能组成一个符号，那么读入下一个字符，一直到读入的字符不能再组成一个有意义的符号。



