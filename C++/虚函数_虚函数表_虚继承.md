# 虚函数/虚函数表/虚继承

## 虚函数

虚函数实现了运行时多态



虚函数通过一张虚函数表 (Virtual Table) 来实现，实际上是一个**函数指针的数组**

虚函数表存放了一个类的虚函数的地址，这张表解决了继承、覆盖问题，保证其内容真实反映实际的函数

在虚函数的类的实例中这个表被分配在这个实例的内存中

所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得尤为重要了，它就像一张地图，指明了实际应该调用的函数

> 父类的指针根据虚函数表来确定要调用的是哪个子类的函数



C++编译器保证虚函数表的指针存放在对象实例中最前面的位置

这意味着我们可以通过对象实例的地址得到这张虚函数表，然后可以遍历其中的指针，并调用相应的函数



#### 打印虚函数表

虚函数表的指针存放在对象实例的最前位置

我们可以通过创建一个函数指针来访问虚函数表

```C++
typedef void(*Vtable)();

Derive b;
Vtable vtb = NULL;
vtb = (Vtable) * (int*)*(int*)(&b);

vtb();		// 指针函数调用第一个虚函数
```

其中

`&b` 会得到派生类对象的地址值

`(int*)(&b)` 将指针转换成 `int*` 指针，指向对象内存地址空间的前四个字节

`*(int*)(&b)` 解引用地址会得到指向虚函数表的指针

`*(int*)*(int*)(&b)` 再次解引用将得到虚函数表的第一项内容

`(Vtable)*(int*)*(int*)(&b)` 将指向虚函数表第一项的内容转换成指针函数的类型

由此调用指针函数则可以访问虚函数表的第一项



#### 虚函数表位置

虚函数表的指针存放在实例的地址中，所以虚函数表指针存放于堆中

虚函数表存放在只读数据段 `.rodata` 内



#### 如果派生类没有覆盖基类中的任何虚函数

```C++
class Base {
public:
    virtual void Foo() 
    {
        cout << "Base:Foo()" << endl;
    }

    virtual void Bar()
    {
        cout << "Base:Bar()" << endl;
    }

    virtual void Baz()
    {
        cout << "Base:Baz()" << endl;
    }
};


class Derive : public Base {
public:
    virtual void Foo1()
    {
        cout << "Derived:Foo1()" << endl;
    }
};
```

则此时在虚函数表中的地址顺序为：`Base:Foo(), Base:Bar(), Base:Baz(), Derive:Foo1()`

+ 虚函数表按照声明的顺序放于表中
+ 父类的虚函数在子类的虚函数前面
+ 派生类中没有声明为虚函数的函数不会被放在虚函数表中
+ 即使派生类中的虚函数会存放在基类的虚函数表中，但是基类指针指向派生类对象无法访问派生类中没有覆盖的虚函数



#### 如果派生类覆盖了基类的虚函数

```C++
class Base {
public:
    virtual void Foo() 
    {
        cout << "Base:Foo()" << endl;
    }

    virtual void Bar()
    {
        cout << "Base:Bar()" << endl;
    }

    virtual void Baz()
    {
        cout << "Base:Baz()" << endl;
    }
};


class Derive : public Base {
public:
    virtual void Foo()
    {
        cout << "Derived:Foo()" << endl;
    }
};
```

则此时虚函数表中的地址顺序为：`Derive:Foo(), Base:Bar(), Base:Baz()`

+ 覆盖的派生类函数会放在基类函数的位置
+ 没有被覆盖的函数位置保持不变



```C++
Base *b = new Derive();
b->Foo();
```

由 `b` 所指向的内存中的虚函数表中的 `Foo` 地址已经被派生类的实现所覆盖

所以在调用时，实际被调用的是 `Derive:Foo()`

由此实现了多态



#### 多继承时的虚函数表

当出现多继承时，如果派生类没有覆盖基类的函数

+ 每个父类都有自己的虚函数表
+ 父类的虚函数表按照继承的顺序排序
+ 派生类的成员函数被放在第一个父类的表中

当派生类继承了基类的函数时

+ 覆盖的派生类函数放在父类的虚函数表中原来的位置



## 不同对象实例的虚函数表

+ 创建基类对象的虚函数表：只会指向基类的虚函数，无论派生类是否覆盖；派生类虚函数不会出现在虚函数表中
+ 创建派生类对象的虚函数表：会继承基类的虚函数，并能够通过虚函数表访问；派生类虚函数在基类虚函数后面；如果覆盖则覆盖在相应位置
+ 创建基类指针指向派生类对象的虚函数表：虚函数表含有基类和派生类的虚函数，但是无法通过基类的指针访问派生类的虚函数



#### 以下函数不可以当作虚函数：

+ 友元函数，它不是类的成员函数
+ 全局函数
+ 静态成员函数，因为没有 `this` 指针；虚函数的调用需要对象来完成
+ 构造函数，拷贝构造函数，因为虚函数表在构造函数执行完后才会创建



虚析构函数保证了当基类的指针指向派生类对象时能够正确的释放派生类的对象

因为当基类定义了虚析构函数时，派生类会自动定义合成析构函数或者是覆盖基类的析构函数

工作方式：最底层的派生类的析构函数最先被调用，然后各个基类的析构函数被调用



#### 关于私有虚函数可以被派生类覆盖

一个观点是：调用虚函数是通过虚函数表中的地址来访问虚函数，所以与函数的可见性无关，派生类可以覆盖基类的私有虚函数



由于虚函数必须被对象调用，而私有的成员函数无法被对象调用

所以调用私有虚函数的方法只有通过虚函数表来调用

创建一个指针函数，找到虚函数表的地址并调用相应的私有虚函数

```C++
class Base {
private:
    virtual void Coy()
    {
        cout << "Base:Coy()" << endl;
    }
};

class Derive : public Base {

};

typedef void(*Vtable)();

int main () {
   Derive b;
   Vtable vtb = NULL; 
    
   vtb = (Vtable) * ((int*)*(int*)(&b));
   vtb();		// "Base:Coy()    
}
```



## 纯虚函数

```C++
virtual void Foo() = 0;		// 声明纯虚函数
```

纯虚函数在基类中声明，在子类中实现

含有纯虚函数的基类是抽象类，只含有纯虚函数的基类是接口类

子类如果没有实现基类的纯虚函数，那么子类也是抽象类



## 虚继承

虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝



为了解决多继承时的命名冲突和冗余数据问题，C++提出了虚继承，使得派生类中只保留一份间接基类的成员

在继承方式前加上 `virtual` 关键字就是虚继承

```C++
class A {
protected:
   	int m_a;
};

class B : virtual public A {	// 虚继承
protected:
    int m_b;
};

class C : virtual public A {	// 虚继承
protected:
    int m_c;
};

class D : public B, public C {
public:
    void seta(int a){ m_a = a; } 
    void setb(int b){ m_b = b; }  
    void setc(int c){ m_c = c; }  
    void setd(int d){ m_d = d; }  
};
```

如果不适用虚继承的话，由于 `B` 和 `C` 都继承自 `A`，则两个类的实例中都有 `m_a` 的变量

但是当 `D` 继承自 `B` 和 `C` 时，编译器不知道要调用哪个基类的 `m_a`

所以可以指定 `void seta(int a){ B::m_a = a }`

但使用虚继承后，派生类只会保留一份间接基类的成员，此时 `D` 的对象可以直接访问 `m_a`



虚继承的目的是让某个类做出声明，承诺愿意共享它的基类

这个被共享的类就是**虚基类**，上例中 `A` 就是虚基类

在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员



但这种体系下，必须在虚派生的真实需求出现前就已经完成虚派生的操作

**虚继承只影响了虚基类的派生类的进一步的派生类，它不会影响派生类本身**



[C++虚继承和虚基类详解](http://c.biancheng.net/view/2280.html)

[C++打印虚函数表](https://blog.csdn.net/a13602955218/article/details/104743492)

[C++虚函数详解](https://blog.csdn.net/lyztyycode/article/details/81326699)

