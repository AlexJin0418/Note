# 进程间通信

**进程间通信 (Inter Process Communication, IPC)**：进程之间需要通信，而且最好使用一种结构良好的方式而不要使用中断。

进程通信需要考虑三个问题：

1. 进程间如何把信息传递给另一个。

2. 确保两个或多个进程在关键活动中不会出现交叉。

3. 需要保证进程间通信的顺序。

由于CPU实际上在执行线程，线程之间也需要进行通信。对于线程而言，它们共享进程的地址空间，所以不需要考虑消息的传递。但是另外两个问题也都适用于线程。

## 竞争条件
在一些操作系统中，协作的进程可能会共享一些彼此都能读写的公用存储区。考虑一个打印机程序，当一个进程要想打印一个文件时，它将文件名放在一个特殊的假脱机目录下。另一个打印机守护进程则周期性地检查是否有文件需要打印。

设想假脱机目录里面有许多槽位，每个槽位存放一个变量名。同时有两个共享变量：out，指向下一个要打印的文件名；in，指向目录中下一个空闲槽位。

假设此时有两个进程都决定将一个文件排队打印。进程A首先读到in的值，假定为4，表示假脱机目录中下一个空闲的槽位是4。进程将in的值保存在一个局部变量中。此时假设CPU认为进程A运行了足够长的时间，就会发生一次时钟中断，CPU将会切换到进程B。进程B也读取in的值，这时候in的值还是4。进程B也将in的值保存在一个局部变量中。

这时候两个进程都认为下一个可用的槽位是4，同时它们都将这个值保存在了本地的局部变量中。此时进程B继续运行，将文件名保存在in指示的槽位中，并将in的值更新为5。这时候进程B离开这个打印机程序，进行其他操作。

此时CPU开始继续执行进程A，进程A将会从上次中断的地方运行。进程A检查存在本地的in值，发现是4，于是将需要打印的文件名保存到4号槽位，并更新in的值为5。

此时，在假脱机目录内，对于打印机而言，它并不会发现任何异常，打印机守护进程将会读取槽位4中的文件名并打印出来。但进程B却永远得不到任何打印输出。

对于这样的情况，即两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为**竞争条件 (race condition)**。

## 临界区
凡是涉及共享内存，共享文件以及共享任何资源的情况都会引发与竞争条件类似的错误。要避免这种错误，需要找出某种途径来组织多个进程同时读写共享的数据。换言之，它们需要的是**互斥 (mutual exclusion)**。即在某个进程完成对共享数据的操作前，其他进程无法对共享数据进行操作。

我们可以将对共享内存进行访问的程序代码片段称作**临界区域 (critical region)** 或**临界区 (critical section)** 。使得两个进程不可能同时处于临界区中，就能够避免竞争条件。

要保证共享数据的并发进程能够正确和高效地进行协作。对于一个好的解决方案，需要满足以下4个条件：

1. 任何两个进程不能同时处于其临界区。

2. 不应对CPU的速度和数量做任何假设。

3. 临界区外运行的进程不得阻塞其他进程。

4. 不得使进程无限期等待进入临界区。

## 忙等待的互斥
在忙等待互斥中，一个进程在临界区中更新共享内存时，其他进程将不会进入临界区。

**1. 屏蔽中断**

在单处理器系统中，最简单的方法就是每个进程在刚刚进入临界区后立即屏蔽所有中断，并在要离开之前再打开中断。屏蔽中断后，时钟中断也被屏蔽。这样，CPU无法通过时钟中断进行进程切换。于是，一旦某个进程屏蔽中断，它就可以一直拥有CPU并检查和修改共享内存，而不必担心其他进程介入。

这个方案并不好，因为将时钟屏蔽的权力交给用户进程可能会导致整个系统终止。而且，如果系统是多处理器，那么屏蔽中断仅仅对执行该进程的CPU有效，其他CPU可以继续访问共享的内存地址。

另一方面，操作系统可以通过屏蔽中断来保证更新变量或列表等必要操作不被中断。所以屏蔽中断对操作系统本身而言是一项很有用的技术，但对于用户进程则不是一种适合的通用互斥机制。

**2. 锁变量**

寻找一种软件解决方案。设想使用一个**共享的锁变量**，其值为0。当一个进程想进入其临界区时，首先测试锁变量的值。如果锁为0，那么该进程将其设置为1并进入临界区。如果这个锁变量的值是1，则该进程等待直到其值变为0。

这种方法包含了与假脱机目录相同的问题。如果一个进程在将锁变量得值设定为1之前，另一个进程被调度运行，并将锁变量设置为1。当第一个进程再次运行时，它同样也将该锁设置为1，则此时同时有两个进程进入该临界区。

**3. 严格轮换法**

设定一个整型变量turn来表示当前能够进入临界区线程的编号。开始时，进程0检查turn，发现其值为0，于是进入临界区。进程1也发现turn的值为0，所以在一个等待循环中不停地测试turn，看其值何时变为1。

进程0离开临界区时，它将turn的值设置为1，以便允许进程1进入其临界区。进程1随后可以进入临界区进行操作，在离开临界区时进程1将turn的值设置为0。

这种连续测试一个变量直到某个值出现为止的行为称为**忙等待 (busy waiting)**。这种方式浪费CPU时间，所以通常应该避免。

用于忙等待的锁，称为**自旋锁 (spin lock)**。

当出现一个进程比另一个进程慢了很多的情况下，快的进程会一直等待慢的进程在临界区外运行直到其进入临界区并更改turn的值。所以轮流进入临界区不是一个好办法。

这种情况违背了避免竞争条件的第三条，即临界区外运行的进程不得阻塞其他进程。

**4. Peterson解法**

Peterson解法是一个不需要严格轮换的软件互斥算法。

```C
#define FALSE 0
#define TRUE 1
#define N 2                         // 进程数量

int turn;                           // 现在轮到谁
int interested[N];                  // 所有初始化的值为 0 false

void enter_region(int process)      // 调用进程是 0 或 1
{
    int other;                      // 另一个进程号
    
    other = 1 - process;
    
    interested[process] = TRUE;       // 另一个进程感兴趣
    turn = process;                 // 设置标志
    
    while(turn == process && interested[other] == TRUE); // 空语句
}

void leave_region(int process)      // 离开进程
{ 
    interested[process] = FALSE;    // 表示离开临界区
}

```

在进入临界区之前，各个进程使用其进程号 0 或 1 作为参数来调用 enter_region。该调用在需要时将使进程等待，直到能安全地进入临界区。

在完成对共享变量的操作后，进程将调用 leave_region，表示操作已完成，若其他的进程希望进入临界区，则现在就可以进入。

一开始，没有任何进程处于临界区中，现在进程 0 调用 enter_process，并设置 turn = 0, interested[process] = 0。由于此时进程1并不想进入临界区，所以进程0可以很快返回。

如果此时进程1调用 enter_process，进程1将在此处挂起直到 interested[0] 变成FALSE，即进程0离开临界区。

此方法与严格轮换法的区别在于，严格轮换法要求进程即便空闲出来可以进入临界区也要等待另一个进程进入一次临界区后将turn值改变才能进入。

而Peterson解法使得进程在另一个进程离开后就可以立即进入临界区。

**Peterson和其他使用锁变量的区别在于它给两个进程各自一个锁(interested[process])和一个公共锁(turn)，只有当两个锁条件都满足时，进程才能进入临界区。**

**5. TSL指令**
TSL指令是一条硬件指令。

`TSL RX, LOCK`

称为**测试并加锁(test and set lock)**，它将一个内存字lock读到寄存器RX中，然后在该内存字地址上存一个非零值。在该指令结束之前其他处理器均不允许访问该内存字。

执行TSL指令的CPU将锁住内存总线，以禁止其他CPU在本指令结束之前访问内存。

当lock为0时，任何进程都可以使用TSL指令将其设置为1，并读写共享内存。当操作结束时，进程用一条普通的move指令将lock的值重新设置为0。

**防止两个进程进入临界区：**

```
enter_region:
    TSL REGISTER, LOCK      | 复制锁到寄存器并将锁设置为1
    CMP REGISTER, #0        | 判断锁是否为0
    JNE enter_region        | 若不是0，说明锁已经被设置，所以循环
    RET                     | 当锁为0时，说明锁没有被使用，那么可以进入临界区
    
leave_region:
    MOVE LOCK, #0           | 在锁中存入0
    RET                     | 返回调用者
```

当使用锁时，将LOCK的值存入一个寄存器中，并给锁的值设置为非零数，这样其他想要进入临界区的进程会得到锁的值不等于0，则会在临界区外进行等待。

一个可以替代TSL的指令是XCHG，它原子性地交换了两个为止的内容。即在寄存器中存入1，当要设置锁的时候将寄存器和锁变量的内容进行交换。```XCHG REGISTER, LOCK```

## 睡眠与唤醒
Peterson解法和TSL或XCHG解法都是正确的，但他们都有**忙等待**的缺点。

这些解法的本质是：**当一个进程想要进入临界区时，先检查是否允许进入，若不允许，则该进程将原地等待，直到允许为止。**

忙等待不仅仅会浪费CPU时间，也会使得优先级高的线程长时间等待优先级低的进程离开临界区，导致**优先级反转问题**。

考虑进程间通信的原语sleep和wake up，它们在无法进入临界区时将被阻塞，而不是忙等待。这样当进程无法访问临界区时，它将被阻塞并放弃CPU，使得在临界区内的进程更快得获得CPU并进行临界区内的操作。

**生产者-消费者问题**

生产者-消费者(producer-consumer)问题 或，有界缓冲区(bounded-buffer)问题。

两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者，将信息放入缓冲区；另一个是消费者，从缓冲区中取出信息。

当缓冲区已满，而此时生产者还想向其中放入一个新的数据项时。解决方法是让生产者睡眠，待消费者从缓冲区中取出一个或多个数据项时再唤醒生产者。

同样地，当消费者试图从缓冲区中取数据而发现缓冲区为空时，消费者就睡眠，直到生产者向其中放入一些数据时再将其唤醒。

为了判断当前共享缓冲区是否已满，需要一个公共共享变量count来记录缓冲区内数据地数量。

```C
#define N 100                       // 缓冲区的大小
int count = 0;                      // 缓冲区中数据项目的数量

void producer(void)
{
    int item;
    
    while(TRUE) {
        item = produce_item();      // 生产一个新的数据项
        if (count == N) sleep();    // 如果缓冲区满了，就进入休眠状态
        insert_item(item);          // 将新数据项放入缓冲区中
        count = count + 1;          // 将缓冲区的数据项计数器增加1
        if (count == 1) wakeup(consumer); // 如果缓冲区不为空，则唤醒消费者
    }
}

void consumer(void)
{
    int item;
    
    while(TRUE) {
        if (count == 0) sleep();    // 如果缓冲区为空，则将消费者睡眠
        item = remove_item();       // 从缓冲区取出一个数据项
        count = count - 1;          // 缓冲区计数器减1
        if (count == N - 1) wakeup(producer); // 如果缓冲区未满，则唤醒生产者
        consume_item(item);         // 打印数据项
        
    }
}

```

使用sleep和wakeup解决了忙等待的问题，但是对于count的访问未加以限制。

有可能出现以下情况，缓冲区为空时，消费者刚刚读取count的值为0，此时调度程序立即将CPU使用权交给了生产者。生产者在生产出一个数据项后尝试唤醒消费者。

而消费者由于读取count之后就被立即调度出去了，所以此时wakeup信号丢失。消费者判断已经读取了的count值后发现为0，所以进入睡眠。

而生产者以为此时消费者在清醒的状态，并一直向缓冲区中添加数据项，直到填满后睡眠。

这样，生产者和消费者都处于睡眠状态，并无法被唤醒。

问题的实质在于：**发给一个尚未睡眠进程的wakeup信号丢失了。如果它没有丢失，则一切都很正常**。

这种问题的解决方法是，加上一个**唤醒等待位**。即当一个wakeup信号发给一个清醒的进程信号时，将该位置1。随后，当进程要睡眠时，如果唤醒等待位为1，则将该位清除，而该进程仍然保持清醒。

唤醒等待位实际上是wakeup信号的一个小仓库，用来存储未被使用的wakeup信号，以此来抵消之后将出现的睡眠信号。

当出现更多的进程时，一个唤醒等待位就不够使用了。对于多个进程运行时，可能需要添加更多的唤醒等待位，那么从原则上讲，并没有解决wakeup信号丢失的问题。
