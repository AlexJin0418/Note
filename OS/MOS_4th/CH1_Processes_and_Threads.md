# 进程与线程

## 进程

进程是对正在运行的程序的一个抽象。

**伪并行：** 在任何多道程序设计系统中，CPU由一个进程快速切换至另一个进程 (context switch)，使每个进程各运行几十或几百毫秒。严格地说，在某一瞬间，CPU只能运行**一个进程**。
但在一秒内，它可能运行多个进程，这样就产生并行的错觉。

### 进程模型
一个进程就是一个正在执行程序的实例，包括程序计数器，寄存器和变量的当前值。从概念上说，每个进程拥有它自己的虚拟CPU。

进程和程序的区别是很微妙的。进程拥有状态，即当前完成度，但是程序没有。一个进程是某种类型的一个活动，它有程序，输入，输出以及状态。
所以可以说进程是一个正在运行的程序。

### 进程的创建
4种主要事件会导致进程的创建：
+ 系统初始化：启动操作系统时，通常会创建若干个进程。其中有些是前台程序与用户进行交互，有些是后台程序具有专门的功能，这些程序被称为**守护程序(deamon)**。

+ 正在运行的程序执行了创建进程的系统调用：一个正在运行的进程可以发出系统调用以便创建一个或多个新进程协助工作。

+ 用户请求创建一个新的进程：用户可以在交互式系统中通过键入命令或者双击图标启动一个程序，并创建一个新的进程。

+ 一个批处理作业的初始化：大型批处理系统中，如果操作系统认为有资源可以运行另一个作业时，它创建一个新的进程。

在所有的情形中，新进程都是由**一个已存在的进程**执行了一个用于**创建进程的系统调用**而创建的。这个进程可以是一个运行的用户程序，一个由键盘或鼠标启动的系统进程或者一个批处理管理程序。

**UNIX系统**

在UNIX系统中，使用`fork`创建新进程。这个系统调用会创建一个与调用进程相同的副本。
在调用`fork`后，父进程和子进程拥有相同的内存映像，同样的环境字符串和同样的打开文件。

子进程在创建时内存通过**写时复制(copy-on-write)** 与父进程共享。子进程不分配物理空间，并共享父进程的物理空间。当父子进程之一对内存进行修改时，内核再为子进程分配物理空间。

通常，子进程接着执行一个系统调用以修改其内存映像并运行一个新的程序。

**Windows系统**

在Windows系统中，一个Win32函数调用`CreateProcess`既处理进程的创建，也负责把正确的程序装入新的进程。

Windows中，从一开始父进程的地址空间和子进程的地址空间就是不同的。

### 进程的终止
进程的终止由以下条件引起：
+ 正常退出 (自愿的)：因完成了工作而终止。通过系统调用或者供用户点击的图标来对进程进行终止。

+ 出错退出 (自愿的)：进程发现了错误后退出进程，并会反馈错误参数。

+ 严重错误 (非自愿)：进程引起的错误，比如执行了一条非法指令，引用不存在的内存等。

+ 被其他进程杀死 (非自愿)：进程通过调用`kill`或者其他指令可以通知操作系统将其他进程杀死。

### 进程的层次结构
在UNIX中，进程和它的所有子进程以及后裔共同组成一个进程组。考虑UNIX在启动时初始化自己。一个称为init的特殊进程出现在启动映像中。当它开始运行时，
为每个终端创建一个新进程。这些进程等待用户登录，一旦有用户成功登录，该登录进程就执行一个shell准备接收命令。所接收的命令会启动更多的进程。
这样，在整个系统中，所有的进程都属于以init为根的一棵树。

Windows中没有层次的概念，所有的进程都是地位相同的。

### 进程的状态
一个进程的输出结果可能作为另一个进程的输入。

考虑以下代码
```shell
cat chapter1 chapter2 chapter3 | grep tree
```
`cat`是进程1，`grep`是进程2。两个进程的相对速度不同，可能发生这种情况：grep准备就绪可以运行，但输入还没有完成。于是必须阻塞grep，直到输入的到来。

当一个进程在逻辑上不能继续运行时，它就会被阻塞。另一种情况是，一个概念上能够运行的进程被迫停止，因为操作系统调度另一个进程占用了CPU。

所以进程有三种状态：
1. 运行态 (该时刻进程实际占用CPU)

2. 就绪态 (可运行，但因为其他进程正在运行而暂时停止)

3. 阻塞态 (除非某种外部事件发生，否则进程不能运行)

进程的三种状态之间有四种可能的转换关系：
1. 运行 -> 阻塞：进程因为等待输入而被阻塞

2. 运行 -> 就绪：调度程序选择另一个进程

3. 就绪 -> 运行：调度程序选择了当前的进程

4. 阻塞 -> 就绪：出现有效输入

调度程序的主要工作就是决定应当运行哪个进程，何时运行及它应该运行多长时间。



