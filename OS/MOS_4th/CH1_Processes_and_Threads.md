# 进程与线程

## 进程

进程是对正在运行的程序的一个抽象。

**伪并行：** 在任何多道程序设计系统中，CPU由一个进程快速切换至另一个进程 (context switch)，使每个进程各运行几十或几百毫秒。严格地说，在某一瞬间，CPU只能运行**一个进程**。
但在一秒内，它可能运行多个进程，这样就产生并行的错觉。

### 进程模型
一个进程就是一个正在执行程序的实例，包括程序计数器，寄存器和变量的当前值。从概念上说，每个进程拥有它自己的虚拟CPU。

进程和程序的区别是很微妙的。进程拥有状态，即当前完成度，但是程序没有。一个进程是某种类型的一个活动，它有程序，输入，输出以及状态。
所以可以说进程是一个正在运行的程序。

### 进程的创建
4种主要事件会导致进程的创建：
+ 系统初始化：启动操作系统时，通常会创建若干个进程。其中有些是前台程序与用户进行交互，有些是后台程序具有专门的功能，这些程序被称为**守护程序(deamon)**。

+ 正在运行的程序执行了创建进程的系统调用：一个正在运行的进程可以发出系统调用以便创建一个或多个新进程协助工作。

+ 用户请求创建一个新的进程：用户可以在交互式系统中通过键入命令或者双击图标启动一个程序，并创建一个新的进程。

+ 一个批处理作业的初始化：大型批处理系统中，如果操作系统认为有资源可以运行另一个作业时，它创建一个新的进程。

在所有的情形中，新进程都是由**一个已存在的进程**执行了一个用于**创建进程的系统调用**而创建的。这个进程可以是一个运行的用户程序，一个由键盘或鼠标启动的系统进程或者一个批处理管理程序。

**UNIX系统**

在UNIX系统中，使用`fork`创建新进程。这个系统调用会创建一个与调用进程相同的副本。
在调用`fork`后，父进程和子进程拥有相同的内存映像，同样的环境字符串和同样的打开文件。

子进程在创建时内存通过**写时复制(copy-on-write)** 与父进程共享。子进程不分配物理空间，并共享父进程的物理空间。当父子进程之一对内存进行修改时，内核再为子进程分配物理空间。

通常，子进程接着执行一个系统调用以修改其内存映像并运行一个新的程序。

**Windows系统**

在Windows系统中，一个Win32函数调用`CreateProcess`既处理进程的创建，也负责把正确的程序装入新的进程。

Windows中，从一开始父进程的地址空间和子进程的地址空间就是不同的。

### 进程的终止
进程的终止由以下条件引起：
+ 正常退出 (自愿的)：因完成了工作而终止。通过系统调用或者供用户点击的图标来对进程进行终止。

+ 出错退出 (自愿的)：进程发现了错误后退出进程，并会反馈错误参数。

+ 严重错误 (非自愿)：进程引起的错误，比如执行了一条非法指令，引用不存在的内存等。

+ 被其他进程杀死 (非自愿)：进程通过调用`kill`或者其他指令可以通知操作系统将其他进程杀死。

### 进程的层次结构
在UNIX中，进程和它的所有子进程以及后裔共同组成一个进程组。考虑UNIX在启动时初始化自己。一个称为init的特殊进程出现在启动映像中。当它开始运行时，
为每个终端创建一个新进程。这些进程等待用户登录，一旦有用户成功登录，该登录进程就执行一个shell准备接收命令。所接收的命令会启动更多的进程。
这样，在整个系统中，所有的进程都属于以init为根的一棵树。

Windows中没有层次的概念，所有的进程都是地位相同的。

### 进程的状态
一个进程的输出结果可能作为另一个进程的输入。

考虑以下代码
```shell
cat chapter1 chapter2 chapter3 | grep tree
```
`cat`是进程1，`grep`是进程2。两个进程的相对速度不同，可能发生这种情况：grep准备就绪可以运行，但输入还没有完成。于是必须阻塞grep，直到输入的到来。

当一个进程在逻辑上不能继续运行时，它就会被阻塞。另一种情况是，一个概念上能够运行的进程被迫停止，因为操作系统调度另一个进程占用了CPU。

所以进程有三种状态：
1. 运行态 (该时刻进程实际占用CPU)

2. 就绪态 (可运行，但因为其他进程正在运行而暂时停止)

3. 阻塞态 (除非某种外部事件发生，否则进程不能运行)

进程的三种状态之间有四种可能的转换关系：
1. 运行 -> 阻塞：进程因为等待输入而被阻塞

2. 运行 -> 就绪：调度程序选择另一个进程

3. 就绪 -> 运行：调度程序选择了当前的进程

4. 阻塞 -> 就绪：出现有效输入

调度程序的主要工作就是决定应当运行哪个进程，何时运行及它应该运行多长时间。

### 进程的实现
操作系统维护着一张表格（一个结构数组），即进程表。

每个进程表占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器，栈堆指针，内存分配情况，所打开文件的状态，以及其他在阻塞发生时需要保存的信息。

一个进程在执行过程中可能被中断数千次，但关键是每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。

## 线程
在传统操作系统中，每个进程有一个地址空间和一个控制线程。

### 线程的使用
**线程的必要性：** 在许多应用中同时发生着多种活动。其中某些活动随着时间的推移会被阻塞。
通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得简单。

第二个关于需要多线程的理由是，由于线程比进程更轻量级，所以它们比进程更容易创建，也更容易撤销。
在许多系统中，创建一个线程比创建一个进程要块10-100倍。

第三个原因是因为多线程能够允许计算和I/O操作重叠进行，会加快应用程序执行的速度。

在多CPU系统中，多线程实现了真正的并行。

**多线程的例子：**
考虑一个多线程的例子。用户的文本编辑软件，如 word，一个正在运行的文本编辑软件是一个进程。当用户使用键盘和鼠标键入文本时，交互线程会监控用户的输入，并响应用户的输入。而另一个线程，格式化线程，则在后台计算由于用户键入而被修改过的文本格式，并将这个文本格式同步显示到显示屏上。而此时还可能有一个关于磁盘的线程，在固定的时间间隔内自动的在磁盘上保存用户文本。

如果程序是单线程的，那么在磁盘上保存文本时，用户的鼠标键入等操作将会被忽略。而使用三个线程就简单很多。

第一个线程和用户交互；第二个线程在得到通知时进行文档的重新格式化；第三个线程周期性地将RAM中地内容写到磁盘上。

由于线程之间共享公共内存，所以线程可以访问同一个正在编辑的文件，这是三个进程所做不到的。

构造服务器的三种方法：
+ **多线程：** 使用多线程能够实现并行性。当阻塞系统调用时，调用的线程会被挂起，但是其他线程是空闲的，可以去做其他事情。

+ **单线程进程：** 使用单线程，当组赛系统调用时，比如从磁盘中读取数据，当前线程会被挂起等待磁盘读取结果。这时CPU将会空转，影响效率。

+ **有限状态机：** 实现了并行性。因为即便只有单线程，当系统调用时，会记录当前进程的状态，并获取新的任务。当之前的任务完成后，读取状态，并继续任务。所以有限状态机并不会按照进程顺序来执行。


进程模型基于两种概念：资源分组和执行。

资源分组：进程有存放程序正文和数据以及其他资源的地址空间。这些资源包括打开的文件，子进程，即将发生的定时器，信号处理程序，账号信息等。

执行：进程拥有一个执行的线程。在线程中有程序计数器，用来记录接着要执行哪条命令。线程拥有寄存器，用来保存当前的工作变量。线程还拥有一个堆栈，用来记录执行历史。

可以理解为，进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。

在下图中，左侧是三个进程，每个进程有一个线程；右侧是一个进程中有三个线程。每一个进程拥有自己的地址空间，所以对于左侧的线程来说，每个线程都在不同的地址空间中运行。

而右侧的线程则共享进程的地址空间，三个线程全部都在相同的地址空间中运行。

![进程与线程](https://res.cloudinary.com/harlan9613/image/upload/v1591248562/Operating_System/process_thread_ogsylv.png)

对于一个进程中的所有线程，它们共享:
+ 地址空间
+ 全局变量
+ 打开文件
+ 子进程
+ 即将发生的定时器
+ 账号与信号处理程序
+ 账户信息

对于一个进程中的所有线程，它们各自拥有：
+ 程序计数器，存放下一条指令的地址
+ 寄存器，保存当前的工作变量
+ 堆栈，保存被调用却没返回的函数局部变量以及返回地址
+ 状态

如果一个线程打开了一个文件，那么对于该进程内的所有其他线程而言，该文件都是可见并且可以编辑的。因为资源管理的单位是进程而非线程。

线程试图实现的是共享一组资源的多个线程的执行能力，以便这些线程可以为完成某一任务而共同工作。

线程和进程一样，也有用：运行、阻塞、就绪或终止等状态。

正在运行的线程拥有CPU并且处于活跃状态，而被阻塞的线程正在等待某个释放它的事件。就绪线程可被调度执行，并且只要轮到它就很快可以运行。
线程之间状态的转换和进程之间状态的转换是一样的。关键就在于是否拥有CPU，以及是否因为外部事件而被阻塞。

### 线程的堆栈
每个线程都拥有自己的堆栈，是因为每个线程会调用不同的过程，从而有不同的执行历史。

线程会调用过程，每一个被调用但没有返回的过程会在线程堆栈中拥有一个栈帧，其中保存了该过程的局部变量以及过程调用完成之后的返回地址。

### 线程的生命周期
进程通常会从当前的单个线程开始。这个线程有能力通过调用一个库函数创建新的进程。新的线程会自动在创建线程的地址空间中运行。

当线程完成工作后，可以通过调用一个库过程退出。线程接着消失，不再可调度。

线程也可以通过`yield`来自动放弃CPU从而让另一个线程运行。

### POSIX线程
POSIX是一个线程标准。它定义的线程包叫作**pthread**。大部分UNIX系统都支持该标准。

一些pthread的函数调用：
+ pthread_create: 创建一个新的线程，返回其线程标识符
+ pthread_exit: 结束调用的线程并释放它的栈
+ pthread_join: 等待一个特定的线程退出，要等待的线程标识符作为一个参数给出
+ pthread_yield: 释放CPU来运行另外一个线程
+ pthread_attr_init: 创建并初始化一个线程的属性结构
+ pthread_attr_destroy: 删除一个线程的属性结构，不会影响调用它的线程，这些线程会继续存在。

### 在用户空间中实现线程
有两种主要的方法实现线程包：在用户空间中和在内核中。

![thread_in_user_or_kernel_level](https://res.cloudinary.com/harlan9613/image/upload/v1591279236/Operating_System/user_level_kernel_level_thread_tpkeo2.png)

第一种方法是把整个线程包放在**用户空间**中，内核对线程包一无所知。对内核而言，它只是在处理一个单线程的进程而已。

在这类实现中，线程在一个运行时系统(run-time system)的上层运行，该运行时系统是一个管理线程的过程的集合，类似于一个包含线程过程的函数库。

在用户空间管理线程时，每个进程维护一个**线程表**，用来跟踪该进程中的线程。该表记录了线程的程序记录器，堆栈指针，寄存器和状态等。

**在用户空间实现线程包的优点：**
1. 因为线程包实在用户空间中实现，所以线程的创建以及销毁都在用户空间内完成。内核对线程没有感知。这样用户空间的线程包可以运行在不支持线程的操作系统上。

2. 线程由进程内的一个运行时系统进行维护。当线程将要进入阻塞状态时，它会调用运行时系统的一个过程。运行时系统会将线程的状态保存在线程表中，同时查看表中可以运行的就绪线程，读取就绪线程保存的状态值。这样整个线程的切换都是由运行时系统进行管理。保存线程状态的过程和调度程序都是本地过程，不需要陷入内核，也不需要上下文切换以及对高速缓存进行刷新。所以用户级线程的调度同内核相比十分快捷。

3. 用户级线程允许每一个进程有自己定制的调度算法。可以根据需求为不同线程设计调度。相比于内核空间中内核线程需要固定表格空间和堆栈空间，用户级线程具有较好的可扩展性。

**在用户空间实现线程包的缺点：**
1. 由于对内核而言，对于进程的处理都是按照单线程进程来处理。所以当有系统调用阻塞发生时，比如I/O或者是缺页中断，内核会将整个进程阻塞。当阻塞系统调用发生时，在得到调用结果之前，线程会被挂起，函数只有在得到结果后才会返回。比如说当磁盘在寻找数据时，调用的线程会因为等待磁盘寻找结果而被挂起。

2. 由于在进程内部没有时钟中断，所以无法使用轮转调度的方式来调度线程。线程一旦拥有了CPU就会一直运行，在该进程中的其他线程就不能运行，除非第一个线程主动放弃CPU。

### 在内核中实现线程
在内核中实现线程不需要运行时系统。同时进程中也不需要维护一张保存线程状态的线程表。相反，在内核中有用来记录系统中所有线程的线程表。

当线程希望创建或者撤销一个线程时，它进行一个系统调用，这个系统调用通过对线程表的更新完成线程创建或撤销的工作。

所有能够阻塞线程的调用都以系统调用的形式实现。当一个线程阻塞时，内核可以根据其选择运行同一个进程中的另一个线程，或者是运行另一个进程中的线程。而在用户级别中，运行时系统始终运行自己进程中的线程，直到内核剥夺它的CPU。

考虑到在内存中创建和撤销线程的代价比较大，内核使用“回收”来处理线程。当一个线程被撤销时，就把它标志为不可运行的，但是其内部的数据结构没有收到影响。在必须创建一个新线程时，就重新启动某个旧的被回收的线程。而在用户级别中，因为创建和撤销的代价比较小，所以没有必要使用线程回收。

**在内核空间实现线程的优点：**
1. 内核线程不需要任何新的、非阻塞系统调用。如果某个进程中的线程引起了页面故障，内核可以很方便地检查该进程是否有任何其他可运行的线程。这样，内核不需要将整个进程全部挂起。

**在内核空间实现线程的缺点：**
1. 用户线程的运行是在用户空间，而线程的维护则是在内核空间。所以对线程的调度需要经历用户态-内核态-用户态的步骤，这样的开销比较大。

**内核空间无法解决的问题：**
1. 当一个多线程进程创建一个新的进程时，新的进程是拥有与原进程相同数量的线程，还是只有一个线程？一般的做法是取决于新进程下一步怎么做，如果新进程是调用exec来启动一个程序，那么单线程是正确的选择；如果它是继续执行，那么最好复制所有的线程。

2. 当一个信号到达进程时，应该由哪一个线程来处理它？线程可以在进程中注册其感兴趣的信号，但是如果多个线程注册了相同的感兴趣的信号呢？

### 混合实现
人们试图将用户级线程的优点和内核级线程的优点结合起来。一种方法是使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来。

这样，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。

在这种模型中，每个内核级线程有一个可以轮流使用的用户级线程集合。

### 调度程序激活机制
内核线程在一些关键点上优于用户级进程，但是内核级线程的速度慢。

**调度程序激活 (scheduler activation)** 机制能够为内核级线程在保持其优良特性的前提下改进其速度。

调度程序激活工作的目标是模拟内核线程的功能，这样在当一个线程被阻塞时，不会导致整个进程被阻塞，这个进程内的其他线程可以继续运行。同时为线程包提供通常在用户空间中才能实现的更好的性能和更强大的灵活性，减少在用户空间和内核空间之间不必要的转换。

当调度程序激活机制启动时，内核给每个进程安排一定数量的虚拟CPU，并且让进程的运行时系统将线程分配到这些虚拟CPU上。对于多核系统，这些虚拟CPU有可能是真是的CPU。

分配给一个进程的虚拟处理器的初始数量是一个，但是进程可以申请更多的处理器，并且在不用的时候退回。内核也可以取回已经分配出去的虚拟处理器。

这样，对于内核而言，进程还是单线程的。内核并不知道进程拥有多少个线程。

#### 上行调用 upcall
调度程序激活机制的一个目标是作为上行调用的信赖基础，这是一种违反分层次系统内在结构的概念。通常，n层提供n+1层可调用的特定服务，但是n层不能调用n+1层中的过程。也就是说，上层可以调用下层，但是下层不能调用上层的过程。

上行调用违背了这一种分层次的系统，允许下层调用上层的过程。而内核就是下层，用户空间就是上层。

+ 当用户空间内的进程中的一个线程发生系统调用阻塞或者缺页中断时，内核会了解到这个线程被阻塞。因为运行时系统并不运行系统调用，所以对运行时系统来说，它并不直到当前运行的线程发生了阻塞。

+ 这时内核会通过在一个已知的起始地址启动运行时系统，将被阻塞的线程编号以及发生时间的描述传递给运行时系统。而这一操作就是上行调用。

+ 运行时系统得知自己的一个线程被阻塞后，它先保存被阻塞的线程，并从就虚表中取出一个新的线程，设置其寄存器，然后启动。

+ 当原来的线程又可以运行时，内核再次上行调用通知运行时系统。这时运行时系统按照自己的判断，立即重启被阻塞的线程或者放入就虚表中稍后运行。

所以调度程序激活机制能够使线程的调度保留在用户空间由运行时系统完成，同时避免了多线程进程中单个进程出现阻塞时内核将整个进程挂起的问题。保留了内核级线程的优良特性，同时实现了速度上的优化。

#### 硬件中断
在某个用户线程运行的同时发生了一个硬件中断时：

+ 被中断的进程对引起该中断的事件不感兴趣，比如时另一个进程的I/O完成，那么在中断处理程序结束之后，就把被中断的线程恢复到中断之前的状态。

+ 如果被中断的进程对引起中断的事件感兴趣，比如某个线程请求的页面到达了，那么被中断的线程就不再启动，而是被挂起的线程重新启动，获取中断时保存的状态。之后运行时系统决定该调度哪一个线程。

### 弹出式线程
在处理消息时，传统的方法使将进程或线程阻塞在一个接收的系统调用上，等待消息到来。当消息到达时，该系统调用接收消息，并打开消息检查其内容。

这样的作法会阻塞掉之后的消息到来，因为只有当当前消息处理完成后，才会去接收下一个消息。

而**弹出式线程**的做法是，当一个消息到来时，系统会创建一个新的线程用来处理这个消息。因为这是一个新的线程，所以创建起来的消耗会很小。这样消息到达与处理开始之间的时间非常短。

使用弹出式线程需要确定这个线程运行在哪里。如果放在内核空间，弹出式线程可以很容易地访问所有的表格和I/O设备。但是如果弹出式线程在内核出错，可能会造成比在用户空间更大的危害。

### 使单线程代码多线程化
许多已有的程序是为单线程进程编写的。将这些代码修改为支持多线程会产生一些问题：

**1. 多线程共享变量**
当多个线程共享全局变量时，线程1在更改变量后可能因为时钟中断而放弃CPU，这时获得CPU的线程2调用了相同的过程，从而改变了共享的变量。那么在线程1重新获得CPU时，其得到的变量就不是之前获得的变量。

这个问题的解决方法是为每个线程赋予其私有的全局变量。或者引入新的库过程，为每一个线程创建一块专属的地址空间用于存放其私有的全局变量。

**2. 过程重复进入**
有的库过程是无法在当前调用还未结束的时候再次调用的。在多线程中就会遇到这样的问题，一个线程可能在调用完一个过程之前就交出了CPU，此时另一个线程也要去调用这个相同的过程。

这种问题的解决方法是提供一个二进制的标志位。当该过程在被使用时，使用设置其标志位使得这个过程无法被其他线程所调用。但是这样会降低系统潜在的并行性。

**3. 信号**
比如对于键盘的捕捉，是应该指定一个线程还是所有的线程来执行，又或是创建一个新的弹出式线程？如果某个线程像捕捉一个特定的信号，而另一个线程却想用这个信号终止进程，又会发生什么情况？

信号的处理对于单线程环境中已经是很复杂的了，到了多线程环境中更加难以处理。

**4. 堆栈管理**
在很多系统中，当一个进程的堆栈溢出时，内核只是自动为该进程提供更多的堆栈。当一个进程有多个线程时，就必须有多个堆栈。如果内核不了解所有的堆栈，就不能使它们自动增长，直到造成堆栈出错。

## 进程间通信
进程之间需要通信，并且最好能使用一种结构良好的方式而不要使用中断。

**进程间通信 (Inter Process Communication, IPC)** 有三大问题：

1. 进程如何把信息传递给另一个进程

2. 两个或更多的进程在关键活动中不会出现交叉，比如两个进程想要修改同一块数据

3. 进程之间正确的顺序

这三个问题对于线程来说同样适用。相同进程间的线程不存在消息传递问题，因为它们共享一个地址空间。但剩余的两个问题同样适用于线程。

### 竞争条件
在一些操作系统中，协作的进程可能共享一些彼此都能读写的公共存储区。




