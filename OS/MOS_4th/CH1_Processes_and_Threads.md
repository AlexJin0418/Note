# 进程与线程

## 进程

进程是对正在运行的程序的一个抽象。

**伪并行：** 在任何多道程序设计系统中，CPU由一个进程快速切换至另一个进程 (context switch)，使每个进程各运行几十或几百毫秒。严格地说，在某一瞬间，CPU只能运行**一个进程**。
但在一秒内，它可能运行多个进程，这样就产生并行的错觉。

### 进程模型
一个进程就是一个正在执行程序的实例，包括程序计数器，寄存器和变量的当前值。从概念上说，每个进程拥有它自己的虚拟CPU。

进程和程序的区别是很微妙的。进程拥有状态，即当前完成度，但是程序没有。一个进程是某种类型的一个活动，它有程序，输入，输出以及状态。
所以可以说进程是一个正在运行的程序。

### 进程的创建
4种主要事件会导致进程的创建：
+ 系统初始化：启动操作系统时，通常会创建若干个进程。其中有些是前台程序与用户进行交互，有些是后台程序具有专门的功能，这些程序被称为**守护程序(deamon)**。

+ 正在运行的程序执行了创建进程的系统调用：一个正在运行的进程可以发出系统调用以便创建一个或多个新进程协助工作。

+ 用户请求创建一个新的进程：用户可以在交互式系统中通过键入命令或者双击图标启动一个程序，并创建一个新的进程。

+ 一个批处理作业的初始化：大型批处理系统中，如果操作系统认为有资源可以运行另一个作业时，它创建一个新的进程。

在所有的情形中，新进程都是由**一个已存在的进程**执行了一个用于**创建进程的系统调用**而创建的。这个进程可以是一个运行的用户程序，一个由键盘或鼠标启动的系统进程或者一个批处理管理程序。

**UNIX系统**

在UNIX系统中，使用`fork`创建新进程。这个系统调用会创建一个与调用进程相同的副本。
在调用`fork`后，父进程和子进程拥有相同的内存映像，同样的环境字符串和同样的打开文件。

子进程在创建时内存通过**写时复制(copy-on-write)** 与父进程共享。子进程不分配物理空间，并共享父进程的物理空间。当父子进程之一对内存进行修改时，内核再为子进程分配物理空间。

通常，子进程接着执行一个系统调用以修改其内存映像并运行一个新的程序。

**Windows系统**

在Windows系统中，一个Win32函数调用`CreateProcess`既处理进程的创建，也负责把正确的程序装入新的进程。

Windows中，从一开始父进程的地址空间和子进程的地址空间就是不同的。

### 进程的终止
进程的终止由以下条件引起：
+ 正常退出 (自愿的)：因完成了工作而终止。通过系统调用或者供用户点击的图标来对进程进行终止。

+ 出错退出 (自愿的)：进程发现了错误后退出进程，并会反馈错误参数。

+ 严重错误 (非自愿)：进程引起的错误，比如执行了一条非法指令，引用不存在的内存等。

+ 被其他进程杀死 (非自愿)：进程通过调用`kill`或者其他指令可以通知操作系统将其他进程杀死。

### 进程的层次结构
在UNIX中，进程和它的所有子进程以及后裔共同组成一个进程组。考虑UNIX在启动时初始化自己。一个称为init的特殊进程出现在启动映像中。当它开始运行时，
为每个终端创建一个新进程。这些进程等待用户登录，一旦有用户成功登录，该登录进程就执行一个shell准备接收命令。所接收的命令会启动更多的进程。
这样，在整个系统中，所有的进程都属于以init为根的一棵树。

Windows中没有层次的概念，所有的进程都是地位相同的。

### 进程的状态
一个进程的输出结果可能作为另一个进程的输入。

考虑以下代码
```shell
cat chapter1 chapter2 chapter3 | grep tree
```
`cat`是进程1，`grep`是进程2。两个进程的相对速度不同，可能发生这种情况：grep准备就绪可以运行，但输入还没有完成。于是必须阻塞grep，直到输入的到来。

当一个进程在逻辑上不能继续运行时，它就会被阻塞。另一种情况是，一个概念上能够运行的进程被迫停止，因为操作系统调度另一个进程占用了CPU。

所以进程有三种状态：
1. 运行态 (该时刻进程实际占用CPU)

2. 就绪态 (可运行，但因为其他进程正在运行而暂时停止)

3. 阻塞态 (除非某种外部事件发生，否则进程不能运行)

进程的三种状态之间有四种可能的转换关系：
1. 运行 -> 阻塞：进程因为等待输入而被阻塞

2. 运行 -> 就绪：调度程序选择另一个进程

3. 就绪 -> 运行：调度程序选择了当前的进程

4. 阻塞 -> 就绪：出现有效输入

调度程序的主要工作就是决定应当运行哪个进程，何时运行及它应该运行多长时间。

### 进程的实现
操作系统维护着一张表格（一个结构数组），即进程表。

每个进程表占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器，栈堆指针，内存分配情况，所打开文件的状态，以及其他在阻塞发生时需要保存的信息。

一个进程在执行过程中可能被中断数千次，但关键是每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。

## 线程
在传统操作系统中，每个进程有一个地址空间和一个控制线程。

### 线程的使用
**线程的必要性：** 在许多应用中同时发生着多种活动。其中某些活动随着时间的推移会被阻塞。
通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得简单。

第二个关于需要多线程的理由是，由于线程比进程更轻量级，所以它们比进程更容易创建，也更容易撤销。
在许多系统中，创建一个线程比创建一个进程要块10-100倍。

第三个原因是因为多线程能够允许计算和I/O操作重叠进行，会加快应用程序执行的速度。

在多CPU系统中，多线程实现了真正的并行。

**多线程的例子：**
考虑一个多线程的例子。用户的文本编辑软件，如 word，一个正在运行的文本编辑软件是一个进程。当用户使用键盘和鼠标键入文本时，交互线程会监控用户的输入，并响应用户的输入。而另一个线程，格式化线程，则在后台计算由于用户键入而被修改过的文本格式，并将这个文本格式同步显示到显示屏上。而此时还可能有一个关于磁盘的线程，在固定的时间间隔内自动的在磁盘上保存用户文本。

如果程序是单线程的，那么在磁盘上保存文本时，用户的鼠标键入等操作将会被忽略。而使用三个线程就简单很多。

第一个线程和用户交互；第二个线程在得到通知时进行文档的重新格式化；第三个线程周期性地将RAM中地内容写到磁盘上。

由于线程之间共享公共内存，所以线程可以访问同一个正在编辑的文件，这是三个进程所做不到的。

构造服务器的三种方法：
+ **多线程：** 使用多线程能够实现并行性。当阻塞系统调用时，调用的线程会被挂起，但是其他线程是空闲的，可以去做其他事情。

+ **单线程进程：** 使用单线程，当组赛系统调用时，比如从磁盘中读取数据，当前线程会被挂起等待磁盘读取结果。这时CPU将会空转，影响效率。

+ **有限状态机：** 实现了并行性。因为即便只有单线程，当系统调用时，会记录当前进程的状态，并获取新的任务。当之前的任务完成后，读取状态，并继续任务。所以有限状态机并不会按照进程顺序来执行。


进程模型基于两种概念：资源分组和执行。

资源分组：进程有存放程序正文和数据以及其他资源的地址空间。这些资源包括打开的文件，子进程，即将发生的定时器，信号处理程序，账号信息等。

执行：进程拥有一个执行的线程。在线程中有程序计数器，用来记录接着要执行哪条命令。线程拥有寄存器，用来保存当前的工作变量。线程还拥有一个堆栈，用来记录执行历史。

可以理解为，进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。

在下图中，左侧是三个进程，每个进程有一个线程；右侧是一个进程中有三个线程。每一个进程拥有自己的地址空间，所以对于左侧的线程来说，每个线程都在不同的地址空间中运行。

而右侧的线程则共享进程的地址空间，三个线程全部都在相同的地址空间中运行。

![进程与线程](https://res.cloudinary.com/harlan9613/image/upload/v1591248562/Operating_System/process_thread_ogsylv.png)

对于一个进程中的所有线程，它们共享:
+ 地址空间
+ 全局变量
+ 打开文件
+ 子进程
+ 即将发生的定时器
+ 账号与信号处理程序
+ 账户信息

对于一个进程中的所有线程，它们各自拥有：
+ 程序计数器，存放下一条指令的地址
+ 寄存器，保存当前的工作变量
+ 堆栈，保存被调用却没返回的函数局部变量以及返回地址
+ 状态

如果一个线程打开了一个文件，那么对于该进程内的所有其他线程而言，该文件都是可见并且可以编辑的。因为资源管理的单位是进程而非线程。

线程试图实现的是共享一组资源的多个线程的执行能力，以便这些线程可以为完成某一任务而共同工作。

线程和进程一样，也有用：运行、阻塞、就绪或终止等状态。

正在运行的线程拥有CPU并且处于活跃状态，而被阻塞的线程正在等待某个释放它的事件。就绪线程可被调度执行，并且只要轮到它就很快可以运行。
线程之间状态的转换和进程之间状态的转换是一样的。关键就在于是否拥有CPU，以及是否因为外部事件而被阻塞。

### 线程的堆栈
每个线程都拥有自己的堆栈，是因为每个线程会调用不同的过程，从而有不同的执行历史。

线程会调用过程，每一个被调用但没有返回的过程会在线程堆栈中拥有一个栈帧，其中保存了该过程的局部变量以及过程调用完成之后的返回地址。

### 线程的生命周期
进程通常会从当前的单个线程开始。这个线程有能力通过调用一个库函数创建新的进程。新的线程会自动在创建线程的地址空间中运行。

当线程完成工作后，可以通过调用一个库过程退出。线程接着消失，不再可调度。

线程也可以通过`yield`来自动放弃CPU从而让另一个线程运行。

### POSIX线程
POSIX是一个线程标准。它定义的线程包叫作**pthread**。大部分UNIX系统都支持该标准。

一些pthread的函数调用：
+ pthread_create: 创建一个新的线程，返回其线程标识符
+ pthread_exit: 结束调用的线程并释放它的栈
+ pthread_join: 等待一个特定的线程退出，要等待的线程标识符作为一个参数给出
+ pthread_yield: 释放CPU来运行另外一个线程
+ pthread_attr_init: 创建并初始化一个线程的属性结构
+ pthread_attr_destroy: 删除一个线程的属性结构，不会影响调用它的线程，这些线程会继续存在。

### 在用户空间中实现线程
有两种主要的方法实现线程包：在用户空间中和在内核中。

![thread_in_user_or_kernel_level](https://res.cloudinary.com/harlan9613/image/upload/v1591279236/Operating_System/user_level_kernel_level_thread_tpkeo2.png)

第一种方法是把整个线程包放在**用户空间**中，内核对线程包一无所知。对内核而言，它只是在处理一个单线程的进程而已。

在这类实现中，线程在一个运行时系统(run-time system)的上层运行，该运行时系统是一个管理线程的过程的集合，类似于一个包含线程过程的函数库。

在用户空间管理线程时，每个进程维护一个**线程表**，用来跟踪该进程中的线程。该表记录了线程的程序记录器，堆栈指针，寄存器和状态等。

**在用户空间实现线程包的优点：**
1. 因为线程包实在用户空间中实现，所以线程的创建以及销毁都在用户空间内完成。内核对线程没有感知。这样用户空间的线程包可以运行在不支持线程的操作系统上。

2. 线程由进程内的一个运行时系统进行维护。当线程将要进入阻塞状态时，它会调用运行时系统的一个过程。运行时系统会将线程的状态保存在线程表中，同时查看表中可以运行的就绪线程，读取就绪线程保存的状态值。这样整个线程的切换都是由运行时系统进行管理。保存线程状态的过程和调度程序都是本地过程，不需要陷入内核，也不需要上下文切换以及对高速缓存进行刷新。所以用户级线程的调度同内核相比十分快捷。

3. 用户级线程允许每一个进程有自己定制的调度算法。可以根据需求为不同线程设计调度。相比于内核空间中内核线程需要固定表格空间和堆栈空间，用户级线程具有较好的可扩展性。

**在用户空间实现线程包的缺点：**
1. 由于对内核而言，对于进程的处理都是按照单线程进程来处理。所以当有系统调用阻塞发生时，比如I/O或者是缺页中断，内核会将整个进程阻塞。当阻塞系统调用发生时，在得到调用结果之前，线程会被挂起，函数只有在得到结果后才会返回。比如说当磁盘在寻找数据时，调用的线程会因为等待磁盘寻找结果而被挂起。

2. 由于在进程内部没有时钟中断，所以无法使用轮转调度的方式来调度线程。线程一旦拥有了CPU就会一直运行，在该进程中的其他线程就不能运行，除非第一个线程主动放弃CPU。


