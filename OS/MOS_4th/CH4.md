# 第4章 文件系统
所有的计算机应用程序都需要存储和检索信息。长期存储信息有三个基本要求
1. 能够存储大量信息
2. 使用信息的进程终止时，信息仍旧存在
3. 必须能使多个进程并发访问有关信息

**文件**是进程创建的信息逻辑单元。一个磁盘一般含有几千甚至几百万个文件，每个文件是独立于其他文件的，唯一不同的是**文件是对磁盘的建模**。

文件是受操作系统管理的。操作系统中处理文件的部分称为**文件系统(File System)**

## 4.1 文件
### 4.1.1 文件命名
文件是一种**抽象机制**，它提供了一种在磁盘上保存信息而且方便以后读取的方法。

文件由文件名和扩展名组成。

在UNIX系统中，文件扩展名只是一种约定，操作系统并不强迫采用它。

而Windows关注扩展名且对其赋予了含义。用户或进程可以在操作系统中注册扩展名，并且规定哪个程序“拥有”该扩展名。

### 4.1.2 文件结构
文件可以有多种构造方式。

文件可以是一种**无结构的字节序列**，操作系统所见到的就是字节，其文件内容的任何含义只在用户程序中解释。把文件看作字节序列提供了最大的灵活性。用户程序可以向文件中加入任何内容，并以任何方便的形式命名。UNIX系统和Windows系统都采用这种文件模型。

第二种文件结构具有**固定长度记录的序列**，每个记录都有其内部结构。读操作返回一个序列，而写操作重写或追加一个记录。这一文件模型广泛用于使用穿孔卡片记录数据的年代。

第三种文件结构是有一颗**记录树**构成，每个记录不必具有相同的长度，记录的固定位置上有一个键字段。这棵树按“键”字段进行排序，从而可以对特定“键”进行快速查找。这类文件结构在用于处理商业数据的大型计算机中获得广泛使用。

### 4.1.3 文件类型
操作系统支持多种文件类型。普通文件分为**ASCII文件**和**二进制文件**。

**ASCII文件**由多行正文组成。ASCII文件可以显示和打印，还可以用任何文本编辑器进行编辑。ASCII文件也可以用作另一个程序的输入。

**二进制文件**打印出来是无法理解的，且充满混乱字符的一张表。二进制文件有一定的内部结构，使用该文件的程序才了解这种结构。

### 4.1.4 文件访问
**顺序访问(sequential access)：** 进程在系统中从头按顺序读取文件的全部字节或记录，但不能跳过某一内容。顺序访问文件是可以返回到起点的。

**随机访问(random access)：** 不按顺序地读取文件中的字节或记录，或按照关键字而不是位置来访问记录。而这种能够以任何次序读取其中字节或记录的文件称作随机访问文件。

### 4.1.5 文件属性
文件有文件名，数据，以及包含文件创建日期，时间，文件大小，所有者等附加信息的属性。
![file_attributes](https://res.cloudinary.com/harlan9613/image/upload/v1586961050/IMG/4.4_rwfphz.png)

### 4.1.6 文件操作
使用文件的目的是存储信息并方便以后的检索。对于存储和检索，不同系统提供了不同的操作。
***

## 4.2 目录
文件系统提供**目录**或**文件夹**用于记录文件的位置。
### 4.2.1 一级目录系统
一级目录系统是在一个根目录中包含所有的文件。这一设计的优点在于简单，并且能够快速定位文件。

### 4.2.2 层次目录系统
层次目录系统将文件以自然的方式分组。用户可以创建任意数量的子目录，这为用户组织其工作提供了强大的结构化工具。因此，几乎所有的现代文件系统都是用这个方式组织的。

### 4.2.3 路径名
**绝对路径名(absolute path name)：** 从根目录到文件的路径组成。
**相对路径名(relative path name)：** 指当前工作目录。用户可以指定一个目录为当前工作目录。

### 4.2.4 目录操作
UNIX提供了一些系统调用来实现目录操作，如create, delete, opendir, closedir...

link：链接。这个系统调用指定一个存在的文件和一个路径名，并建立从该文件到路径所指名字的链接。这样，可以在多个目录中出现同一文件。这种被称为**硬链接(hard link)**

关于链接文件的一种不同想法是**符号链接**。不同于使用两个文件名指向同一个内部数据结构来表示一个文件，符号链接中，一个文件名指向命名另一个文件的一个小文件。当使用这个小文件时，文件系统沿着路径最终找到文件名，再用心名字启动查找文件的过程。

符号链接的有点在于能够跨越磁盘的界限，甚至可以命名在远程计算机上的文件，不过符号链接的实现并不如硬链接那样有效率。
***

## 4.3 文件系统的实现
### 4.3.1 文件系统布局
文件系统存放在磁盘上。多数磁盘划分为**一个或多个分区**，每个分区中有一个独立的文件系统。

磁盘的0号扇区称为**主引导系统(Master Boot Record, MBR)**，用来引导计算机。在MBR的结尾是分区表。该表给出了每个分区的起始和结束地址。表中的一个分区被标记为**活动分区**。

当计算机被引导时，BIOS读入并执行MBR，并确定**活动分区**，读入它的第一个块，称为**引导块(boot block)**，并执行引导块。引导块中的程序将装载该分区中的操作系统。

每个分区都从一个引导块开始，即使它不含有一个可启动的操作系统。

![文件系统](https://res.cloudinary.com/harlan9613/image/upload/v1587094826/IMG/4-9_rens3u.png)

### 4.3.2 文件的实现
文件存储实现的关键问题是记录各个文件分别用到哪些磁盘块。

#### 1. 连续分配
最简单的分配方案是把每个文件作为一串连续数据块存储在磁盘上。

每个文件都从一个新的块开始，这样如果文件A占用了三又二分之一块，那么最后一块结尾会浪费一些空间。

连续磁盘空间分配方案实现简单，记录每个文件用到的磁盘空间简化为只需要记住**第一块的磁盘地址**和**文件的块数**。同时读取操作的性能较好，因为在单个操作中就可以从磁盘上读出整个文件，只需要对**第一个块**进行查找。

但是连续分配会造成**随着时间的推移，磁盘会变得零碎**。当文件被删除后，它占用的块自然就释放了，在磁盘上留下一堆空闲块。磁盘不会在这个位置挤压掉这个空洞，因为这样会涉及复制空洞之后的所有文件，可能会有上百块。

当磁盘被充满后，要么**压缩磁盘**要么**重新使用空洞所在的空闲空间**。前者由于代价太高而不可行；后者需要维护一个空洞列表。当创建一个新文件时，为了挑选合适大小的空洞文件，就有必要知道该文件的大小。

但对于文字编辑器来说，提前知道用户输入文件的大小是不可行的。但是，**CD-ROM等一次性写光学介质**可以使用连续分配方案，因为所有的文件大小都是预先知道的。而在后续的使用当中，文件的大小也不会被改变。

#### 2. 链表分配
存储文件的第二种方法是**为每个文件构造磁盘块链表**。每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。

在目录项中，只需要存放第一块的磁盘地址，文件的其他块就可以从这个首块地址查找到。

尽管顺序读取十分方便，但是随机访问却十分缓慢。如果要读取块n，就需要从头读取到块n-1才能获得目标块。

由于指针占去了一些字节，每个磁盘块存储数据的字节数不再是2的整数次幂。所以要读取完整的一块大小的信息，就需要从两个磁盘块中获得和拼接信息，这就因复制引发了额外的开销。

#### 3. 采用内存中的表进行链表分配
如果取出每个磁盘块的指针字，把它们放在内存的一个表中，就可以解决上述链表的两个不足。

内存中存放每个磁盘块指针字的表格称为**文件分配表(File Allocation Table, FAT)**。

按照这种方式组织，每个磁盘块都可以存放数据。而且，在随机访问中，虽然还是需要从头定位寻找的块，但是因为分配表在内存中，因此寻块的速度要比在磁盘上更快。不管文件有多大，在项目中只需记录一个起始块号就可以获得文件的全部块。

这种方法的主要缺点是需要把整个表放在内存中。对于1TB的磁盘和1KB大小的块，那么这个表需要10亿项，按照每一项3个字节，那么这张表需要占用3GB或2.4GB内存。FAT的管理方式不能较好地扩展并应用于大型磁盘中。

#### 4. i节点
最后一个记录各个文件分别包含哪些磁盘块的方法是给每个文件赋予一个称为**i节点(index-node)**的数据结构，其中列出了文件属性和文件块的磁盘地址。给定i节点，就能找到文件的所有块。

在内存中，只有当对应的文件被打开时，其i节点才会在内存中。

i节点的一个问题是，如果每个i节点只能存储固定数量的磁盘地址，那么当一个文件所含的磁盘块的数目超过了i节点所能容纳的数目怎么办？一个解决方案是最后一个“磁盘地址”不指向数据块，而是指向**一个包含额外磁盘块地址的块的地址**。

### 4.3.3 目录的实现
在读取文件前，必须先打开文件。打开文件时，操作系统利用用户给出的路径名找到相应的目录项。目录系统的主要功能是把ASCII文件名映射成定位文件数据所需的信息。

每个文件系统需要维护诸如文件所有者以及创建时间等文件属性。一种存储方法是把文件属性直接存放在目录项中。目录中有一个 固定大小的目录项列表，每个文件对应一项，其中包含一个文件名，一个文件属性的结构体以及用于说明磁盘块位置的一个或多个磁盘地址。

对于采用i节点的系统，还存在一种方法，即把文件属性存放在i节点中而不是目录项中。这样目录项中只有文件名和i节点号。

几乎所有的现代操作系统都支持**可变长度的长文件名**。最简单的方法是给予文件名一个长度限制，典型值为225个字符。并在文件属性中预留225个字符的空间。这种方法浪费了大量的目录空间，因为只有很少的名字能用到这么长的长度。

一种方法是每个目录项有一个固定部分，这个固定部分通常以目录项的长度开始，后面是固定格式的数据，包括所有者，创建时间，保护信息等属性。这个固定长的头的后面是一个任意长度的实际文件名。每个文件名以一个特殊字符结束。为了使每个目录项从字的边界开始，每个文件名被填充成整个数字。

![file_name](https://res.cloudinary.com/harlan9613/image/upload/v1587103821/IMG/4-15_dou6ez.png)

这个方法的缺点是，当移走文件后，就引入了一个长度可变的空隙，而下一个进来的文件不一定正好适合这个空隙。另一个问题是，一个目录项可能会分布在多个页面上，在读取文件名时可能发生缺页中断。

另一种方法是，**使目录项自身都有固定长度，而将文件名放置在目录后面的堆中**。当一个文件目录项被移走后，另一个文件的目录项总是可以适合这个空隙。当然必须要对堆进行管理。

加快查找文件的一个方法是**在每个目录中使用散列表**。散列表通过散列值排列不同的文件，具有相同散列值的文件以链表来链接。使用散列表的优点使查找非常迅速。其缺点是需要复杂的管理。

另一种方法是将文件查找的结果存入**高速缓存**。在查找文件之前，现在高速缓存中查找文件是否在缓存中。如果是，该文件可以立即定位。

### 4.3.4 共享文件
当几个用户同在一个项目里工作时，他们常常需要共享文件。共享文件出现在另一个不同的文件夹下，这之间的联系称之为**链接(link)**。

如果共享文件的目录中包含磁盘地址，则当链接文件时，必须把目录中的磁盘地址复制到共享的目录中。如果文件被改变，那其他用户对于文件的改变是不知道的。

一种解决办法是共享的磁盘块不列入目录，而是列入一个**与文件本身关联的小型数据结构中**。

另一种方法是建立一个类型为**LINK**的新文件，并把该文件放在共享的目录下，使得与当前目录下的一个文件存在链接。当读取共享文件时，通过访问LINK类型文件，找到该文件所链接的文件的名字，并且去读那个文件。这一方法称为**符号链接(symbolic linking)**。

如果时用小型数据结构来控制共享文件，那么在删除文件拥有者后，相应的i节点也会被删除。而共享目录还会指向该i节点，那么当i节点在以后被分配给另一个文件后，共享目录会指向一个错误的文件。

而使用符号链接不会出现这样的问题。因为只有真的文件所有者才有一个指向i节点的指针。但是符号链接需要读取包含路径的文件。读取文件路径会产生多次额外的磁盘访问。

### 4.3.5 日志结构文件系统
**日志结构文件系统(Log-strucutred File System, LFS)** 的目的是为了缓解磁盘寻道时间影响文件系统性能的问题。其基本思想是将整个磁盘结构化为一个日志。

所有的写操作最初都被缓冲在内存中，然后周期性地把所有已缓冲的写作为一个单独的段，在日志的末尾处写入磁盘。

### 4.3.6 日志文件系统
保存一个用于记录系统下一步将要做什么的日志。这样当系统在完成它们即将完成的任务崩溃时。重新启动后，可以通过查看日志，获取崩溃前计划完成的任务，并完成它们。这样的文件系统被称为**日志文件系统**。

日志文件系统先写一个日志项，列出三个将要完成的动作。只有当日志项已经被写入，不同的操作才可以进行。

为了增加可靠性，一个文件系统可以引入数据库中**原子事务(atomic transaction)** 的概念。使用这个概念，一组动作可以被界定在开始事务和结束事务操作之间。

### 4.3.7 虚拟文件系统
虚拟文件系统将多种文件系统整合到一个统一的结构中。绝大多数UNIX操作系统都使用**虚拟文件系统(Virtual File System, VFS)**。

关键思想是抽象出所有文件系统都共有的部分，并且将这部分代码放在单独的一层，该层调用底层的实际文件系统来具体管理数据。

![VFS](https://res.cloudinary.com/harlan9613/image/upload/v1587105643/IMG/4-18_kn66fl.png)

VFS有一个对于实际文件系统的“下层”结构，就是**VFS interface**。接口提供了上层给用户进程的接口和下层给实际文件系统的接口。

当系统启动时，根文件系统在VFS中注册。另外，在装载其他文件系统时，不管在启动时还是在操作过程中，它们也必须在VFS中注册。当一个文件系统注册时，它做的最基本的工作就是提供一个包含VFS所需要的函数地址的列表。因此，只要是一个文件系统在VFS注册，VFS就知道如何从它那里读一个块。
***

## 4.4 文件系统管理和优化
### 4.4.4 文件系统性能
访问磁盘比访问内存慢得多。所以许多文件系统采用了各种优化措施以改善性能。

#### 1. 高速缓存
最常用的减少磁盘访问次数技术是**块高速缓存(block cache)**或者**缓冲区高速缓存(buffer cache)**。

高速缓存逻辑上属于磁盘，但实际上基于性能的考虑被**保存在内存内**。

高速缓存的常用算法是：读取全部的读请求，查看在高速缓存中是否有所需要的块。如果存在，可执行读操作而无须访问磁盘。如果该块不在高速缓存中，首先要把它读到高速缓存，再复制到所需的地方。

![高速缓存](https://res.cloudinary.com/harlan9613/image/upload/v1586920819/IMG/4.28_gtrkks.png)

高速缓存常用的方法是将设备和磁盘地址进行散列操作(**4-28**)，在散列表中查找结果。具有相同散列值的块在一个散列表中连接在一起。使用LRU算法进行维护。

对于高速缓存的LRU算法需要考虑两点：
1. 这一块是否不久后会再次使用？
2. 之一块是否与文件系统一致性有本质的联系？

第一个问题。可以将块根据功能分为不同的块，比如i节点，间接块，目录块，满数据块，部分数据块等。把有可能最近不再需要的块放在LRU链表前部，于是它们所占用的缓冲区可以很快被重用。对很快就可能再次使用的块，比如正在写入的部分满数据块，可放在链表的尾部，这样能在高速缓存中保存较长的一段时间。

第二个问题。关系到文件系统的一致性。我们不希望发生系统崩溃时，正在编辑的文件丢失掉。Unix系统的处理方式基于其磁盘都是**硬盘**的环境，调用`sync`强制性地把全部修改过地块立即写回磁盘。这个系统调用会在一定地时间内循环执行。而windows的处理方式基于其早期磁盘都是**软盘**的环境。只要高速缓存中写入了块，那么所有被修改过的块都会被写入磁盘中。

#### 2. 块提前读
块提前读是指在需要用到块之前，试图提前将其写入高速缓存，从而提高命中率。如果请求文件系统在某个文件中生成块k，那么文件系统会为块k+1安排一个预读，因为文件系统希望在需要用到该块时，它已经在高速缓存或者马上就要在高速缓存中。

块提前读的策略适用于**实际顺序读取**的文件。对**随机读取**的文件，块提前读会读取无用的块以及从高速缓存中删除有用的块并占用磁盘带宽。

对于文件的访问方式，可以使用与文件相关联的某个位协助跟踪该文件到底是“顺序访问方式”还是“随机访问方式”。如果不能确定，那么可以首先预设文件为顺序访问方式。如果查找结果为随机访问，那么修改该位即可。这样，文件系统可以通过合理猜测来确定是否应该采用块提前读的策略。

#### 3. 减少磁盘臂运动
另一种技术是把有可能顺序访问的块放在一起，最好是在同一柱面上，从而**减少磁盘臂的移动次数**。

在使用i节点或者任何类似i节点的系统中，另一个性能瓶颈是，读取一个很短的文件也需要两次磁盘访问：一次是访问i节点，另一次是访问块。改进方法是，在磁盘中部而不是开始存放处存放i节点。或者将磁盘分成多个柱面组，每个柱面组有自己的i节点，数据块和空闲表。这样可以减少磁盘臂的移动次数。

### 4.4.5 磁盘碎片整理
随着时间流逝，文件被不断地创建与删除，于是磁盘会产生很多碎片，文件与空穴到处都是。结果是，当创建一个新文件时，它使用地块会散布在整个磁盘上，造成性能地降低。

磁盘性能可以通过如下方式恢复：移动文件使它们相邻，并把所有的空闲空间放在一个或者多个大的连续的区域内。

磁盘碎片整理程序会在一个在分区末端的连续区域内有大量空闲空间的文件系统上很好地运行。这段空间会允许磁盘碎片整理程序在分区开始端的文件碎片，并复制它们所有的块放到空闲空间内。这个动作在磁盘开始处释放出一个连续的块空间。

固态硬盘不受磁盘碎片的影响。
***

## 4.7 小结
从外部看，文件系统是一组文件和目录，以及对文件和目录的操作。大多数现代操作系统都支持层次目录系统。

文件系统的设计者必须要考虑存储区是如何分配的，系统如何记录哪个块分给了哪个文件。可能的方法有连续文件，链表，文件分配表和i节点等。

文件系统的性能十分重要，可以通过多种途径来提高性能，包括高速缓存，预读取以及可能仔细地将一个文件中地块紧密地放置在一起等方法。

日志结构文件系统通过大块单元写入的操作也可能改善性能。
***

## 习题




