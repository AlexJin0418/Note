### 第2章 变量和基本类型

#### 2.1 基本内置类型
##### 2.1.1 算术类型
|类型| 含义 | 最小尺寸|
|---|---|---|
|bool|布尔型|未定义|
|char|字符|8位|
|wchar_t|宽字符|16位|
|char16_t|Unicode字符|16位|
|char32_t|Unicode字符|32位|
|short|短整型|16位|
|int|整型|16位|
|long|长整型|32位|
|long long|长整型|64位|
|float|单精度浮点数|6位有效数字|
|double|双精度浮点数|10位有效数字|
|long double|扩展精度浮点数|10位有效数字|

**带符号和无符号类型**
除去布尔型和扩展的字符型外，其他整型可分为**带符号的(signed)**和**不带符号的(unsigned)**。带符号可以表示正数，负数和0，无符号类型则只能表示大于等于0的值。

##### 2.1.2 类型转换
+ 把非布尔类型赋值给布尔类型：0为false，其他为true
+ 把布尔类型赋值给非布尔类型：false为0，true为1
+ 把浮点类型赋值给整数类型：近似处理，只保留浮点中小数点前的部分
+ 把整数值赋值给浮点类型：小数部分记0
+ 给无符号类型赋值超出表示范围时，结果是初始值对无符号类型表示数值总数取模后的余数
+ 给带符号类型赋值超过表示范围时，结果是**为定义(undefined)**

##### 2.1.3 字面值常量
一个形如42的值被称作**字面值常量(literal)**。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

整型字面值可以写作十进制，八进制和十六进制。默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。

**字符和字符串字面值**实际上由常量字符构成的**数组**。编译器在每个字符串的结尾处添加一个空字符('\0')。

**转义序列**包含两类字符：**不可打印**的字符和**特殊含义**的字符

**布尔字面值**：true / false

**指针字面值**：nullptr
***
#### 2.2 变量
##### 2.2.1 变量定义
当对象在创建时获得了一个特定的值，我们说这个对象被**初始化了(initialized)**。
在C++语言中，初始化和赋值时两个完全不同的操作：
+ 初始化的含义时创建变量时赋予其一个初始值
+ 赋值的含义是把对象的当前值擦除，而以一个新的值来替代

> **c++11的新标准：列表初始化(list initialization)**。可以使用花括号为对象赋初始值
```C++
int x = 0;
int x = {0}; // 列表初始化
int x {0}; // 列表初始化
int x (0);
```
如果我们使用列表初始化且初始值**存在丢失信息**的风险，则编译器将报错。
```C++
long double id = 3.1415926;
int c {id}, b = {id}; // 错误：因为long double类型转换成int存在丢失信息的危险
```

##### 2.2.2 变量声明和定义的关系
C++ 语言支持**分离式编译(separate compilation)**机制，该机制允许将程序分割为若干个文件，每个文件可以被独立编译。
为了支持分离式编译，C++语言将声明和定义区分开来。
+ **声明(declaration)** 使名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明
+ **定义(definition)** 负责创建与名字关联的实体，申请存储空间，也可能为变量赋一个初始值

如果想声明一个变量而非定于它，就在变量名前添加关键字**extern**，而且不要显示地初始化变量。
```C++
extern int i; // 声明i
extern int j = 10; // 定义j
```
`变量能且只能被定义一次，但可以被多次声明`
##### 2.2.3 标识符
**变量命名规范**：
+ 标识符由字母，数字，下划线组成，其中必须以字母或下划线开头
+ 大小写敏感
+ 变量名一般用小写字母
+ 用户自定义类名一般以大写字母开头

***

#### 2.3 复合类型
##### 2.3.1 引用
**引用(reference)** 为对象起了另外一个名字，引用类型引用(refers to)另外一种类型。
```C++
int ival = 1024;
int &refVal = ival; // refVal使ival的另一个名字，共享内存地址
int &refVal2; // 报错：引用必须初始化
```
`引用必须初始化`
初始化变量时，初始值会被拷贝到新建的对象中。而定义引用时，程序把引用和它的初始值**绑定**在一起。
> 引用并非对象，相反的，它只是为一个已经存在的对象所起的另一个名字。引用的初始值必须是一个对象

##### 2.3.2 指针
**指针(Pointer)** 本身是个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。指针无需在定义时赋初始值。
```C++
int *ip1, ip2; // ip1和ip2都是指向int类型的指针
double dp, *dp2; // dp2是指向double类型的指针，dp是double类型的对象
```

**获取对象的地址 &**
```C++
int ival = 42;
int *p = &ival; // p存放变量ival的地址，需要使用取地址符(&)
```

**使用解引用符 * 来访问指针指向的对象**
```C++
// 符号的多重含义
int i = 42; 
int &r = i; // & 表示引用
int *p; // * 表示指针
p = &i; // & 表示获取地址
*p = i; // * 表示解引用
int &r2 = *p; // 创建一个int类型的引用绑定到指针p指向的int类型对象
```
> C++11 新标准，使用字面值nullptr来初始化空指针

***

#### 2.4 const限定符
**const**关键字限定的变量的值不能被改变。
`因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。`

如果利用一个对象去**初始化**另一个对象，则它们是不是const都无关紧要
```C++
int i = 42;
const int ci = i; // i的值被拷贝给了ci
int j = ci; // ci的值被拷贝给了j
```

默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。如果需要共享const对象，我们可以在一个文件中定义const，而在其他多个文件中声明并使用这个const对象。

> 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字

##### 2.4.1 const的引用
可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为**对常量的引用(reference to const)**。与普通引用不同的时，对常量的引用不能被用作修改它所绑定的对象
```C++
const int ci = 1024;
const int &ri = ci; // 引用及其对应的对象都是常量
r1 = 42; // 错误，r1是对常量的引用
int &r2 = ci; // 错误，非常量无法引用一个常量
```

初始化**常量引用**时允许用任意表达式作为其实值，只要该表达式的结果能转换成引用的类型即可
```C++
const int &r2 = 42 // 正确，r2是一个常量引用，可以初始化为一个字面值常量
```

**对const的引用可能引用一个并非const的对象**。常量引用仅对应用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是一个非常量，所以允许通过其他途径改变它的值：
```C++
int i = 42;
int &r1 = i; // 绑定r1到i
const int &r2 = i; // 绑定常量引用r2到i
r1 = 0; // r1并非常量，可以修改i的值为0
r2 = 0; // r2是一个常量引用
```
r2绑定(非常量)整数i是一个合法行为。然而不允许通过r2修改i的值。但i的值仍能通过其他方式被修改，比如绑定r1进行修改。


**总结：**
+ 常量引用必须初始化
+ 初始化常量引用可以使用任意表达式，只要类型相同
+ 初始化常量引用可以绑定常量和**非常量**
+ 对于常量对象只能由常量引用绑定


##### 2.4.2 指针和const
**指向常量的指针(pointer to const)** 可以改变所值的对象，但不能改变所指对象的值。
```C++
const double pi = 3.14; // 创建一个double类型的常量
double *ptr = &pi; // 错误，因为ptr是一个非常量指针，无法指向一个常量
const double *cptr = &pi; // 正确，指向常量的指针cptr可以指向常量pi
*cptr = 42; // 错误，因为cptr是一个指向常量的指针，所以不能修改其指向地址值中的值
```
指向常量的指针可以指向一个非常量，但不能改变非常量的值，非常量的值可以通过其他方式改变。
> 所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的指

**const指针：**指针可以是一个常量。常量指针必须初始化，而且一旦初始化完成，它的值，即存放在指针中的那个**地址值**就不能被改变了。即不变的是指针本身的值而非指向的那个值。
```C++
int errNumb = 0;
int *const curErr = &errNumb; // curErr将一直指向errNumb
const double pi = 3.1415;
const double *const pip = &pi; // pip是一个指向常量的常量指针
```

`方法是从右向左读：const double *const pip 指得是，本身是一个常量指针，指向的类型是常量double`

##### 2.4.3 顶层const
**顶层const (top-level const)：** 表示指针本身是个常量
**底层const (low-level const)：** 表示指针指向的是一个常量

当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受影响。因为执行拷贝操作不会改变被拷贝对象的值，因此拷入考出的对象是否是常量都没什么问题。

对于底层const，当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说**非常量可以转换成常量，反之则不行。**

##### 2.4.4 constexpr 和常量表达式
**常量表达式(const expression)：** 是指值不会改变并且在编译过程就得到计算结果的表达式。显然，字面值属于常量表达式。
一个对象是不是常量表达式由它的数据类型和初始值共同决定，即本身要是常量，且初始值要是字面值或者常量表达式。

> C++11 新标准规定，允许将变量声明为**constexpr**类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。

```C++
constexpr int mf = 20; // 20是常量表达式
constexpr int limit = mf + 1; // mf是常量表达式
constexpr int sz = size(); // 只有当size是一个constexpr函数时才是一条正确的声明语句
```

`一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。`

**字面值类型**
常量表达式的值需要在编译时就得到计算，那么对用到的类型需要加以限制。
算术类型，引用和指针都属于字面值类型。

一个constexpr的指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。

constexpr限定符仅对指针有效，对所指的对象无关
```C++
const int *p = nullptr // 指向常量的指针
constexpr int *q = nullptr // 常量指针
```
与其他常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量。

***

#### 2.5 处理类型
##### 2.5.1 类型别名
类型别名是一个名字，它是某种类型的同义词
使用关键字 **typedef**
```C++
typedef double wages; // wages是double的同义词
```

> C++11 新标准规定使用**别名生命(alias declaration)** 来定义类型别名，使用关键字**using**

##### 2.5.2 auto 类型说明符

> C++11 新标准引入了**auto**类型说明符，用它就能让编译器替我们去分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型。所以auto定义的变量必须有初始值。

`auto会忽略掉顶层const，但是会保留底层const`

##### 2.5.3 decltype类型指示符
> C++11 新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。

`切记：decltype((variable)) 双层括号的结果永远是引用，而引用必须要初始化。而decltype(variable)结果只有当variable本身就是一个引用时才是引用。`

#### 2.6 自定义数据结构

使用**struct** 和**class** 关键字定义数据结构。
