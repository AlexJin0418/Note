# 面向连接的运输：TCP
TCP是因特网运输层的面向连接的可靠的运输协议

## TCP 连接
TCP被称为**面向连接(connection-oriented)**，是因为一个进程在开始与另外一个进程发送数据之前，这两个进程必须线相互“握手”，即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。作为TCP连接建立的一部分，连接的双方都将初始化与TCP连接相关的许多TCP状态变量。

TCP连接只在端系统中运行，所以TCP连接是一条逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中。

TCP连接提供的是**全双工服务(full-duplex service)**：如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就可以在从进程B流向进程A的同时，也可以从进程A流向进程B。

TCP连接也是**点对点(point-to-point)**的，即在单个发送方和单个接收方之间的链接。

TCP发送方和接收方都有缓存。通过套接字接收到应用层数据后，TCP会将数据存在缓存中，发送缓存是发起三次握手期间设置的缓存之一。接下来TCP会时不时从发送缓存中取出一块数据。并将数据传递到网络层。

TCP报文段中数据的数量受限于**最大报文段长度(Maximum Segment Size, MSS)**。MSS通常根据最初确定的由本机发送主机发送的最大链路层帧长度(**最大传输单元，Maximum Transmission Unit, MTU**)来设置。

设置MSS要保证一个TCP报文段加上TCP/IP的部首长度(通常40字节)将适合单个链路层帧。即 **MSS + TCP/IP Header <= MTU。**

## TCP 报文段结构
TCP为每块客户数据配上一个TCP首部，从而形成多个**TCP报文段(TCP segment)**。

TCP报文段由首部字段和一个数据字段组成。数据字段包含一块应用数据。

![TCP_segment_structure](https://res.cloudinary.com/harlan9613/image/upload/v1589599172/Computer_Network/TCP_segment_structure_z53xli.png)

如前所述，MSS限制了报文段数据字段的最大长度。

**source port#， dest port#：** 源端口号和目的端口号用于多路复用/分解来自或送到上层应用的数据。

**sequence number：** 32比特的序号字段，用来表示**当前传输的报文段首字节的字节流编号**。在数据传输中，TCP隐式地对数据流中地每一个字节编号。假定一个数据流由一个包含500000字节的文件组成，其MSS为1000字节，数据流首字节编号是0，那么 500000 / 1000 = 500。总共由500个报文段，每个报文段的编号长度是1000。

**acknowledgement number：** 32比特的确认号字段。确认号字段表示**当前主机期望收到的字节流编号**。即主机A向主机B发送一个报文段中ACK为70，那么主机A就期望从主机B发回的报文段中，主机B的sequence number为70。当出现失序到达时，接收方会保留失序的字节，并等待缺少的字节以填补该间隔。

**head len：** 部首长度字段表示TCP首部长度。

**flag field：** 6比特长的标志字段。
+ U: URG 比特用来指示报文段里存在着被发送方的上层实体置为“紧急”的数据。并不常用。
+ A：ACK 表示确认字段中的值是有效的，即成功接收报文段的确认。
+ P：PSH 指示接收方应立即将数据交付至上层
+ RSF: RST, SYN, FIN 比特用于连接建立和拆除

**reveive window field：** 接收窗口字段，用于流量控制，指示接收方愿意接受的字节数量。

**checksum：** 检验和字段，用于检验数据是否出错。

**Urg data pointer：** 紧急数据的指针。

## TCP往返时间的估计与超时
TCP如果rdt协议一样，采用超时/重传机制来处理报文段的丢失问题。

对于超时/重传机制的问题在于**设置超时间隔长度**。

显然，超时间隔必须大于该连接的往返时间(RTT)，即从一个报文段发出到它被确认的时间。否则会造成不必要的重传。

**1. 估计往返时间**
报文段的样本RTT(sampleRTT)就是从某报文段被发出到对该报文段的确认被收到的之间的时间量。在任意时刻，仅为一个已发送的但目前尚未被确认的报文段估计 SampleRTT，从而产生一个接近每个RTT的新SampleRTT值。

显然，由于路由器的拥塞和端系统负载的变化，这些报文段的SampleRTT值会随之波动。因此，为了估计一个典型的RTT，自然要采取某种对SampleRTT取平均的办法。TCP会维持一个SampleRTT均值(称为EstimatedRTT)。一旦获得一个新的SampleRTT时，TCP就会根据下列公式来更新：

**EstimatedRTT = (1-a) * EstimatedRTT + a * SampleRTT**

即 EstimatedRTT 的新值是由以前的 EstimatedRTT 值与 SampleRTT 新值的加权组合而成。a 的值推荐为 a = 0.125。

![Estimated_RTT](https://res.cloudinary.com/harlan9613/image/upload/v1589603897/Computer_Network/EstimatedRTT_zk4rnm.png)

可以看出，通过加权平均计算后的 EstimatedRTT 相较于 SampleRTT 的值更为平滑。

除了估算 RTT 之外，测量 RTT 的变化也是有价值的。RTT 偏差 DevRTT，用于估算 SampleRTT 一般会偏离 EstimatedRTT 的程度。

![DevRTT](https://res.cloudinary.com/harlan9613/image/upload/v1589604097/Computer_Network/DevRTT_q4qmbh.png)

如果 RTT 的值波动越小，那么 DevRTT 的值就会很小；另一方面，如果 RTT 的值波动很大，那么 DevRTT 的值就会很大。

**2. 设置和管理重传超时间隔**
假设已经给出了 EstimatedRTT 值和 DevRTT 值，那么TCP超时间隔应该用什么值呢？很明显，超时间隔应该大于等于 EstimatedRTT，否则会造成不必要的重传。但是超时间隔也不应该比 EstimatedRTT 大太多，否则当报文段丢失时，TCP不能很快地重传该报文段，导致数据时延大。因此为 EstimatedRTT 留出一定地余量。

![Timeout_Interval](https://res.cloudinary.com/harlan9613/image/upload/v1589604350/Computer_Network/Timeout_interval_owqb93.png)

推荐的初始值 TimeoutInterval 为1秒。当出现超时后，TimeoutInterval值将加倍，以免即将被确认的后继报文段过早出现超时。然而，只要收到报文段并更新 EstimatedRTT，就使用上述公式再计算 TimeoutInterval。

## 可靠数据传输
由于网络层的IP协议是不可靠的，无法保证数据的交付，不保证数据按序交付，也不保证数据交付的完整性。所以TCP在IP不可靠的尽力而为服务上创建了一种**可靠数据传输服务 (reliable transfer serveice)**。

TCP的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏，无间隙，非冗余和按序的数据流。

相较于rdt可靠传输服务中为每一个分组都设定一个计时器而言，TCP使用**单一**的重传定时器，即使有多个已发送但还未被确认的报文段。

![TCP_sender](https://res.cloudinary.com/harlan9613/image/upload/v1589607914/Computer_Network/TCP_sender_zfpxps.png)

TCP 发送方由三个事件组成：
1. **从上层应用接收数据：** TCP从应用程序接收数据，将数据封装在一个报文段中，并把该报文段交给IP。TCP通过报文段序号来记录当前报文段的信息。如果此时定时器还没有为某些其他报文段而运行，则当报文段被传给IP时，TCP就启动该定时器。该定时器的过期间隔是 TimeoutInterval，由 EstimatedRTT 和 DevRTT 计算得出。

2. **定时器超时：** 如果发生定时器超时，那么TCP重传具有最小序号但仍未应答的报文段。

3. **收到ACK：** 到达一个来自接收方的确认报文段。当该事件发生时，TCP将ACK的值与 SendBase 进行比较。SendBase是最早未被确认的字节的序号。因为TCP采用累积确认，所以ACK的确认序号是在**确认一个或多个先前未被确认的报文段**。

**TCP 实例：**

![TCP_Example1](https://res.cloudinary.com/harlan9613/image/upload/v1589608360/Computer_Network/TCP_example1_iepuh8.png)

**由于确认丢失而重传：** 在此例中，发送方向接收方发送序号为 92 的分组，在发送时启动计时器。接收方收到了序号为 92 的分组，并向发送方发送确认分组 100，表示期望发送方下一次发送序号为 100 的分组。此时ACK分组丢失，计时器超时。这时候发送方的最小序号为确认的分组是 92，于是发送方重新发送分组 92，并成功收到了确认分组 100。下一步发送方将发送分组 100。

![TCP_Example2](https://res.cloudinary.com/harlan9613/image/upload/v1589608360/Computer_Network/TCP_example2_tbxf9r.png)

**报文段100没有重传：** 在此例中，发送方连续向接收方发送了分组 92，100。接收方收到了分组，并向发送方反馈ACK分组 100，120。但由于网络或其他原因，发送方在超时之后还未收到确认分组，于是重传了最小序号为确认的分组 92。在重传之后，第二次计时器超时之前发送方收到了分组 92，100的确认分组，此时发送方不会重传第二个分组。同时，接收方会对接收到的分组进行记录，所以当重传分组 92 到达时，接收方会返回 ACK 120 已告知发送方分组 100 也已经收到。

![TCP_Example3](https://res.cloudinary.com/harlan9613/image/upload/v1589608361/Computer_Network/TCP_example3_sufwni.png)

**累积确认避免了一个报文段的重传：** 在此例中，在计时器范围内，发送分组 92，100 都被接收方收到，并且接收方向发送方反馈了 ACK 分组。此时 ACK 100 丢失，但 ACK 120 到达。因为TCP是累积确认，所以当收到 ACK 120 分组时，发送方可以确认之前的两个分组都被接收到。由此避免了报文段的重传。

**超时间隔加倍：** TCP重传具有最小序列号的还未被确认的报文段。**每次TCP重传时都会将下一次的超时间隔设为先前值得两倍**。因此超时间隔在每次重传后会呈指数型增长。然而，每当定时器在收到上层应用得数据和收到ACK中得任意一个启动时，TimeoutInterval由最近得 EstimatedRTT 值与 DevRTT 值推算得到。这种修改提供了一个形式受限的拥塞控制。避免了由重传分组导致得拥塞严重。

**快速重传：** 当超时由于超时间隔加倍而变得很长时，较长得周期迫使发送方延迟重传丢失的分组，因此增加了端到端的延时。当接收方收到一个大于当前期望报文段的数据流时，它检测到数据流中出现了间隔，即有分组丢失。此时接收方将重复向发送方发送期望的确认分组。当收到三个冗余分组时，发送方将执行快速重传，将中间丢失的分组传送给接收方。

**是回退N步还是选择重传：** TCP确认是累积式的，正确接收但失序的报文段是不会被接收方逐个确认的。TCP发送方仅需维持已发送过但未被确认的字节的最小序号和下一个要发送的字节的序号。这种以一下，TCP看起来更像一个GBN风格的协议。但是TCP会将正确接收但失序的报文段缓存起来。而且TCP不会重传所有分组，只是会重传当前最小未被确认的分组。从此来看，TCP的差错恢复机制也许式GBN协议和SR协议的混合体。

## 流量控制
一条TCP连接的每一侧主机都为该连接设置了接收缓存。当TCP连接收到正确，按序的字节后，它就将数据放入接收缓存。如果某应用程序读取数据时相对缓慢，而发送方发送的太多，太快，发送的数据就会很容易地使该链接地接收缓存溢出。

TCP为它地应用程序提供了**流量控制服务 (flow-control service)** 以消除发送方使接收方缓存溢出的可能性。流量控制因此是一个速度匹配服务。

TCP通过让发送方维护一个称为 **接收窗口 (receieve window)** 的变量来提供流量控制。接收窗口用于给发送方一个指示 -- 该接收方还有多少可用的缓存空间。

假设主机A向主机B发送一个文件。主机B为该连接分配了一个接收缓存，并用 RcvBuffer 来表示其大小。主机B上的应用进程不时地从该缓存中读取数据。我们定义以下变量:
+ LastByteRead：主机B上的应用进程从缓存读出的数据流的最后一个字节的编号。
+ LastByteRcvd：从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个字节的编号。

由于TCP不允许已分配的缓存溢出，下式必须成立：
LastByteRcvd - LastByteRead <= RcvBuffer

接收窗口用 rwnd 表示，根据缓存可用空间数量来设置：
rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]

由于该空间是随着时间变化的，所以 rwnd 是动态的。

同时，主机A需要轮流跟踪两个变量，LastByteSent 和 LastByteAcked，LastByteSent - LastByteAcked 就是主机A发送到连接中但未被确认的数据量。通过使这个 LastByteSent - LastByteAcked 控制在 rwnd 以内，就可以保证主机A不会使主机B的缓存溢出。

TCP规范中要求：当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存将开始情况，并且确认报文里将包含一个非0的 rwnd 值，由此来告诉主机A可以继续向主机B发送报文段。

## TCP连接
TCP的**三次握手**：
+ 第一步：客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。该报文段不包含任何应用层数据。但是在报文段的首部中的一个标志位 SYN 比特被设置成为 1。另外，客户会随机选择一个初始序号，并将此编号放置于该起始的TCP SYN报文段的序号字段中。

+ 第二步：一旦包含TCP SYN报文段的IP数据到达服务器主机，服务器会从该数据报中提取出 TCP SYN 报文段。为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段。允许连接的报文段也不包含应用层数据，但是在报文段的首部包含3个重要信息。首先 SYN 比特被设置成1。其次，TCP报文段首部的确认号被设置成 client_isn + 1。最后，服务器选择自己的初始序号，server_isn，并将其放在到TCP报文段首部的序号字段中。这个允许连接的报文段实际上表明了：“我收到了你发起建立连接的SYN分组，该分组带有初始序号 clinet_isn。我同意建立该连接。我自己的初始序号是 server_isn”。

+ 第三步：在收到SYNACK报文段后，客户也要给连接分配缓存和变量。客户主机则向服务器发送另一个报文段；这最后一个报文段对服务器的允许链接的报文段进行了确认 (该客户通过将值 server_isn+1 放置到 TCP 报文段首部的确认字段中来完成此项工作)。因为连接已经建立了，所以该 SYN 比特被置为 0。该三次握手的第三个阶段可以在报文段负载中携带客户到服务器的数据。

当TCP关闭连接的时候，客户TCP会向服务器进程发送一个特殊的TCP报文段。这个特殊的报文段让其首部中的一个标志位即 FIN 比特设置位1。当服务器接收到该报文段后，就向发送方回送一个确认报文段。然后，服务器发送它自己的终止报文段，其 FIN 比特被置为1。最后，该客户对这个服务器的终止报文段进行确认。此时，两台主机上用于该连接的所有资源都被释放了。
