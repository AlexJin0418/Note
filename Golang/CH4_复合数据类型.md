# 复合数据类型

复合数据类型是由基本数据类型以各种方式组合而构成的。

Go中有四种比较重要的复合数据类型，分别是数组、slice、map和结构体。

## 4.1 数组

数组是具有**固定长度**且拥有零个或多个相同数据类型元素的序列。

数组中的每个元素可以通过索引来访问，索引从0到数组长度减1。

数组的初始化：
```go
var a [3]int // 3个整数的数组a

var q [3]int = [3]int{1,2,3} // 有三个初始化值的数组q

z := [...]int{1,2,3} // 使用“...”来默认数组长度为初始化元素的个数
```

数组的长度是数组类型的一部分，所以`[3]int`和`[4]int`是两种不同类型的数组。数组的长度必须是常量表达式，也就是在编译时数组的长度就可以被确定。

数组也可以通过索引和索引对应的值来进行初始化

```go
r := [...]int{0:1, 1:3, 6:-1}  

for i := 0; i < len(r); i++ {
  fmt.Println(r[i]) // 1, 3, 0, 0, 0, 0, -1
}
```

上例中初始化数组的第0，1，6索引号的元素，其余元素初始化为零值。

如果一个数组的元素类型是**可比较的**，那么这个数组也是可比较的。使用`==`操作符可以比较两个数组的元素是否完全相同。不同数组类型的数组不可以进行比较。

```go
a := [2]int{1, 2}

b := [...]int {1, 2}

c := [2]int{1, 3}

fmt.Println(a == b, a == c, b == c) // "true, false, false"

d := [3]int{1, 2}

fmt.Println(a == d) // "Compile error" 
```

当调用一个函数的时候，每个传入的参数都会创建一个副本，然后赋值给对应的函数变量，所以函数接受的是一个副本，而不是原始的参数。

使用这种方式传递大的数组会变得很低效，并且在函数内部对数组的任何修改都仅影响副本，而不是原始数组。

可以显式地传递一个数组的指针给函数，这样在函数内部对数组的任何修改都会反映到原始数组上面。

```go
func zero(ptr *[32]byte) {
  for i := range ptr {
    ptr[i] = 0
  }
}
```

使用数组指针是高效的，同时允许被调函数修改调用方数组中的元素，但是因为数组长度是固定的，所以数组本身是不可变的。
