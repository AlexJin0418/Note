# 复合数据类型

复合数据类型是由基本数据类型以各种方式组合而构成的。

Go中有四种比较重要的复合数据类型，分别是**数组、slice、map和结构体**。

## 数组

数组是具有**固定长度**且拥有零个或多个相同数据类型元素的序列。

数组中的每个元素可以通过索引来访问，索引从0到数组长度减1。

数组的初始化：
```go
var a [3]int // 3个整数的数组a

var q [3]int = [3]int{1,2,3} // 有三个初始化值的数组q

z := [...]int{1,2,3} // 使用“...”来默认数组长度为初始化元素的个数
```

数组的长度是数组类型的一部分，所以`[3]int`和`[4]int`是两种不同类型的数组。数组的长度必须是常量表达式，也就是在编译时数组的长度就可以被确定。

数组也可以通过索引和索引对应的值来进行初始化

```go
r := [...]int{0:1, 1:3, 6:-1}  

for i := 0; i < len(r); i++ {
  fmt.Println(r[i]) // 1, 3, 0, 0, 0, 0, -1
}
```

上例中初始化数组的第0，1，6索引号的元素，其余元素初始化为零值。

如果一个数组的元素类型是**可比较的**，那么这个数组也是可比较的。使用`==`操作符可以比较两个数组的元素是否完全相同。不同数组类型的数组不可以进行比较。

```go
a := [2]int{1, 2}

b := [...]int {1, 2}

c := [2]int{1, 3}

fmt.Println(a == b, a == c, b == c) // "true, false, false"

d := [3]int{1, 2}

fmt.Println(a == d) // "Compile error" 
```

当调用一个函数的时候，每个传入的参数都会创建一个副本，然后赋值给对应的函数变量，所以函数接受的是一个副本，而不是原始的参数。

使用这种方式传递大的数组会变得很低效，并且在函数内部对数组的任何修改都仅影响副本，而不是原始数组。

可以显式地传递一个数组的指针给函数，这样在函数内部对数组的任何修改都会反映到原始数组上面。

```go
func zero(ptr *[32]byte) {
  for i := range ptr {
    ptr[i] = 0
  }
}
```

使用数组指针是高效的，同时允许被调函数修改调用方数组中的元素，但是因为数组长度是固定的，所以数组本身是不可变的。

## slice
slice 表示一个拥有相同类型元素的可变长度的序列。
 
slice是一种轻量级的数据结构，可以用来访问底层数组的部分或者全部元素。

slice有三个属性：**指针**、**长度**和**容量**。

+ 指针：指向底层数组的第一个可以从slice中访问的元素，这个元素不一定是数组的第一个元素。

+ 长度：指slice中的元素个数，不能超过slice的容量。使用内置函数`len`来返回长度。

+ 容量：指从slice的起始元素到底层数组的最后一个元素间元素的个数，表示slice可用的长度范围。使用内置函数`cap`来返回容量。

```go
// 一个底层数组可以对应多个slice，这些slice可以引用数组的任何位置，且彼此之间的元素可以重叠

a := [...]int{1,2,3,4,5,6,7,8,9}  // 创建一个底层数组

s1 := a[2:4]                      // s1 = [3 4]
s2 := a[1,6]                      // s2 = [2 3 4 5 6]
s3 := a[:]                        // s3 = [1 2 3 4 5 6 7 8 9]
```

**slice的范围**

slice的操作符 `s[i:j]`，其中 (0 <= i <= j <= cap(s))。s[i:j]中的元素包括[i ... j - 1]。

如果slice的引用超过了被引用对象的容量(cap)，那么会导致程序宕机；但是如果slice的引用超过了被引用对象的长度，即len(s)，那么最终新的slice会比原slice长

```go

// slice可以创建一个比原slice长度更长的slice，但是不能超过容量
fmt.Println(s2)                   // [2 3 4 5 6]

s4 := s2[0:8]                     // [2 3 4 5 6 7 8 9]
```

**slice作为参数**

因为slice包含了一个指向底层数组的指针，所以slice可以作为函数的参数来进行传递。

在函数中对slice的修改会同时修改底层数组

```go
package main

import "fmt"

func main () {
  a := [...]int{1,2,3,4,5,6,7}
  fmt.Println(a)                      // [1 2 3 4 5 6 7]
  
  s := a[1:5]
  fmt.Println(s)                      // [2 3 4 5]
  
  Zero(s)
  
  fmt.Println(s)                      // [0 0 0 0]  slice可以作为参数传递
  
  fmt.Println(a)                      // [1 0 0 0 0 6 7] 因为指向底层数组，所以对slice的修改会影响底层数组
}

func Zero (a []int) {
  for i := 0; i < len(a); i++ {
    a[i] = 0
  }
}
```

**数组与slice对比**

数组的长度是固定的；而slice的长度是可以变化的，slice可以理解为一种对底层数组的引用。

和数组一样，slice也按照顺序指定元素，也可以通过索引来指定元素，或者两者结合。

数组作为参数传递时相当于对原数组进行复制传值，对参数的改变不会影响到原数组；而slice因为有指向数组的指针，所以作为参数被改变时会影响到原数组。

slice无法做比较，因此不能用==来测试两个slice是否拥有相同的元素。因为slice元素不是直接的，所以如果底层数组元素改变，同一个slice在不同时间会拥有不同的元素。所以slice不能通过简单的==进行比较。

**slice的零值**

slice拥有零值，其零值是`nil`。值为nil的slice没有**对应的底层数组**。值为nil的slice长度和容量都是零。

但是也有非nil的slice长度和容量是零。比如`[]int{}`，这里slice有对应的底层数组，但是并没有初始化长度以及容量。

所以，如果想检查一个slice是否为空，那么使用`len(s) == 0`，而不是`s == nil`，因为`s != nil`的情况下，slice也有可能是空。

**使用make内置函数**

内置函数`make`可以创建一个具有指定元素类型、长度和容量的slice。其中容量参数可以省略，这种情况下，slice的长度和容量相等。

```go
make([]T, len)
make([]T, len, cap)     // 和 make([]T, cap)[:len]功能相同
```
