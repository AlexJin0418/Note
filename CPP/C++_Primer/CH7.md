# 第7章 类
类的基本思想是**数据抽象(data abstraction)**和**封装(encapsulation)**。

数据抽象是一种依赖于**接口(interface)** 和**实现(implementation)** 分离的编程技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员，负责接口实现的函数体以及定义类所需的各种私有函数。

封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。

## 定义抽象数据类型
示例程序定义了一个Sales_data类和组成接口的非成员函数
```C++
struct Sales_data {

    // 声明内部成员函数
    std::string isbn() const { return bookNo; }
    Sales_data& combine(const Sales_data&);
    double avg_price() const;
    
    // 声明内部成员变量
    std::string bookNo;
    unsigned units_sold = 0;
    double revene = 0.0;
};

// 声明在Sales_data类外部的非成员接口函数
Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);
```

#### 定义成员函数
虽然成员函数和成员变量都需要在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外。使用.h和.cpp文件分离声明和定义成员函数是一种比较好的方式。isbn()函数被定义在了类内。
```C++
std::string isbn() const { return bookNo; } // 被声明且定义在类内部的函数
```

#### 引入this
对于isbn成员函数的调用
```C++
Sales_data total;
total.isbn();
```
当我们调用成员函数时，实际上是在替某个对象调用它。如果`isbn`指向`Sales_data`的成员，比如`bookNo`，则`isbn`隐式地指向**调用该函数的对象的成员**。在上面的调用中，当 `isbn`返回`bookNo`时，实际上它隐式地返回`total.bookNo`。

成员函数通过一个名为**this**的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化**this**。如果调用
```C++
total.isbn();
```
则编译器负责把`total`的地址传递给`isbn`的隐式形参`this`，可以等价地认为编译器将该调用重写成了如下地形式：
```C++
// 伪代码
Sales_data::isbn(&total)
```
因为成员函数有了`this`的隐式参数来访问调用它的对象，那么我们可以直接使用**调用该函数的对象的成员**。任何对类成员的直接访问都被看作`this`的隐式引用，也就是说，当`isbn`使用`bookNo`时，它隐式地使用`this`指向的成员，就像我们书写了`this->bookNo`一样。
所以我们可以把`isbn`的定义写成如下形式：
```C++
std::string isbn() const { return this->bookNo; }
```

#### 引入const成员函数
`isbn`函数的另一个关键之处是紧随参数列表之后的`const`关键字，这里`const`的作用是修改隐式`this`指针的类型。
默认情况下，`this`的类型是一个指向非常量的常量指针。因为`this`在成员函数中总是指向调用成员函数的对象，所以`this`是一个常量指针，`this`中保存的地址。所以在上例中，`this`的类型是
```C++
Sales_data *const
```
这就意味着我们不能将`this`绑定在一个**常量对象**上，因为`this`是一个指向非常量的常量指针。这一情况使得我们不能在一个**常量对象**上调用普通的成员函数。

那么我们可以将`this`声明成一个**指向常量的常量指针**：
```C++
const Sales_data *const
```
因为指向常量的指针即可以指向一个常量，也可以指向一个非常量。那么调用该成员函数的对象可以即是**常量对象**也可以是**普通对象**。这样有助于提高函数的灵活性。

因为`this`是**隐式的且不会出现在参数列表中**，所以我们将`const`关键字放在成员函数的参数列表之后。此时，紧跟在参数列表后面的`const`表示`this`是一个指向常量的指针。像这样的成员函数被称作**常量成员函数(const member function)**。

> 常量对象，以及常量对象的引用或指针都只能调用常量成员函数。

#### 类作用域和成员函数
类本身是一个作用域。类的成员函数的定义嵌套在类的作用域之内。

即使成员变量`bookNo`定义在成员函数`isbn`之后，`isbn`还是能够使用`bookNo`。编译器分两步处理类：首先编译**成员的声明**，然后才轮到**成员函数体**。因此，成员函数体可以随意使用类中的成员而无须在意这些成员出现的次序。

#### 在类的外部定义成员函数
当我们在类外部定义成员函数时，成员函数的定义与它的声明匹配。
```C++
double Sales_data::avg_price() const {
    if (units_sold) {
        return revenue / units_sold;
    }
    else {
        return 0;
    }
}
```
函数名`Sales_data::avg_price`使用作用域运算符来说明：我们定义了一个名为`avg_price`的函数，并且该函数被声明在类`Sales_data`的作用域内。

#### 定义一个返回this对象的函数
成员函数`combine`表示调用该函数的对象和传入参数的对象进行复合赋值运算。
```C++
Sales_data& Sales_data::combine(const Sales_data &rhs) {
    units_sold += rhs.units_sold; // 把rhs的成员加到this对象的成员上
    revenue += rhs.revenue;
    return *this; // 返回调用该函数的对象
}
```
当我们使用对象调用该函数时
```C++
total.combine(trans);
```
`total`的地址被绑定到隐式的**this参数上**，而`rhs`绑定到了`trans`上。
因为我们将左值隐式的绑定在了`this`参数，所以我们需要返回一个相同类型的对象。因为`this`指针指向了调用该成员函数的对象，那么返回值就是**解引this指针**。
```C++
return *this;
```

### 定义类相关的非成员函数
类经常需要定义一些辅助函数。这些函数不属于类本身，不是成员函数，而是作为类的接口组成部分。
> 一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。

### 构造函数
构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。构造函数没有返回类型。

如果类没有显示地定义构造函数，那么编译器会为我们隐式地定义一个默认构造函数。一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。

> 只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数

#### 定义Sales_data类构造函数
```C++
Struct Sales_data {
    Sales_data() = default; // 默认构造函数
    Sales_data(const std::string &s): bookNo(s) {}
    Sales_data(const std::string &s, usigned n, double p):
                bookNo(s), units_sold(n), revenue(p*n) {}
    // ...
}
```
默认构造函数不接受任何形参。在C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上 **= default** 来要求编译器生成构造函数。

#### 构造函数初始值列表
在构造函数后面冒号后是一个成员变量初始值的列表，每个名字后面括号内的值就是初始值。

通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在我们就能确保为成员赋予了一个正确的值。如果不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型地成员。

***
## 访问控制与封装
在C++语言中，我们使用**访问说明符(access specifiers)** 加强类的封装性：
+ 定义在 public 说明符之后的成员在整个程序内可被访问，public成员定义类的接口。
+ 定义在 private 说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了类的隐藏细节。

#### 使用 class 和 struct 关键字
`struct`和`class`都能定义类。如果使用`struct`关键字，则定义在第一个访问说明符之前的成员是**public**的；相反，如果我们使用`class`关键字，则这些成员是**private**的。
> 使用class和struct定义类唯一的区别就是默认的访问权限。

### 友元
类可以允许其他类或者函数访问它的**非公有(private)成员**，方法是令其他类或者函数成为它的**友元(friend)**。

友元函数需要友元声明。友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。

> 一般来说，最好在类定义开始或结束前的位置集中定义友元

#### 友元的声明
友元的声明仅仅指定了**访问的权限**，而非一个通常意义上的函数声明。所以需要在友元声明之外再专门对函数进行一次声明。

为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中。
***

## 类的其他特性
### 类成员再探
除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名
```C++
class Screen {
public:
    typedef std::string::sizetype pos;
private:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
}
```
用来定义类型的成员必须**先定义后使用**。

#### 令成员作为内联函数
`内联函数使告诉编译器将函数的内容整段得复制到当前段落中去，可以省去调用函数的开销，但会增加程序的体积。`

在类中，常有一些规模较小的函数适合于被声明成**内联函数**。

我们可以在类的内部把`inline`作为声明的一部分显式地声明成员函数，同样的，也能在类地外部用`inline`关键字修饰函数地定义。
```C++
inline
Screen &Screen::move(pos r, pos c)
{
    //...
}
```

不过，最好只在类外部定义的地方说明`inline`，这样可以使类更容易理解。

> 和我们在头文件中定义inline函数的原因一样，inline成员函数也应该与相应的类定义在同一个头文件中。

#### 重载成员函数
和非成员函数一样，成员函数也可以被重载，只要函数之间在**参数的数量和/或类型上有所区别就行**。

#### 可变数据成员
有时(但并不频繁)会发生这样一种情况，我们希望能修改类的某个数据成员，即使是在一个`const`成员函数内。可以通过在变量中声明`mutable`关键字做到这一点。
```C++
pclass Screen {
public:
    void some_member() const;
private:
    mutable size_t access_ctr;
}

void Screen::some_member() const
{
    ++access_ctr;
    // 函数继续
}
```

尽管`some_member`是一个`const`成员函数，它仍然能够改变`access_ctr`的值。

#### 类数据成员的初始值
当我们初始化类类型的成员时，需要为构造函数传递一个符合成员类型的实参。

> 当我们提供一个类内初始值时，必须以符号=或者花括号表示。

### 返回*this的成员函数
```C++
class Screen {
public:
    Screen &set(char);
    Screen &set(pos, pos, char);
}

inline Screen &Screen::set(char c)
{
    return *this;
}
```
`set`成员的返回值是调用`set`的对象的引用。返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本。

如果我们返回的是`Screen`而不是`Screen&`，那么就相当于创建了一个副本，并改变了副本的值，而不是改变调用对象的值
```C++
// 如果返回Screen而非Screen&
Screen temp = myScreen.set('c');
```

#### 从const成员函数返回*this
一个const成员函数如果以引用的形式返回*this，那么它返回类型将是常量引用

#### 基于const的重载
因为非常量版本的函数对于常量对象是不可用的，所以我们只能在一个常量对象上调用const成员函数。这时候需要将成员函数重载以便适应const和非const的对象。

### 类类型
每个类定义了唯一的类型。对于两个类来说，即使它们的成员完全一样，这两个类也是两个不同的类型。

#### 类的声明
我们可以仅仅声明类而暂时不定义它：
```C++
class Screen;
```
这种声明被称作**向前声明(forward declaration)**，它向程序中引入了名字Screen并且指明Screen是一种类类型。

对于一个类来说，在我们创建它的对象之前该类必须被定义过。类似的，类也必须首先被定义，然后才能用引用或者指针访问其成员。

### 友元再探
类可以把其他的类定义成友元，也可以把其他类的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。

如果一个类A想要访问类B的私有成员，那么类B需要将类A设置成它的友元类。当一个类指定了友元类，则友元类的成员函数可以访问此类包括非共有成员在内的所有成员。

> 每个类负责控制自己的友元类或友元函数

#### 令成员函数作为友元
除了令整个类作为友元外，类还可以只为某个其他类中的成员函数提供访问权限。当把一个成员函数声明成友元时，我们必须**明确指出该成员函数属于哪个类**。
```C++
class Screen {
    // 明确指出了成员函数属于哪个类
    friend void Window_mgr::clear(ScreenIndex);
}
```
想要令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的批次依赖关系。

#### 函数重载和友元
尽管重载函数的名字相同，但是它们仍是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明。

#### 友元声明和作用
类和非成员函数的声明不是必须在它们的友元声明之前。就算在类的内部定义友元函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，**即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的**。
***

## 类的作用域



