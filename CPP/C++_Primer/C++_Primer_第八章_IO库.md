# C++ Primer 第八章 IO库

C++语言不直接处理输入输出，而是通过一族定义在标准库中的类型来处理IO。这些类型支持从设备读取数据、向设备写入数据的IO操作，设备可以是文件、控制台窗口等。

## IO类

IO类型定义在三个独立的头文件中

+ `iostream`：定义了用于读写流的基本类型
+ `fstream`：定义了读写命名文件的类型
+ `sstream`：定义了读写内存`string`对象的类型



类型 `ifstream `和 `istringstream` 都继承自 `istream`，所以可以对这些对象使用cout，同理，也可以用 >> 从一个`ifstream` 或者 `istringstream` 对象中读取数据



### IO对象无拷贝或赋值

我们不能拷贝或对IO对象赋值

由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型

进行IO操作的函数通常以**引用**方式传递和返回流



### 条件状态

IO操作一个与生俱来的问题是可能发生错误，有的错误是可以恢复的，有的错误则发生在系统深处

IO库定义了一个与机器无关的 `iostate` 类型，它提供了表达流状态的完整功能

IO库定义了4个 `iostate` 类型的 `constexpr` 值表示特定的位模式，这些值用来表示特定类型的IO文件

+ `strm::badbit` 表示系统及错误，如不可恢复的读写错误。一旦 badbit 被置位，流就无法再使用了
+ `strm::failbit` 表示发生可恢复的错误，当问题修复后，流还可以继续使用
+ `strm::eofbit` 表示流到达了文件结束
+ `strm::goodbit` 表示流未处于错误状态。此值保证为0

标准库还定义了一组函数来查询这些标志位的状态：

+ `s.rdstate()` 返回流当前条件状态，返回类型为 `strm::iostate`
+ `s.setstate(flags)` 根据给定的 flags 标志位，将流中对应条件位复位
+ `s.clear()` 将流中所有的条件位复位，将流的状态设置为有效
+ `s.clear(flags)` 根据给定的 flags 标志位，将流中对应条件状态位复位
+ `s.good()` 若流处于有效状态，则返回 true
+ `s.bad()` 如流的 `badbit` 置位，则返回 true
+ `s.fail()` 如流的 `failbit` 置位，则返回 true
+ `s.eof()` 如流的 `eofbit` 置位，则返回 true



> 什么情况下，下面的 while 循环会终止？
>
> ```C++
> while (cin >> i) /* ... */
> ```
>
> 当输入流遇到了文件结束符，IO流错误或读入无效数据时都会终止 while 循环
>
> `cin >> i` 等价于判断 `cin.goodbit` 是否为 0，而操作 good 只有在所有错误位均未置位的情况下返回 true
>
> 如果遇到文件结束符 `eofbit`，IO流错误 `badbit ` 或读入无效数据 `failbit` 都会导致 while 循环的终止



### 管理输出缓冲

每个**输出流**都管理一个缓冲区，用来保存程序读写的数据

有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作

导致缓冲刷新（即，数据真正写到输出设备或文件）的原因很多：

+ 程序正常结束，作为 main 函数的 return 操作一部分，缓冲刷新被执行

+ 缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区

+ 可以使用操作符来显式刷新缓冲区

  + `endl` 输出一个换行，然后刷新缓冲区
  + `flush` 刷新缓冲区，不附加任何额外字符
  + `ends` 输出一个空字符，然后刷新缓冲区

+ 在每个输出操作之后，我们可以用操作符 `unitbuf` 设置流的内部状态，来清空缓冲区。它告诉流在接下来的每次写操作之后都进行一次 `flush `操作。默认情况下，对 `cerr` 是设置 `unibuf` 的，因此写到 `cerr` 的内容都是立即刷新的。而 `nounibuf` 操作符则重置流，使其恢复到使用正常的系统管理的缓冲区刷新机制

  + ```C++
    cout << unibuf;		// 所有输出操作后都会立即刷新缓冲区
    ```

+ 一个输出流可能会被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况下，`cin` 和 `cerr` 都关联到 `cout`。因此，读 `cin` 或写 `cerr` 都会导致 `cout` 的缓冲区被刷新  

  + 当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。这意味着，所有输出流内容都会在读操作之前被打印出来
  + `cin >> ival` 会导致 `cout` 的缓冲区刷新



`tie ` 有两个重载版本：

+ 不带参数，返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个输出流的指针，如果对象未关联到流，则返回空指针
+ 带参数，接受一个指向 `ostream` 的指针，将自己关联到此 `ostream`



我们即可以将一个 `istream` 对象关联到另一个 `ostream`，也可以将一个 `ostream` 关联到另一个 `ostream`



## 文件输入输出

头文件 `fstream` 定义了三个类型来支持文件IO：

+ `ifstream` 从一个文件中读取数据
+ `ofstream` 向一个给定文件写入数据
+ `fstream` 可以读写给定文件



### 使用文件流对象

当我们想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来

创建文件流对象时，我们可以提供文件名（可选的）。如果提供了文件名，则 `open` 会自动调用

+ `ifstream in(ifile);	    // 构造一个 ifstream 并打开给定文件`
+ `ofstream out;          // 输出文件流未关联到任何文件`

如果我们定义了一个空文件流对象，可以随后调用 `open` 来将它与文件关联起来

```C++
ofstream out;					// 定义一个未与任何文件关联的输出流对象
out.open(ifile + ".copy");		// 打开指定文件
```

如果调用 `open` 失败，`failbit` 会被置位



对一个已经打开的文件流调用 `open` 会失败，并会导致 `failbit` 被置位。为了将文件流关联到另一个文件，必须先关闭已经关联的文件。一旦文件成功关闭，可以打开新的文件

```C++
out.close();
out.open(ifile + "2");
```



**\*\*当一个 `fstream` 对象被销毁时，其析构函数会自动调用 `close` 来关闭与其关联的文件\*\***



### 文件模式

每个流都有一个关联的**文件模式 (file mode)**，用来指出如何使用文件：

+ in		         以读取方式打开

+ out              以写方式打开

+ app             每次写操作前均定位到文件末尾

+ ate               打开文件后立即定位到文件末尾

+ trunc           截断文件

+ binary         以二进制方式进行IO



无论使用哪种方式打开文件，我们都可以指定文件模式：

+ 只可以对 `ofstream` 或 `fstream` 对象设定 `out` 模式
+ 只可以对 `ifstream` 或 `fstream` 对象设定 `in` 模式
+ 只有当 `out` 也被设定时才可以设定 `trunc` 模式，也就是说只有在写入时才可以截断文件
+ 只要 `trunc` 没被设定，就是设定 `app` 模式。在 `app` 模式下，即使没有显示指定 `out` 模式，文件也总是以输出方式被打开
+ 默认情况下，即使我们没有指定 `trunc`，以 `out` 模式打开的文件也会被截断。为了保留以 `out` 模式打开的文件的内容，我们必须同时指定 `app` 模式，这样只会将数据追加到文件末尾；或者同时指定 `in` 模式，即打开文件同时进行读写操作
+ `ate` 和 `binary` 模式可用于任何类型的文件流对象，且可以与其他任何文件模式组合使用



每个文件流都定义了默认的文件模式，当我们未指定文件模式时，就使用默认模式。`ifstream` 关联的文件默认以 `in` 模式打开；`ofstream` 关联的文件默认以 `out` 模式打开；`fstream` 关联的模式以 `in` 和 `out` 模式打开



**\*\*以 `out` 模式打开文件会丢弃已有数据 \*\***

默认情况下，当我们打开一个 `ofstream` 时，文件的内容会被丢弃

保留被 `ofstream` 打开的文件中已有数据的唯一方法是显式指定 `app` 或 `in` 模式

或者以 `fstream` 打开文件



**\*\*在每次打开文件时，都要设置文件模式，可能是显式地设置，也可能是隐式地设置。当程序未指定模式时，就是用默认值\*\***



