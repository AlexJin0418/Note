# C++ 中 static 关键字

## 1. 程序的存储
内存地址组成

![Image](http://hi.csdn.net/attachment/201102/23/0_1298441225Ylzy.gif)

### 正文段
CPU执行的机器指令部分。通常，正文段是可共享的，所以即使是经常环境指针环境表环境字符串执行的程序(如文本编辑程序、C编译程序、s h e l l等)在存储器中也只需有一个副本，另外，正文段常常是只读的，以防止程序由于意外事故而修改其自身的指令。

### 初始化数据段
通常将此段称为数据段，它包含了程序中需赋初值的变量。初始化的全局变量和静态变量存放在这里。例如，C程序中任何函数之外的说明：int maxcount = 99; 使此变量以初值存放在初始化数据段中。
+ 初始化的全局变量
+ 初始化的静态变量

### 非初始化数据段
通常将此段称为bss段，这一名称来源于早期汇编程序的一个操作符，意思是“block started by symbol（由符号开始的块）”，未初始化的全局变量和静态变量存放在这里。在程序开始执行之前，内核将此段初始化为0。函数外的说明：long sum[1000] ; 使此变量存放在非初始化数据段中。
+ 未初始化的全局变量
+ 未初始化的静态变量

### 堆
需要由程序员分配释放管理，若程序员不释放，程序结束时可能由OS回收。通常在堆中进行动态存储分配。

如程序中的malloc, calloc, realloc等函数都从这里面分配。堆是从下向上分配的。

### 栈
由编译器自动分配释放管理。局部变量及每次函数调用时返回地址、以及调用者的环境信息（例如某些机器寄存器）都存放在栈中。新被调用的函数在栈上为其自动和临时变量分配存储空间。通过以这种方式使用栈，C函数可以递归调用。递归函数每次调用自身时，就使用一个新的栈帧，因此一个函数调用实例中的变量集不会影响另一个函数调用实例中的变量。
+ 局部变量
+ 函数调用时返回地址
+ 调用者的环境信息（例如某些机器寄存器）

## C 语言中的static

### static 局部变量

静态局部变量属于静态存储方式，它具有以下特点：

(1) 静态局部变量在函数内定义它的生存期为整个程序生命周期，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出该函数后，尽管该变量还继续存在，但不能使用它。

(2) 对基本类型的静态局部变量若在声明时未赋以初值，则系统自动赋予0值。而对自动变量不赋初值，则其值是不定的。

```C++
void test_static() 
{
    static int Temp = 1; 
    Temp++; 
    printf("Temp is :%d/n",Temp); 
}
 
int main(int argc,char *argv[]) 
{ 
    int i=0; 
    for(i=0;i<=4;i++) 
    { 
        test_static(); 
    }
 
    system("pause"); 
}
```
事实上，static int Temp = 1; 这句只会在 第一次调用的时候才会执行。

### static 全局变量
在全局变量的说明之前再加以static 就构成了静态的全局变量。

(1) 非静态全局变量的作用域是整个源程序，也即在各个源文件中都是有效的。

(2) 而静态全局变量则只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。

使用静态全局变量的好处是：因此可以避免在其它源文件中引起错误。

### static 函数
定义一个static函数，只需在函数类型前再加一个“static”关键字即可，如下所示:

```C++
static  int fun(int xxx)
{……}
```

此处 "static" 的含义是指对函数的作用域仅局限于本文件。

使用静态函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名，因为同名也没有关系。

## C++ 中的static关键字（类中的static关键字）

### static 数据成员

在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。

```C++
#include <iostream.h>
class Myclass
{
public:
 Myclass(int a,int b,int c);
 void GetSum();
 
private:
 int a,b,c;
 static int Sum; //声明静态数据成员
};
 
int Myclass::Sum=0; //定义并初始化静态数据成员
//static int Myclass::Sum = 0; //注意加static， 是错误的
 
Myclass::Myclass(int a,int b,int c)
{
 this->a=a;
 this->b=b;
 this->c=c;
 Sum+=a+b+c;
}
 
void Myclass::GetSum()
{
 cout<<"Sum="<<Sum<<endl;
}
 
void main()
{
 Myclass M(1,2,3);
 M.GetSum(); // cout 6
 
 Myclass N(4,5,6);
 N.GetSum(); // cout 21
 M.GetSum(); // cout 21
}
```

可以看出，static数据成员有以下特点：
(1) 对于非static数据成员，每个类对象都有自己的拷贝。而static数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。

(2) 静态数据成员存储在全局数据区。静态数据成员定义时才分配空间，所以不能在类声明中定义。

在上例中，语句 `int Myclass::Sum = 0;` 是定义静态数据成员；

(3) 静态数据成员和普通数据成员一样遵从public, protected, private 访问规则；除了定义，定义不要管访问规则。

(4) 因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；

(5) 静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：
```C++
//＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞
 
int Myclass::Sum=0;
```

(6) 类的静态数据成员有两种 访问形式：
```C++
//＜类对象名＞.＜静态数据成员名＞
M.Sum = 0
 
//＜类类型名＞::＜静态数据成员名＞
Myclass::Sum = 0 
```
但是上面这个例子是不行的，因为他是private的变量，如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ；

(7) 静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了；

(8) 同全局变量相比，使用静态数据成员有两个优势： 
a. 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性； 
b. 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；

### static 成员函数

static 成员函数，它为类的全部对象服务而不是为某一个类的具体对象服务。普通的成员函数一般都隐含了一个this指针，但静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的no-static数据成员，也无法访问no-static成员函数，它只能调用其余的静态成员函数。

```C++
#include <iostream.h>
class Myclass
{
public:
 Myclass(int a,int b,int c);
 static void GetSum(); /声明静态成员函数
 
private:
 int a,b,c;
 static int Sum; //声明静态数据成员
};
 
int Myclass::Sum = 0;//定义并初始化静态数据成员
 
Myclass::Myclass(int a,int b,int c)
{
 this->a=a;
 this->b=b;
 this->c=c;
 Sum+=a+b+c; //非静态成员函数可以访问静态数据成员
}
 
//static void Myclass::GetSum(){...} //加上static是错误的
void Myclass::GetSum() //静态成员函数的实现
{
 //cout<<a<<endl; //错误代码，a是非静态数据成员
 cout<<"Sum="<<Sum<<endl; //静态函数是能访问静态数据成员
}
 void main()
{
 Myclass M(1,2,3);
 M.GetSum();
 
 Myclass N(4,5,6);
 N.GetSum();
 
 Myclass::GetSum();
}
```

关于静态成员函数，可以总结为以下几点：

(1) 在类体外，静态函数的定义前不能加关键字static；

(2) static成员之间可以相互访问，包括static成员函数访问static数据成员和访问static成员函数；

(3) 非静态成员函数可以任意地访问静态成员函数和静态数据成员；

(4) 静态成员函数不能访问非静态成员函数和非静态数据成员，只能访问静态的；

(5) 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；

(6) 调用静态成员函数，可以用成员访问操作符(.)和(->)或直接用类名调用静态成员函数
`M.GetSum();`
`Myclass::GetSum();调用类的静态成员函数。`
但是，一样 要遵从 public，protected，private 访问规则 。

## Reference
https://blog.csdn.net/lwbeyond/article/details/6184035
