### 第2章 变量和基本类型

#### 2.1 基本内置类型
##### 2.1.1 算术类型
|类型| 含义 | 最小尺寸|
|---|---|---|
|bool|布尔型|未定义|
|char|字符|8位|
|wchar_t|宽字符|16位|
|char16_t|Unicode字符|16位|
|char32_t|Unicode字符|32位|
|short|短整型|16位|
|int|整型|16位|
|long|长整型|32位|
|long long|长整型|64位|
|float|单精度浮点数|6位有效数字|
|double|双精度浮点数|10位有效数字|
|long double|扩展精度浮点数|10位有效数字|

**带符号和无符号类型**
除去布尔型和扩展的字符型外，其他整型可分为**带符号的(signed)**和**不带符号的(unsigned)**。带符号可以表示正数，负数和0，无符号类型则只能表示大于等于0的值。

##### 2.1.2 类型转换
+ 把非布尔类型赋值给布尔类型：0为false，其他为true
+ 把布尔类型赋值给非布尔类型：false为0，true为1
+ 把浮点类型赋值给整数类型：近似处理，只保留浮点中小数点前的部分
+ 把整数值赋值给浮点类型：小数部分记0
+ 给无符号类型赋值超出表示范围时，结果是初始值对无符号类型表示数值总数取模后的余数
+ 给带符号类型赋值超过表示范围时，结果是**为定义(undefined)**

##### 2.1.3 字面值常量
一个形如42的值被称作**字面值常量(literal)**。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

整型字面值可以写作十进制，八进制和十六进制。默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。

**字符和字符串字面值**实际上由常量字符构成的**数组**。编译器在每个字符串的结尾处添加一个空字符('\0')。

**转义序列**包含两类字符：**不可打印**的字符和**特殊含义**的字符

**布尔字面值**：true / false

**指针字面值**：nullptr
***
#### 2.2 变量
##### 2.2.1 变量定义
当对象在创建时获得了一个特定的值，我们说这个对象被**初始化了(initialized)**。
在C++语言中，初始化和赋值时两个完全不同的操作：
+ 初始化的含义时创建变量时赋予其一个初始值
+ 赋值的含义是把对象的当前值擦除，而以一个新的值来替代

> **c++11的新标准：列表初始化(list initialization)**。可以使用花括号为对象赋初始值
```C++
int x = 0;
int x = {0}; // 列表初始化
int x {0}; // 列表初始化
int x (0);
```
如果我们使用列表初始化且初始值**存在丢失信息**的风险，则编译器将报错。
```C++
long double id = 3.1415926;
int c {id}, b = {id}; // 错误：因为long double类型转换成int存在丢失信息的危险
```

##### 2.2.2 变量声明和定义的关系
C++ 语言支持**分离式编译(separate compilation)**机制，该机制允许将程序分割为若干个文件，每个文件可以被独立编译。
为了支持分离式编译，C++语言将声明和定义区分开来。
+ **声明(declaration)** 使名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明
+ **定义(definition)** 负责创建与名字关联的实体，申请存储空间，也可能为变量赋一个初始值

如果想声明一个变量而非定于它，就在变量名前添加关键字**extern**，而且不要显示地初始化变量。
```C++
extern int i; // 声明i
extern int j = 10; // 定义j
```
`变量能且只能被定义一次，但可以被多次声明`
##### 2.2.3 标识符
**变量命名规范**：
+ 标识符由字母，数字，下划线组成，其中必须以字母或下划线开头
+ 大小写敏感
+ 变量名一般用小写字母
+ 用户自定义类名一般以大写字母开头

***

#### 2.3 复合类型
##### 2.3.1 引用
**引用(reference)** 为对象起了另外一个名字，引用类型引用(refers to)另外一种类型。
```C++
int ival = 1024;
int &refVal = ival; // refVal使ival的另一个名字，共享内存地址
int &refVal2; // 报错：引用必须初始化
```
`引用必须初始化`
初始化变量时，初始值会被拷贝到新建的对象中。而定义引用时，程序把引用和它的初始值**绑定**在一起。
> 引用并非对象，相反的，它只是为一个已经存在的对象所起的另一个名字。引用的初始值必须是一个对象

##### 2.3.2 指针
**指针(Pointer)** 本身是个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。指针无需在定义时赋初始值。
```C++
int *ip1, ip2; // ip1和ip2都是指向int类型的指针
double dp, *dp2; // dp2是指向double类型的指针，dp是double类型的对象
```

**获取对象的地址 &**
```C++
int ival = 42;
int *p = &ival; // p存放变量ival的地址，需要使用取地址符(&)
```

**使用解引用符 * 来访问指针指向的对象**
```C++
// 符号的多重含义
int i = 42; 
int &r = i; // & 表示引用
int *p; // * 表示指针
p = &i; // & 表示获取地址
*p = i; // * 表示解引用
int &r2 = *p; // 创建一个int类型的引用绑定到指针p指向的int类型对象
```
> C++11 新标准，使用字面值nullptr来初始化空指针

***

#### 2.4 const限定符
**const**关键字限定的变量的值不能被改变。
`因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。`

如果利用一个对象去**初始化**另一个对象，则它们是不是const都无关紧要
```C++
int i = 42;
const int ci = i; // i的值被拷贝给了ci
int j = ci; // ci的值被拷贝给了j
```

默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。如果需要共享const对象，我们可以在一个文件中定义const，而在其他多个文件中声明并使用这个const对象。

> 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字

##### 2.4.1 const的引用
可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为**对常量的引用(reference to const)**。与普通引用不同的时，对常量的引用不能被用作修改它所绑定的对象
```C++
const int ci = 1024;
const int &ri = ci; // 引用及其对应的对象都是常量
r1 = 42; // 错误，r1是对常量的引用
int &r2 = ci; // 错误，非常量无法引用一个常量
```

初始化**常量引用**时允许用任意表达式作为其实值，只要该表达式的结果能转换成引用的类型即可
```C++
const int &r2 = 42 // 正确，r2是一个常量引用，可以初始化为一个字面值常量
```

**对const的引用可能引用一个并非const的对象**。常量引用仅对应用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是一个非常量，所以允许通过其他途径改变它的值：
```C++
int i = 42;
int &r1 = i; // 绑定r1到i
const int &r2 = i; // 绑定常量引用r2到i
r1 = 0; // r1并非常量，可以修改i的值为0
r2 = 0; // r2是一个常量引用
```
r2绑定(非常量)整数i是一个合法行为。然而不允许通过r2修改i的值。但i的值仍能通过其他方式被修改，比如绑定r1进行修改。


**总结：**
+ 常量引用必须初始化
+ 初始化常量引用可以使用任意表达式，只要类型相同
+ 初始化常量引用可以绑定常量和**非常量**
+ 对于常量对象只能由常量引用绑定


##### 2.4.2 指针和const
**指向常量的指针(pointer to const)** 可以改变所值的对象，但不能改变所指对象的值。
```C++
const double pi = 3.14; // 创建一个double类型的常量
double *ptr = &pi; // 错误，因为ptr是一个非常量指针，无法指向一个常量
const double *cptr = &pi; // 正确，指向常量的指针cptr可以指向常量pi
*cptr = 42; // 错误，因为cptr是一个指向常量的指针，所以不能修改其指向地址值中的值
```
指向常量的指针可以指向一个非常量，但不能改变非常量的值，非常量的值可以通过其他方式改变。
> 所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的指

**const指针：**指针可以是一个常量。常量指针必须初始化，而且一旦初始化完成，它的值，即存放在指针中的那个**地址值**就不能被改变了。即不变的是指针本身的值而非指向的那个值。
```C++
int errNumb = 0;
int *const curErr = &errNumb; // curErr将一直指向errNumb
const double pi = 3.1415;
const double *const pip = &pi; // pip是一个指向常量的常量指针
```

`方法是从右向左读：const double *const pip 指得是，本身是一个常量指针，指向的类型是常量double`

##### 2.4.3 顶层const
**顶层const (top-level const)：** 表示指针本身是个常量
**底层const (low-level const)：** 表示指针指向的是一个常量

当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受影响。因为执行拷贝操作不会改变被拷贝对象的值，因此拷入考出的对象是否是常量都没什么问题。

对于底层const，当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说**非常量可以转换成常量，反之则不行。**

##### 2.4.4 constexpr 和常量表达式
**常量表达式(const expression)：** 是指值不会改变并且在编译过程就得到计算结果的表达式。显然，字面值属于常量表达式。
一个对象是不是常量表达式由它的数据类型和初始值共同决定，即本身要是常量，且初始值要是字面值或者常量表达式。

> C++11 新标准规定，允许将变量声明为**constexpr**类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。

```C++
constexpr int mf = 20; // 20是常量表达式
constexpr int limit = mf + 1; // mf是常量表达式
constexpr int sz = size(); // 只有当size是一个constexpr函数时才是一条正确的声明语句
```

`一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。`

**字面值类型**
常量表达式的值需要在编译时就得到计算，那么对用到的类型需要加以限制。
算术类型，引用和指针都属于字面值类型。

一个constexpr的指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。

constexpr限定符仅对指针有效，对所指的对象无关
```C++
const int *p = nullptr // 指向常量的指针
constexpr int *q = nullptr // 常量指针
```
与其他常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量。

***

#### 2.5 处理类型
##### 2.5.1 类型别名
类型别名是一个名字，它是某种类型的同义词
使用关键字 **typedef**
```C++
typedef double wages; // wages是double的同义词
```

> C++11 新标准规定使用**别名生命(alias declaration)** 来定义类型别名，使用关键字**using**

##### 2.5.2 auto 类型说明符

> C++11 新标准引入了**auto**类型说明符，用它就能让编译器替我们去分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型。所以auto定义的变量必须有初始值。

`auto会忽略掉顶层const，但是会保留底层const`

##### 2.5.3 decltype类型指示符
> C++11 新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。

`切记：decltype((variable)) 双层括号的结果永远是引用，而引用必须要初始化。而decltype(variable)结果只有当variable本身就是一个引用时才是引用。`

#### 2.6 自定义数据结构

使用**struct** 和**class** 关键字定义数据结构。
***
### 第3章 字符串、向量和数组
#### 3.1 命名空间的using声明
使用**using声明** 可以以更简单的途径来使用到命名空间中的成员。

**每个名字都需要独立的using声明**
> 按照规定，每个using声明引入命名空间中的一个成员。

**头文件不应包含using声明**
如果头文件中由某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。

***

#### 3.2 标准库类型 string
标准库类型**string**表示可变长的字符序列，使用string类型必须包含string头文件
```C++
#include <string>
using std::string;
```

初始化：使用等号(=)执行的的是**拷贝初始化(copy initialization)**，编译器把等号右侧的初始值拷贝到新创建的对象中去。
相反，如果不适用等号，则为**直接初始化(direct initialization)**

**string::size_type类型**
string的size函数返回的类型是string::size_type。这是一个无符号类型的值，而且能足够存放下任何string对象的大小。所有用于存放string类的size函数返回值的变量，都应该是string::size_type。

> C++11新标准允许编译器通过auto或者decltype来推断变量的类型。

因为返回值是一个无符号整型数，那么如果将string::size_type和一个int类型的负数比较时会出错，因为int类型的负数会自动地转换成一个比较大的无符号值。
**所以如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题。**

**比较string对象**
string比较运算符依照字典顺序：
+ 如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。
+ 如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。

字面值可以和string类型相加。
> 因为某些历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是标准库类型string对象。切记，字符串字面值与string是不同的类型。

#### 3.2.3 处理string对象中的字符
cctype头文件中定义了一组标准库函数处理string对象中的字符。
> cctype是C++标准库头文件，由C语言标准库ctype.h转化而来。在命名上更符合标准。

**使用范围for语句改变字符串中的字符**：
如果想要改变string对象中的字符，必须把循环变量定义成引用类型。引用类型是给定对象一个别名，因此当使用引用作为循环控制变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改变它绑定的字符
```C++
#include <string>
using std::string;

string s = "hello world";
for (auto &c : s) {
    c = toupper(c);
}

cout << s << endl; // "HELLO WORLD"
```

**下标运算符 []：** 使用下标运算符能够指定string对象任意位置中的字符
> 使用超出范围的下标将引发不可预知的结果，所以string对象的下标必须大于等于0而小于s.size()

***

### 3.3 标准库类型vector
标准库类型**vector**表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引。vector是一个**类模板(class template)**

使用vector需要声明头文件
```C++
#incldue <vector>
using std::vector;
```

> vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int>

因为引用不是对象，所以不存在包含引用的vector

对于列表初始化，只能使用花括号进行列表初始化，而不能放在圆括号里初始化。

**值初始化：** 通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个**值初始化的(value-initialized)** 元素初值。比如int，元素初始值自动设为0。如果元素是某种类类型，比如string，则元素由类默认初始化。

这种初始化有两种特殊限制：
+ 有些类要求必须明确地提供初始值
+ 如果只提供了元素的数量而没有设定初始值，只能使用直接初始化

**构造和列表初始化：**
+ 使用圆括号初始化：提供的值是用来构造vector对象的，大多提供容量值
+ 使用花括号初始化：花括号内的当作元素初始值的列表来处理

当花括号内的值和vector的类型不同时，在确认无法执行列表初始化后，编译器会尝试用默认初始化vector对象
```C++
vector<string> v1 {10, "hi"}; // 10是int类型无法初始化到string vector中，所以不是列表初始化
```

#### 3.3.2 向vector对象中添加元素
使用成员函数**push_back()** 来向vector尾端添加新的元素。

> C++11标准要求vector能在运行时高效快速地添加元素。有效的办法是先定义一个空的vector对象，再在运行时向其中添加具体值。

`确保所写的循环正确无误，特别是在循环有可能改变vector对象容量的时候`

#### 3.3.3 其他vector操作
vector的empty和size两个成员与string的同名成员功能完全一致：empty检查vector对象是否包含元素然后返回一个布尔值；size则返回vector对象中元素的个数，返回值的类型是由vector定义的size_type类型。
> 要使用size_type，需首先指定它是由哪种类型定义的。vector对象的类型总是包含着元素的类型

`vector可以使用下标[]符访问元素，但不能通过下标符来添加元素`

***

### 3.4 迭代器
















