# 可靠数据传输原理
**可靠数据传输：** 传输数据由一条可靠信道进行传输，传输数据比特不会受到损坏 (由0变成1，或者相反) 或丢失，而且所有数据都是按照其发送顺序进行交付。

实现可靠传输服务抽象是**可靠数据传输协议(reliable data transfer protocol)** 的责任。可靠数据传输协议的下层协议也许是不可靠的。比如TCP是在不可靠的IP端到端网络层之上实现的可靠数据传输协议。

![Reliable_Data_Transfer_Protocol](https://res.cloudinary.com/harlan9613/image/upload/v1589175602/Computer_Network/reliable_data_transfer_protocol_updcvb.png)

a) 对于运输层内的可靠信道，进程可以直接通过可靠信道进行分组交换

b) 对于底层的不可靠传输，进程需要在运输层使用可靠数据传输协议来放置比特丢失或翻转

**可靠数据传输协议服务实现**

![RDT_Service](https://res.cloudinary.com/harlan9613/image/upload/v1589175935/Computer_Network/%E5%9B%BE%E7%89%871_h9z8o7.png)

+ `redt_send()`：由数据发送方进程调用，向可靠数据传输协议较高层发送数据
+ `udt_send()`： 由rdt调用，将数据通过不可靠信道传输给接收方
+ `rdt_rcv()`：由接收方的rdt调用，从不可靠信道中取出到达的分组
+ `deliver_data()`：由接收方的rdt调用，负责将分组中的数据发送给用户进程

## 构造可靠传输协议
### 经完全可靠信道的可靠数据传输：rdt1.0
首先考虑最简单的情况，即**底层信道是完全可靠的**。我们称该协议为 rdt1.0，该协议本身是简单的。

因为底层信道是完全可靠的，所以发送方和接收放不用担心分组是否会有翻转和丢失的情况出现。

![rdt1.0](https://res.cloudinary.com/harlan9613/image/upload/v1589178727/Computer_Network/rdt1.0_zuyrti.png)

**发送端：** rdt通过`rdt_send(data)`从用户进程接收到数据后，通过`make_pkt(data)`将数据打包产生一个包含该数据的分组，并将分组发送到信道中。

**接收端：** rdt通过`rdt_rcv(packet)`从信道中接收到分组，通过`extract(packet,data)`取出数据，并将数据向上层用户进程发送。

因为是完全可靠的信道，所有接收端就不需要提供任何反馈信息给发送方。

### 经具有比特差错信道的可靠数据传输：rdt2.0
底层信道更为实际的模型是**分组中的比特可能受损**的模型。我们眼下还将继续假定所有发送的分组将按其发送的顺序被接收。

当发送端向接收端发送数据时，如果接收端收到的数据受损，那么接收端可能需要向发送端表明收到的数据受损，并要求发送端再次发送数据。这样的机制叫做重传机制。而基于重传机制的可靠数据传输协议称为**自动重传请求(Automatic Repeat reQuest, ARQ)协议**。

ARQ协议中还需要另外三种协议功能来处理存在比特差错的情况：
1. **差错检测**：首先，需要使用一种机制来使接收方检测何时出现了比特差错。一种方法就是使用比特检验和来对分组进行比对。
2. **接收方反馈**：在出现比特差错后，接收方需要向发送方提供反馈。常见的反馈信息有**ACK(肯定确认)**和**NAK(否定确认)**分组。
3. **重传**：接收方收到有差错的分组时，发送方将重传该分组报文。

![rdt2.0](https://res.cloudinary.com/harlan9613/image/upload/v1589179755/Computer_Network/rdt2.0_qjbdrq.png)

**发送方：** rdt通过`rdt_send(data)`从用户进程接收数据，之后通过`make_pkt(data, checksum)`将数据和检验和打包产生一个包含该数据的分组，并将分组发送到信道中。

当分组发送后，发送端将进入等待接收端反馈的阶段。发送方协议等待来自接收方的ACK或NAK分组。如果`rdt_rcv(rcvpkt) && isNAK(rcvpkt)`为真，那么表示接收端没有收到正确的分组，发回了`NAK`的反馈，此时发送方需要再次发送该分组。

而如果`rdt_rcv(rcvpkt) && isACK(rcvpkt)`为真，表示接收端收到了分组，则可以继续等待用户进程发送数据。

**接收方：** rdt首先通过`rdt_rcv(rcvpkt)`从信道获取分组，之后检查该分组是否存在比特损坏的情况。如果有，那么调用`udt_send(NAK)`来告知发送方重新发送分组。如果接收方收到的分组是完整的，那么取出数据并上传至用户进程后再向发送方进行反馈，`udt_send(ACK)`。

> 在rdt2.0协议中，发送方在发出分组后会一直等待接收方的反馈。直到收到接收方的反馈后才会进行下一步。这种协议被称为**停等(stop-and-wait)协议**。

#### ACK/NAK 分组受损的 rtd2.1
rdt2.0协议存在一个致命的缺陷，那就是 **ACK/NAK 分组可能会受损**。当 ACK/NAK 受损时，发送方无法直到接收方的正确反馈。

一种对于受损ACK/NAK分组的解决方法是：发送方再次发送同样的分组。但因为此时接收方不知道收到的分组是新的分组还是一次重传分组，所以这种解决方法会产生**冗余分组(duplicate packet)**。

解决**冗余分组**的方法就是在数据分组中添加一个新的字段，该字段保存了这一分组在发送方的编号。于是，接收方只需要检查该序列号就可以确定收到的分组是否为一次重传。对于停等协议来说，只需要1比特，即0和1就可以分别当前分组是否为当前分组还是上一个已经收到的分组。

此时每一个分组都有一个0或这1来表示其序列号，且当前序列号与前一个发送的分组是不同的。

![rdt2.1_send](https://res.cloudinary.com/harlan9613/image/upload/v1589182084/Computer_Network/rdt2.0_send_sontey.png)

**发送方：** 发送端首先获取序号为0的数据并生成分组后向接收端发送。之后等待接收方的反馈。

如果收到的是ACK，那么发送方会等待用户进程发送序号为1的数据。

如果收到的是NAK或者受损的ACK/NAK包，那么发送方会再次向接收方发送分组0。

![rdt2.1_receiver](https://res.cloudinary.com/harlan9613/image/upload/v1589182084/Computer_Network/rdt2.1_receiver_huig5c.png)

**接收方：** 当接收方第一次收到分组0时会有两种情况，第一种是收到了分组0，第二种是分组0受损。如果收到了分组0，这时候会取出数据并向发送方发送一个ACK，并等待分组1的到来。如果分组受损则会向发送方发送一个NAK包。

在发送方收到了接收方的反馈后，如果反馈没有受损，那么发送方会向接收方发送分组1。此时双方通信都没有受损的分组，通信正常。

如果发送方收到的ACK受损，那么发送方会重复向接收方发送分组0，这时候接收方正在等待分组1，所以只会向发送方发送ACK包，而不会再次取出分组0中的数据，一面重复。

如果发送方收到的是NAK包，那么发送方会重复向接收方发送分组0，而接收方收到分组0后会取出数据并向发送方发送ACK包。此时对于分组0的交换完成。接收方等待分组1的到来。

**因为目前假定信道不会丢分组，ACK和NAK分组本身不需要指明它们要确认的分组序号**。

#### 只有ACK分组的 rdt2.2
rdt2.2是在有比特差错信道上实现的一个无NAK的可靠数据传输协议。这时ACK分组将会使用0或1表示其属于哪一个分组的反馈。如果收到受损的分组，则接收方将发送一个对上次正确接收的分组发送一个ACK，以此来实现和NAK相同的效果。

如果接收方收到的ACK与发送的ACK分组序号不相符，那么就表示接收方没有收到正确的分组，所以重新发送。

![rdt2.2](https://res.cloudinary.com/harlan9613/image/upload/v1589185212/Computer_Network/rdt2.2_w8mle7.png)

### 经具有比特差错的丢包信道的可靠数据传输：rdt3.0
现在假定除了比特受损外 **(发送方能够收到接收方的反馈，无论是ACK还是损坏的分组)**，底层信道还会丢包，这在今天的计算机网络中并不罕见。

这里，我们让发送方负责检测和恢复丢包工作。假定发送方传输一个数据分组，该分组或者接收方对该分组的ACK发生了丢失。在这两种情况下，发送方都收不到应当到来的接收方的相应。如果发送方愿意等待足够长的时间以便确定分组已丢失，则它只需重传该数据分组即可。

发送方应当选择一个时间值来判断是否发生了丢包。如果在这个时间内没有收到ACK或受损分组，则应当重传该分组。

对于发送方来说，不论是数据分组丢失，还是ACK丢失，或者值时分组或ACK过度延时。在所有这些情况下，动作是同样的：重传。为了实现重传机制，需要一个**倒计数定时器 (countdown timer)**，在一个给定的时间量过期后，可中断发送方。

发送方需要做到：1.每次发送一个分组时，便启动一个定时器。2.相应定时器中断。3.终止定时器。

![rdt3.0_sender](https://res.cloudinary.com/harlan9613/image/upload/v1589186294/Computer_Network/rdt3.0_fmguol.png)

**发送方：** 发送方向接收方发送分组0之后，启动计时器并等待接收方的ACK分组。如果接收方收到分组0且返回ACK0，那么发送方准备发送分组1。

如果接收方收到了分组0，但分组0损坏，则向发送方发送ACK1。此时发送方会停止计时器，并再次向接收方发送分组0。

如果接收方没有收到分组0，或者ACK0在传输过程中丢包，导致计时器超时，那么发送方会再次向接收方发送当前分组0。

接收方会根据分组的序号来判断当前分组是否为重复分组。

![rdt3.0_example1](https://res.cloudinary.com/harlan9613/image/upload/v1589186294/Computer_Network/rdt3.0_example1_ezmwyx.png)

a) 发送方和接收方都没有丢包，则传输正常。

b) 发送方在发送分组1时出现丢包，此时接收方收不到任何分组，则不会向发送方发送反馈。在超时后，发送方会再次发送分组1。

![rdt3.0_example2](https://res.cloudinary.com/harlan9613/image/upload/v1589186295/Computer_Network/rdt3.0_example2_pl3dok.png)

c) 发送方成功发送了分组1，且接收方收到了分组1，但是ACK1分组丢失。此时发送方发送了分组1一段时间后仍收不到任何反馈，于是再次发送分组1。此时接收方识别到新到来的分组1是重复分组，于是向发送方再次发送ACK1。

d) 发送方成功发送了分组1，接收方也发送了ACK1，但是由于大延时发送方没有在时限内收到ACK1。于是发送方重新发送了分组1。在发送了分组1之后发送方收到了ACK1分组，这时候发送方开始发送分组0。对于接收方来说，第二次收到分组1时因为是重复分组，所以再次向发送方发送了ACK1。而收到了新的分组0后，向发送方发送了ACK0分组。发送方第二次收到了ACK1的分组，于是再次向接收方发送了分组0。这样再第一次时延之后，发送方和接收方会重复发送相同的分组。

## 流水线可靠数据传输协议
rdt3.0是一个功能正确的协议。但是rdt3.0性能问题的核心在于它是一个停等协议。也就是说发送方必须获得接收方的反馈后才能发送新的分组。

发送方发送一个分组后还要承受数据到达接收方以及接收方返回反馈分组的时延，所以即便链路的吞吐量很大，效率仍然很低。

对于这种性能问题的解决方法是：**不以停等的方式运行，允许发送方发送多个分组而无需等待确认**。

因为许多从发送方向接收方输送的分组可以被看成是填充到一条流水线中，故这种技术被称为**流水线 (pipelining)**。

流水线技术对可靠数据传输协议可带来如下影响：
+ 必须增加序号范围，因为每个输送中的分组必须有一个唯一的序号，而且也许有多个在输送中的未确认报文。
+ 协议的发送方和接收方两端也许不得不缓存多个分组。发送方最低限度应当能缓冲那些已发送但没有确认的分组。接收方需要缓存那些已正确接收的分组。
+ 所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失，损坏以及延时过大的分组。解决流水线的差错恢复有两种方法：**回退N步**和**选择重传**。

### 回退N步 Go-Back-N, GNB
在回退N步协议中，允许发送方发送多个分组而不需要等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数N。

![GBN_window](https://res.cloudinary.com/harlan9613/image/upload/v1589334264/Computer_Network/GBN_window_cee2gj.png)

+ 窗口由N个分组组成
+ base前的窗口表示发送且已被确认的分组
+ base到nextseqnum之间的分组表示已发送还未被确认的分组
+ nextsequm到base+N-1之间的分组表示可以使用但还未发送的分组
+ base+N-1之后的分组表示不可用分组

GBN也被称为**滑动窗口协议 (sliding-window protocol)**

**GBN 发送方：**

![GBN_FSM](https://res.cloudinary.com/harlan9613/image/upload/v1589334336/Computer_Network/GBN_sender_w5xtjf.png)

+ 发送方首先检查下一个分组是否在窗口内，`nextseqnum < base+N`，如果超出了窗口的范围，则通知上层进程取消数据传递。如果在范围内，且要发送的分组是窗口的第一个分组时，开始计时器。同时增加nextseqnum。

+ 当长时间未收到任何接收方反馈时，则重新启动计时器，并发送窗口内所有已发送但未确认的分组。

+ 在GBN协议中，对序号为n的分组的确认采取**累计确认(cumulative acknowledgement)**方式，表明接收方已正确接收到序号为n的以前且包括n在内的所有分组。

+ 当接收到一个ACK时，将base向后移动一位，表示整个窗口都向后移动。并且重设计时器。

**GBN 接收方：**

![GBN_RCV](https://res.cloudinary.com/harlan9613/image/upload/v1589334820/Computer_Network/GBN_rcv_z9r6su.png)

+ 如果一个序号为n的分组被正确接收到，并且按序，则接收方为分组n发送一个ACK，并且将该分组中的数据全部交付到上层。

+ 在所有其他情况下，接收方丢弃该分组，并为**最近按序接收的分组**重新发送ACK。

**接收方只需要维护的信息是下一个按序接收的分组的序号。发送方强制接收方按照发送顺序接收分组。**

**GBN例子：**

![GBN_in_action](https://res.cloudinary.com/harlan9613/image/upload/v1589335100/Computer_Network/GBN_in_action_z2gtq1.png)

+ 此时发送方的窗口长度为4，则发送方会依次发送前4个分组。

+ 接收方首先正确的接收到了分组0和分组1，且向发送方反馈了ACK。发送方的窗口被向后移动。

+ 分组2并没有到达接收方且丢包。同时发送方又向接收方发送了分组3，4，5。此时接收方缓存了下一个按序接收的分组的序号为2，所以其他任何分组都将被丢弃，且接收方会向发送方反馈重复的分组1ACK。

+ 当分组2的计时器超时后，发送方将重新从第一个发送但没有确认的分组开始发送，这里是分组2。所以发送方将重新发送分组2，3，4，5。

+ 当窗口内的所有分组都被发送完后，发送方需要等待接收方反馈ACK分组，以此来移动窗口，继续发送。

### 选择重传 Selective Repeat

GBN存在的问题在于单个分组的出错会导致大量的分组重传。

选择重传协议通过让发送方仅重传那些它怀疑在接收方面出错的分组而避免了不必要的重传。

这种个别的，按需的重传要求接收方逐个地确认正确接收地分组。

![SR](https://res.cloudinary.com/harlan9613/image/upload/v1589338500/Computer_Network/SR_jwwlpu.png)

+ 在发送方窗口内，有一部分的分组被接收，而有一部分的分组已发送但未确认

+ SR接收方将确认一个正确接收的分组而不管其是否按序。失序的分组将被缓存直到所有丢分组皆被收到为止。

+ 接收方收到分组后会将窗口移动

**SR 例子：**

![SR_in_action](https://res.cloudinary.com/harlan9613/image/upload/v1589338849/Computer_Network/sr_in_action_xppm3h.png)

+ 发送方首先发送 0，1，2，3 分组。发送完当前窗口内的所有分组后发送方等待。

+ 接收方收到分组 0，1 并反馈ACK，同时分组 2 丢失。此时接收方窗口内为 2，3，4，5。在收到分组3后将分组3的内容缓存

+ 发送方收到分组 0，1 的ACK分组后，移动窗口，发送分组 4，5

+ 接收方收到分组 4，5。因为分组2丢失，所以同样接收方缓存分组 4，5。并向发送方发送分组 4，5 的ACK。

+ 此时发送方分组2的计时器超时，发送方重新发送分组2。之后分组 4，5 的ACK已经到达。但是因为分组2的ACK没有收到，所以发送方窗口无法移动。

+ 接收方收到了分组2，于是分组 2，3，4，5 可以按照顺序交付，同时接收方的窗口移动至 6，7，8，9

+ 发送方收到分组2的ACK后，可以移动窗口至 6，7，8，9。传输继续。

因为在SR中，发送方和接收方窗口有可能是不同步的。因为如果接收方收到分组，但是发送方丢失ACK分组时，接收方的窗口会移动，但是发送方窗口不会移动。所以在有限的分组序号中，**如果接收窗口过大的话**，很可能出现发送方重传分组和接收方等待新分组的序号是相同的。

所以对于SR协议而言，**窗口长度必须小于或等于序号空间大小的一半**。假设当前接收窗口起始地址在序号空间的中心，如果窗口大小大于一半，那么窗口会覆盖序号空间的后半部分和少量前半部分。如果之前分组的ACK丢失的话，发送方的窗口还会留在序号空间的前一半。这样会出现接收方等待的新分组的序号和发送方将要重传分组的序号相同。

## 小结
此部分中学习了运输层协议能够提供可靠数据传输，即使下面的网络层是不可靠的。我们应该理解在链路层，网络层，运输层或应用层协议中都可以提供可靠运输传送。该协议栈中上面4层的任意一层都可以实现**确认，定时器，重传以及序号**，能够向其上层提供可靠数据传输。
