# 7.二叉树

二叉树能够解决计算机中的查找问题

二分查找法只能用于有序的数组

二分查找法的时间复杂度为 Log(n)



## 代码实现 Binary Search

```C++
// Binary search
// Only works for sorted array
// If finds target, return index
template<typename T>
int binarySearch(T arr[], int n, T target)
{
	int l = 0, r = n - 1;
	while (l <= r)
	{
		//int mid = (l + r) / 2;
		int mid = l + (r - l) / 2;
		if (arr[mid] == target)
		{
			return mid;
		}

		if (target < arr[mid])
		{
			r = mid - 1;
		}
		else
		{
			l = mid + 1;
		}
	}

	return -1;
}

```



## 二叉树的优势

二叉树可以高效地查找数据

还可以高校插入



二叉树

+ 每个节点地值大于左孩子
+ 每个节点地值小于右孩子
+ 以左右子节点为根节点地树仍为二叉树
+ 二分搜索树不一定是完全二叉树



![binary_search_tree](https://github.com/harlan0103/Note/blob/master/.assets/DataStructure%26Algorithm/binary_search_tree.png)





## 二分搜索树地遍历

**深度优先遍历：DFS**

前序遍历：先访问当前节点，再依次访问左右子树

中序遍历：先访问左子树，再访问自身，再访问右子树

后续遍历：先递归访问左右子树，再访问自身节点



终须排序用于顺序打印整个二叉树

后序遍历用于释放整个二叉树

```C++
// Pre-order traversal BST
void preOrder(Node* node)
{
    if (node != NULL)
    {
        cout << node->key << endl;
        preOrder(node->left);
        preOrder(node->right)
    }

}

// In-order traveral BST
void inOrder(Node* node)
{
    if (node != NULL)
    {
        inOrder(node->left);
        cout << node->key << endl;
        inOrder(node->right);
    }
}

// Post-order traversal BST
void postOrder(Node* node)
{
    if (node != NULL)
    {
        postOrder(node->left);
        postOrder(node->right);
        cout << node->key << endl;
    }
}
```



## 广度优先遍历

广度优先遍历能够按照二叉树的层级来遍历整个二叉树





## 删除任意节点

删除节点时，通过找寻其右子节点中的最小值

右子节点的最小值满足大于原节点的所有左子节点，且小于原节点的所有右子节点



```C++
// Find minimum node
Node* findMin(Node* node)
{
    if (node -> left == NULL)
    {
        return node;
    }

    return findMin(node->left);
}

// Delete minimum node
Node* deleteMin(Node* node)
{
    if (node -> left == NULL)
    {
        Node* rightNode = node->right;	// No matter NULL or not
        delete node;
        count--;
        return node->right;
    }

    node->left = deleteMin(node->left);
    return node;
}

// Remove target node
Node* remove(Node* node, Key key)
{
    if (node == NULL)
    {
        return NULL;
    }

    if (key < node -> key)
    {
        node->left = remove(node->left, key);
        return node;
    }
    else if (key > node->key)
    {
        node->left = remove(node->right, key);
        return node;
    }
    else
    {
        // key == node->key
        if (node -> left == NULL)
        {
            Node* rightNode = node->right;
            delete node;
            count--;
            return rightNode;
        }

        if (node->right == NULL)
        {
            Node* leftNode = node->left;
            delete node;
            count--;
            return leftNode;
        }

        // node->left != NULL && node->right != NULL
        Node* successor = new Node(findMin(node->right));
        count++;

        successor->left = node->left;	// 左侧子节点不变
        successor->right = deleteMin(node->right);	// 右侧子节点变成删除右侧最小节点的子节点

        delete node;
        count--;
        
        return successor;
    }
}
```



