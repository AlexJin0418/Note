# 5. 快速排序 Quick Sort

快速排序从当前选择中选择一个元素作为基点

然后将这个元素想办法放置在其排好序的位置

之后对于小于这个元素以及大于这个元素的左右两部分进行递归排序

![quick_sort](https://github.com/harlan0103/Note/blob/master/.assets/DataStructure%26Algorithm/quick_sort.png)

算法思路

![quick_sort_1](https://github.com/harlan0103/Note/blob/master/.assets/DataStructure%26Algorithm/quick_sort_1.png)



```C++
template<typename T>
void conqureHelper(T arr[], int l, int mid, int r)
{
    // Need a temp array
    T* temp = new T[r - l + 1];

    for (int i = l; i <= r; i++)
    {
        temp[i - l] = arr[i];
    }

    // Based on segment [l ... mid] and [mid + 1 ... r]
    // Rearrange all
    int i = l, j = mid + 1;
    for (int k = l; k <= r; k++)
    {
        if (i > mid)
        {
            arr[k] = temp[j - l];
            j++;
        }
        else if (j > r)
        {
            arr[k] = temp[i - l];
            i++;
        }
        else if (temp[i - l] > temp[j - l])
        {
            arr[k] = temp[j - l];
            j++;
        }
        else
        {
            arr[k] = temp[i - l];
            i++;
        }
    }
    delete[] temp;
    return;
}

template<typename T>
void divideHelper(T arr[], int l, int r)
{
    // range: [l ... r]
    if (l >= r)
    {
        return;
    }

    int mid = (l + r) / 2;

    divideHelper(arr, l, mid);
    divideHelper(arr, mid + 1, r);
    conqureHelper(arr, l, mid, r);
}
```



## 快速排序存在的问题

快速排序存在的问题在于

如果使用快速排序对一个近似于顺序的数组进行判断时

那么每次使用第一个元素作为基底元素的话

每一次的 subtree 都只会生成右侧，因为右侧几乎没有元素小于当前的基底元素

则 subtree 的层级则会近似于 n 层

最终的时间复杂度会接近于 O(n^2)



#### 解决方法

一个解决方法是，每次选择基底点时先随机选择区间内的一个点

并将其交换到首位作为基底点



## 双路快速排序

双路快速排序能够解决数据量大且很多数据相等的情况

当重复元素过多时会将整个数组分成两个极度不平衡的分组



```C++
// 双路快速排序
template<typename T>
int __partition2(T arr[], int l, int r)
{
    T v = arr[l];

    // arr[l+1...i] <= v; arr[j...r] >= v
    int i = l + 1, j = r;
    while (true)
    {
        // 确保 arr[i] 是小于 v 的
        while (i <= r && arr[i] < v)
        {
            i++;
        }

        while (j >= l + 1 && arr[j] > v)
        {
            j--;
        }

        if (i > j)
        {
            break;
        }

        swap(arr[i], arr[j]);
        i++;
        j--;
    }
    // 此时 i > j
    // j 表示的是最后一个小于 v 的元素
    swap(arr[l], arr[j]);

    return j;
}
```

