# 4. 归并排序 Merge Sort

归并排序思路：

将数组一分为二，将左边和右边的部分分别排序

![merge_sort](https://github.com/harlan0103/Note/blob/master/.assets/DataStructure%26Algorithm/merge_sort.png)



分治之后，将每个子序列进行排序，然后对左右分支进行归并

![merge_sort1](https://github.com/harlan0103/Note/blob/master/.assets/DataStructure%26Algorithm/merge_sort1.png)



如果有 n 个元素，我们可以将其分成 log(n) 层级

每个层级我们都会处理 n 个元素

如果我们并归的时间复杂度为 O(n)

那么整体的时间复杂度就为 n log(n)



并归排序的并归过程需要开辟一个新的空间来辅助进行并归

所以需要额外的空间复杂度为 O(n)



```C++
template<typename T>
void conqureHelper(T arr[], int l, int mid, int r)
{
    // Need a temp array
    // 创建一个临时数组用来存储区间内的元素
    T* temp = new T[r - l + 1];

    for (int i = l; i <= r; i++)
    {
        temp[i - l] = arr[i];
    }

    // Based on segment [l ... mid] and [mid + 1 ... r]
    // Rearrange all
    int i = l, j = mid + 1;
    for (int k = 0; k < r - l + 1; k++)
    {
        if (i > mid)
        {
            arr[k] = temp[j - l];
            j++;
        }
        else if (j > r)
        {
            arr[k] = temp[i = l];
            i++;
        }
        else if (temp[i - l] > temp[j - l])
        {
            arr[k] = temp[j - l];
            j++;
        }
        else
        {
            arr[k] = temp[i = l];
            i++;
        }
    }
    delete[] temp;
    return;
}

// 分治部分
template<typename T>
void divideHelper(T arr[], int l, int r)
{
    // range: [l ... r]
    if (l >= r)
    {
        return;
    }

    int mid = (l + r) / 2;

    divideHelper(arr, l, mid);
    divideHelper(arr, mid + 1, r);
    if (arr[mid] > arr[mid + 1])
    {
        conqureHelper(arr, l, mid, r);
    }
}

// 并归排序
// 先分治 再并归
template<typename T>
void mergeSort(T arr[], int n)
{
    divideHelper(arr, 0, n - 1);
}
```

