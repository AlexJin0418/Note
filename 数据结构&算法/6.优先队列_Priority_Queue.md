# 6. 优先队列

普通队列：先进先出

优先队列：优先级高的先出



优先队列动态将新加入队列的元素根据优先度进行排序



队列主要操作：

入列

出列 - 取出优先级最高的元素



使用堆的入列和出列时间复杂度为 log(n)



## 二叉堆 Binary Heap

二叉堆是一个完全二叉树：

+ 两个子节点不大于其父节点
+ 除了最后一层，其他层的节点必须是完整的
+ root 值为最大值



### 使用数组存储二叉堆

对于完全二叉树，其左子节点为其位置index的2倍，而右子节点为其位置index的2倍+1

```C++
parent(i) = i / 2;
left child (i) = 2 * i;
right child (i) = 2 * i + 1;
```



### 添加和删除元素

添加新元素的思路就是首先在数组末尾添加一个新的元素

之后和其父节点进行比较，如果新元素比父节点大就交换位置

直到遇到更大的父节点为止



返回首元素的思路是先获取首元素

之后将首元素和末尾元素交换，并减少计数

之后从首元素开始向下遍历并比对所有的左子节点和右子节点

并将父节点和较大的子节点进行交换

直到整个二叉树平衡



```C++
// MAXHEAP

template<typename Item>
class MaxHeap
{
public:
    // 构造函数
	MaxHeap(int capacity)
	{
		data = new Item[capacity + 1];
		count = 0;
		this->capacity = capacity;
	}

   	// 析构函数
	~MaxHeap() 
	{
		delete[] data;
	}

	int size() { return count; }

	bool empty() { return count == 0; }
	
    // 向堆中添加新元素并排序
	void insert(Item item)
	{
		if (count + 1 > capacity)
		{
			return;
		}
		// 元素从1开始
		data[count + 1] = item;
		count++;
		shiftUp(count);
	}

	// 返回第一个元素
	Item pop()
	{
		if (!empty())
		{
			Item res = data[1];
			swap(data[1], data[count]);
			count--;

			shiftDown();

			return res;
		}

		return NULL;
	}
	
    // 打印 Heap
	void print()
	{
		cout << "maxheap: [ ";
		int i = 1;
		for (; i < count; i++)
		{
			cout << data[i] << ", ";
		}

		cout << data[i] << " ]" << endl;
	}

private:
	Item* data;
	int count;
	int capacity;

	void shiftUp(int k)
	{
		while (k > 1 && data[k/2] < data[k])
		{
			swap(data[k/2], data[k]);
			k /= 2;
		}
	}

	void shiftDown()
	{
		int i = 1;
		while (i <= count)
		{
			// check left and right
			int l = i * 2 <= count ? i * 2 : i;
			int r = i * 2 + 1 <= count ? i * 2 + 1 : i;

			int max = data[l] > data[r] ? l : r;
			if (data[max] > data[i])
			{
				swap(data[max], data[i]);
				i = max;
			}
			else
			{
				break;
			}
		}
	}
};

```



## Heapify

对于一个完全二叉树

其所有的子节点都可以看成一个只含有一个元素的最大堆



完全二叉树中，最后一个父节点的位置是 size / 2



Heapify 的思路在于，从最后一个父节点开始从下向上进行交换并得到最大堆



## 索引堆

索引堆将数据和数据原有的index区分存储

数据不需要进行排序

只需要对索引进行排序

索引的下标表示索引所表示的数据的位置

构建堆的过程只需要交换索引



即，索引堆存储的是数据集的下标

通过堆索引堆进行排序来获取数据的顺序

因为索引是 `int` 所以可以避免复杂数据排序带来的消耗



